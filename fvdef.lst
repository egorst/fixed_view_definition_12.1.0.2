SYS@db12> select '+++'||view_name||'+++'||chr(10),view_definition from v$fixed_view_definition order by view_name;
+++GO$SQL_BIND_CAPTURE+++             select INST_ID,                 KQLFBC_PADD,                 KQLFBC_HASH,                 KQLFBC_SQLID,                 KQLFBC_CADD,                 KQLFBC_CHNO,                 substr(KQLFBC_NAME, 1, 30),                 KQLFBC_POS,                 to_number(decode(KQLFBC_DUPPOS, 65535, NULL, KQLFBC_DUPPOS)),                 KQLFBC_OACDTY,                 substr(KQLFBC_DTYSTR, 1, 15),                 decode(KQLFBC_OACCSI, 0, to_number(null), KQLFBC_OACCSI),                 decode(KQLFBC_OACPRE, 0, to_number(null), KQLFBC_OACPRE),                  decode(KQLFBC_OACSCL, 0, to_number(null), KQLFBC_OACSCL),                  KQLFBC_OACMXL,                 decode(KQLFBC_WCAP, 0, 'NO', 'YES'),                 decode(KQLFBC_WCAP, 0, to_date(NULL),                        decode(KQLFBC_WCAP, 2, to_date(NULL), KQLFBC_LCAP)),                 KQLFBC_STRVAL,                  decode(KQLFBC_WCAP, 0, NULL,                                      sys.sys$rawtoany(KQLFBC_BINVAL, KQLFBC_OACDTY,                                        KQLFBC_OACCSF, KQLFBC_OACCSI)),                 CON_ID          from x$kqlfbc
+++GV$ACCESS+++                       select distinct s.inst_id,s.ksusenum,o.kglnaown,o.kglnaobj,o.kglobtyd, o.con_id from x$ksuse s,x$kglob o,x$kgldp d,x$kgllk l where l.kgllkuse=s.addr and l.kgllkhdl=d.kglhdadr and l.kglnahsh=d.kglnahsh and o.kglnahsh=d.kglrfhsh and o.kglhdadr=d.kglrfhdl
+++GV$ACTIVE_INSTANCES+++             select inst_id, ksiminum, rpad(ksimstr,60), con_id from x$ksimsi
+++GV$ACTIVE_SERVICES+++              select inst_id, kswsastabsi, kswsastabnm, kswsastabnmh, kswsastabnn, kswsastabcd, kswsastabcdh,  decode(kswsastabgoal, -1, NULL, 0, 'NONE', 1, 'SERVICE_TIME', 2, 'THROUGHPUT', NULL) kswsastabgoal,  decode(bitand(kswsastabpflg, 2), 2, 'Y', 'N'),  decode(bitand(kswsastabgflg, 1), 1, 'YES', 'NO'),  decode(bitand(kswsastabpflg, 4), 4, 'YES', 'NO'),  decode(bitand(kswsastabpflg, 8), 8, 'LONG', 'SHORT'),  decode(bitand(kswsastabpflg, 32), 32, 'YES', 'NO'),  kswsastabrettm, kswsastabreplayto,  decode(bitand(kswsastabpflg, 64), 64, 'YES', 'NO'),  kswsastabsessstate,  kswsastabpdb, kswsastabsqltrans, kswsastabmaxlagtime, con_id  from x$kswsastab  where kswsastabact = 1
+++GV$ACTIVE_SESSION_HISTORY+++       SELECT  /*+ no_merge ordered use_nl(s,a) */ a.inst_id, s.sample_id, s.sample_time, s.is_awr_sample, a.session_id, a.session_serial#, decode(a.session_type, 1, 'FOREGROUND', 'BACKGROUND'), a.flags, a.user_id, a.sql_id, decode(bitand(a.flags, power(2, 4)), NULL, 'N', 0, 'N', 'Y'), a.sql_child_number, a.sql_opcode, a.force_matching_signature, decode(a.top_level_sql_id, NULL, a.sql_id, a.top_level_sql_id), decode(a.top_level_sql_id, NULL, a.sql_opcode,        a.top_level_sql_opcode), a.sql_opname,a.sql_adaptive_plan_resolved,a.sql_full_plan_hash_value,a.sql_plan_hash_value, decode(a.sql_plan_operation, NULL, to_number(NULL),       a.sql_plan_line_id), a.sql_plan_operation, a.sql_plan_options, decode(a.sql_exec_id, 0, to_number(NULL), a.sql_exec_id), a.sql_exec_start, decode(a.plsql_entry_object_id,0,to_number(NULL),       a.plsql_entry_object_id), decode(a.plsql_entry_object_id,0,to_number(NULL),       a.plsql_entry_subprogram_id), decode(a.plsql_object_id,0,to_number(NULL),a.plsql_object_id), decode(a.plsql_object_id,0,to_number(NULL),a.plsql_subprogram_id), decode(a.qc_session_id, 0, to_number(NULL), a.qc_instance_id), decode(a.qc_session_id, 0, to_number(NULL), a.qc_session_id), decode(a.qc_session_id, 0, to_number(NULL), a.qc_session_serial#), decode(a.px_flags, 0, to_number(NULL), a.px_flags), decode(a.wait_time, 0, a.event,    NULL), decode(a.wait_time, 0, a.event_id, NULL), decode(a.wait_time, 0, a.event#,   NULL), a.seq#, a.p1text, a.p1, a.p2text, a.p2, a.p3text, a.p3, decode(a.wait_time, 0, a.wait_class,    NULL), decode(a.wait_time, 0, a.wait_class_id, NULL), a.wait_time, decode(a.wait_time, 0, 'WAITING', 'ON CPU'), a.time_waited, (case when a.blocking_session = 4294967295         then 'UNKNOWN'       when a.blocking_session = 4294967294         then 'GLOBAL'       when a.blocking_session = 4294967293         then 'UNKNOWN'       when a.blocking_session = 4294967292         then 'NO HOLDER'       when a.blocking_session = 4294967291         then 'NOT IN WAIT'       else 'VALID'  end), (case when a.blocking_session between 4294967291 and 4294967295         then to_number(NULL)       else a.blocking_session  end), (case when a.blocking_session between 4294967291 and 4294967295         then to_number(NULL)       else a.blocking_session_serial#  end), (case when a.blocking_session between 4294967291 and 4294967295         then to_number(NULL)       else a.blocking_inst_id  end), (case when a.blocking_session between 4294967291 and 4294967295         then NULL      else decode(bitand(a.flags, power(2, 3)),NULL, 'N', 0,'N','Y')  end), a.current_obj#, a.current_file#, a.current_block#, a.current_row#,a.top_level_call#, a.top_level_call_name, decode(a.consumer_group_id, 0, to_number(NULL), a.consumer_group_id), a.xid, decode(a.remote_instance#, 0, to_number(NULL), a.remote_instance#), a.time_model, a.in_connection_mgmt, a.in_parse, a.in_hard_parse, a.in_sql_execution, a.in_plsql_execution, a.in_plsql_rpc, a.in_plsql_compilation, a.in_java_execution, a.in_bind, a.in_cursor_close, a.in_sequence_load, a.in_inmemory_query, a.in_inmemory_populate, a.in_inmemory_prepopulate, a.in_inmemory_repopulate, a.in_inmemory_trepopulate, decode(bitand(a.flags, power(2, 5)), NULL, 'N', 0, 'N', 'Y'), decode(bitand(a.flags, power(2, 6)), NULL, 'N', 0, 'N', 'Y'), decode(bitand(a.flags, power(2, 0)), NULL, 'N', 0, 'N', 'Y'), decode(bitand(a.flags, power(2, 2)), NULL, 'N', 0, 'N', 'Y'), a.service_hash, a.program, a.module, a.action, a.client_id, a.machine, a.port, a.ecid, a.dbreplay_file_id, a.dbreplay_call_counter, decode(a.tm_delta_time, 0, to_number(null),        a.tm_delta_time), decode(a.tm_delta_time, 0, to_number(null),        a.tm_delta_cpu_time), decode(a.tm_delta_time, 0, to_number(null),        a.tm_delta_db_time), decode(a.delta_time, 0, to_number(null),         a.delta_time), decode(a.delta_time, 0, to_number(null),         a.delta_read_io_requests), decode(a.delta_time, 0, to_number(null),         a.delta_write_io_requests), decode(a.del
+++GV$ACTIVE_SESS_POOL_MTH+++         select inst_id, policy_name_kgskasp, con_id from x$kgskasp
+++GV$ADVISOR_CURRENT_SQLPLAN+++      select INST_ID,                 KESPLAN_TIMESTAMP,                 KESPLAN_OPER,                 KESPLAN_OOPT,                 KESPLAN_TQID,                 KESPLAN_OBJN,                 KESPLAN_OBJOWNER,                 KESPLAN_OBJNAME,                 KESPLAN_ALIAS,                 KESPLAN_OBJTYPE,                 KESPLAN_OPTI,                 KESPLAN_OPID,                 KESPLAN_PAID,                 KESPLAN_DEPTH,                 KESPLAN_POS,                 KESPLAN_SCOLS,                 KESPLAN_COST,                 KESPLAN_CARD,                 KESPLAN_SIZE,                 KESPLAN_OTAG,                 KESPLAN_PSTA,                 KESPLAN_PSTO,                 KESPLAN_PNID,                 KESPLAN_OTHER,                 KESPLAN_DIST,                 KESPLAN_CPUC,                 KESPLAN_IOCT,                 KESPLAN_TEMP,                 KESPLAN_KEYS,                 KESPLAN_FILTER,                 KESPLAN_PROJ,                 KESPLAN_TIME,                 KESPLAN_QBLOCK,                 KESPLAN_REMARK,                 KESPLAN_OTHER_XML,                 CON_ID          from x$kesplan
+++GV$ADVISOR_PROGRESS+++             select inst_id, ksulosno, ksulosrn, ksulounm, ksulopna, ksuloif5d,                 ksuloctx,  ksulotde, ksulosfr, ksulotot, ksulouni,                          ksuloif3, ksuloif4, ksuloif0,  ksuloif1, ksuloif2,                          to_date(ksulostm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),           to_date(ksulolut,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),           ksuloetm,                                                                   decode(ksuloif6d, null, to_number(null), ksuloif6), ksuloif6d,              ksuloif7d, con_id                                                    from  x$ksulop                                                              where ksulopna in ('Advisor')
+++GV$ALERT_TYPES+++                  SELECT t.inst_id, rid_keltsd, typnam_keltosd,            decode(typ_keltsd, 1, 'Stateful', 'Stateless'), nam_keltgsd,            decode(scp_keltsd, 1, 'Database', 'Instance'),            mtn_keltsd, mtc_keltsd, t.con_id          FROM x$keltsd t, x$keltosd, x$keltgsd          WHERE grp_keltsd = id_keltgsd AND otyp_keltsd = typid_keltosd
+++GV$AQ1+++                          select INST_ID, KWQSIQID , KWQSINWT, KWQSINRD,          KWQSINEX, KWQSIAVGMSGAGE, KWQSINCO, KWQSITWT,          DECODE(KWQSINCO, 0, 0, KWQSITWT/KWQSINCO), CON_ID          from X$KWQSI
+++GV$AQ_BACKGROUND_COORDINATOR+++    select      inst_id, process_id, process_name, num_jobs, job_latency,      num_coordinators, con_id    from X$KWSBGAQPCSTAT
+++GV$AQ_BMAP_NONDUR_SUBSCRIBERS+++    select inst_id, queue_id, USED_POS, con_id from X$BMAPNONDURSUB
+++GV$AQ_CROSS_INSTANCE_JOBS+++       select      inst_id, job_id, schema_name, queue_name, shard_id,      start_subshard_id, destination_instance_id,      coordinator_id, dest_server_process_id,      decode(job_state, 1, 'REQUESTED', 2, 'RUNNING', 3, 'STOPPED',             4, 'PAUSED', 5, 'CRASHED', 6, 'INACTIVE'),      flow_control, reg_msgs_sent, bytes_sent, ack_latency, con_id    from X$KWSCPJOBSTAT
+++GV$AQ_JOB_COORDINATOR+++           select      inst_id, coordinator_id, process_id, process_name, job_name,      job_type, server_count, max_server_count, con_id    from X$KWSBGQMNSTAT
+++GV$AQ_MESSAGE_CACHE+++             select      inst_id, queue_id, shard_id, priority, subshard_id, partition_id,      max_msgs, enqueued_msgs, browsed_msgs,      msgs_made_expired, msgs_made_ready, chunk_size, num_chunks,      num_free_chunks, used_memory_size,      decode(state, 17, 'CACHED_FREE', 18, 'CACHED_FREE',             33, 'CACHED', 34, 'CACHED', 36, 'UNCACHED',             65, 'CACHED', 66, 'CACHED',              129, 'UNCACHED_FREE', 130, 'UNCACHED',              'UNKNOWN'), con_id    from X$MESSAGE_CACHE
+++GV$AQ_MSGBM+++                      select inst_id, queue_id, msgid, bitmap, con_id from X$MSGBM
+++GV$AQ_NONDUR_REGISTRATIONS+++      select      inst_id, kkcneregid, kkcnesub, kkcneloc, kkcneuser, kkcneuserctx,      kkcnectxsz, kkcnens,      kkcnever, kkcnestate, kkcneqos, kkcneregtm, con_id    from X$KKCNEREG
+++GV$AQ_NONDUR_SUBSCRIBER+++         select inst_id, queue_id, subscriber_id, subscriber_name, rule_cond,  trans_owner, trans_name, creation_time, flags, subscriber_type, bitpos,  db_session_id, con_id  from X$nondursub
+++GV$AQ_NONDUR_SUBSCRIBER_LWM+++     select inst_id, queue_id, subscriber_id, shard_id, priority, lwm, con_id   from X$NONDURSUB_LWM
+++GV$AQ_NOTIFICATION_CLIENTS+++      select inst_id, client_id, emon_id, state, num_message_sent,         num_bytes_sent, num_message_received, last_send_time,         last_receive_time, connect_time, disconnect_time,         last_error, con_id from x$kpondconstat
+++GV$AQ_SERVER_POOL+++               select      inst_id, coordinator_id, coordinator_instance_id, process_id,      process_name, job_name, pool_state, con_id    from X$KWSBSMSLVSTAT
+++GV$AQ_SUBSCRIBER_LOAD+++           select inst_id, queue_id, queue_schema, queue_name, subscriber_id,   subscriber_name,   decode (latency_state, 0, 'UNKNOWN',                          1, 'INFINITE',                          2, 'FINITE', 'UNKNOWN') latency_state,    latency, dequeue_requests, active_shards,   decode (active_listener, 0, 'FALSE', 'TRUE'), flags, con_id  from X$AQ_SUBSCRIBER_LOAD
+++GV$ARCHIVE+++                      select le.inst_id,le.lenum,le.lethr,le.leseq, decode(bitand(le.leflg,8),0,'NO','YES'), decode(bitand(le.leflg,8),0,'NO','YES'), to_number(le.lelos), le.con_id from x$kccle le,x$kccdi di where bitand(di.diflg,1)!=0 and le.ledup!=0 and bitand(le.leflg,1)=0 and (to_number(le.lelos)<=to_number(di.difas) or bitand(le.leflg,8)=0)
+++GV$ARCHIVED_LOG+++                 select inst_id,alrid,alstm,alnam,aldst,althp,alseq,to_number(alrls),to_date(alrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(alxlc),to_number(allos),to_date(allot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(alnxs),to_date(alnxt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),albct,albsz,decode(bitand(alflg, 16+32+64+128+256),    16, 'ARCH',    32, 'FGRD',    64, 'RMAN',    128,'SRMN',    256,'LGWR',        'UNKNOWN'),decode(bitand(alflg, 4),    4,  'RFS',    decode(bitand(alflg, 16+32+64+128+256),    16, 'ARCH',    32, 'FGRD',    64, 'RMAN',    128,'SRMN',    256,'LGWR',        'UNKNOWN')),decode(bitand(alflg, 8),0,'NO','YES'),decode(bitand(alflg, 2),0,'NO','YES'),decode(bitand(alflg, 1024),0,              (decode(bitand(alfl2, 16384),0,'NO','IN-MEMORY')),'YES'),decode(bitand(alflg, 1),0,'NO','YES'),decode(bitand(alflg, 1+2048+4096),    0,   'A',    1,   'D',    2048,'X',    4096,'U',         '?'),to_date(altsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(alflg,8192),0,'NO','YES'),decode(bitand(alflg,16384),0,'NO','YES'), decode(bitand(alflg,32768),0,'NO','YES'), to_number(bitand(alfl2,15)), altoa,alacd,decode(bitand(alfl2,64),0,'NO','YES'),  decode(bitand(alfl2,128),0,'NO','YES'), decode(bitand(alflg,512),0,'NO','YES'),  decode(bitand(alfl2,256+512+1024),       256, 'TERMINAL',       512, 'ACTIVATION',      1024, 'RESETLOGS',      decode(bitand(alflg,32768),0,'','SWITCHOVER')), decode(bitand(alfl2,4096), 0, 'NO', 'YES'), con_id from x$kccal
+++GV$ARCHIVE_DEST+++                 select inst_id, to_number(ADDID), ADDXX, decode(ADSTS,1,'VALID',              2,'INACTIVE',              3,'DEFERRED',              4,'ERROR',              5,'DISABLED',              6,'BAD PARAM',              7,'ALTERNATE',              8,'FULL',              9,'IDLE',                'UNKNOWN'), decode(ADMND,0,'OPTIONAL','MANDATORY'), decode(ADSES,0,'SYSTEM','SESSION'), decode(ADRMT,0,'PRIMARY',              1,'STANDBY',              2,'LOCAL',              3,'REMOTE',              4,'BACKUP APPLIANCE',                'UNKNOWN'), decode(ADPRC,0,'ARCH',              1,'LGWR',              2,'FOREGROUND',              3,'RFS',              4,'ONDEMAND',                'UNKNOWN'), decode(ADSCH,0,'INACTIVE',              1,'PENDING',              2,'ACTIVE',              3,'LATENT',                'UNKNOWN'), decode(ADOMF, 0, ADDNM, 'USE_DB_RECOVERY_FILE_DEST'), to_number(ADLSQ), to_number(ADROP), to_number(ADDLY), to_number(ADMCS), to_number(ADNTT), decode(ADWHO,0,'ARCH',              1,'LGWR',              2,'FOREGROUND',              3,'RFS',              4,'ONDEMAND',                'UNKNOWN'), decode(ADREG,0,'NO','YES'), to_date(ADFDT,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(ADFSQ), to_number(ADFBK), to_number(ADFCT), to_number(ADMXF), ADFER, ADALT, ADDPD, ADRFT, to_number(ADQSZ), to_number(ADQSD), ADMID, decode(ADLAB,0,        decode(ADPAR,0,'SYNCHRONOUS',                       'PARALLELSYNC'),                       'ASYNCHRONOUS'), to_number(ADLAB), decode(ADAFF,0,'NO','YES'), decode(ADDTG,0,'PUBLIC','PRIVATE'), decode(ADNOW,1,'YES',              2,'WRONG VALID_TYPE',              3,'WRONG VALID_ROLE',              4,'INACTIVE',                'UNKNOWN'), decode(ADVLD,11,'ONLINE_LOGFILE',              12,'ONLINE_LOGFILE',              13,'ONLINE_LOGFILE',              21,'STANDBY_LOGFILE',              22,'STANDBY_LOGFILE',              23,'STANDBY_LOGFILE',              31,'ALL_LOGFILES',              32,'ALL_LOGFILES',              33,'ALL_LOGFILES',                 'UNKNOWN'), decode(ADVLD,11,'PRIMARY_ROLE',              12,'STANDBY_ROLE',              13,'ALL_ROLES',              21,'PRIMARY_ROLE',              22,'STANDBY_ROLE',              23,'ALL_ROLES',              31,'PRIMARY_ROLE',              32,'STANDBY_ROLE',              33,'ALL_ROLES',                 'UNKNOWN'), ADDBUN, decode(ADVER,0,'NO','YES'), decode(ADCMP,0,'DISABLE','ENABLE'), to_number(ADSCN),  con_id,  decode(ADENC,0,'DISABLE','ENABLE')  from x$krstdest
+++GV$ARCHIVE_DEST_STATUS+++          select inst_id, to_number(DSDID), DSDXX, decode(DSSTS,1,'VALID',              2,'INACTIVE',              3,'DEFERRED',              4,'ERROR',              5,'DISABLED',              6,'BAD PARAM',              7,'ALTERNATE',              8,'FULL',              9,'IDLE',                'UNKNOWN'), decode(DSTYP,1,'LOCAL',              2,'PHYSICAL',              3,'LOGICAL',              4,'CROSS-INSTANCE',              5,'SNAPSHOT',              6,'DOWNSTREAM',              7,'FAR SYNC',              8,'BACKUP APPLIANCE',                'UNKNOWN'), decode(DSDMD,1,'STARTED',              2,'MOUNTED',              3,'MOUNTED-STANDBY',              4,'OPEN',              5,'OPEN_READ-ONLY',                'UNKNOWN'), decode(DSRMD,1,'IDLE',              2,'MANUAL',              3,'MANAGED',              4,'MANAGED REAL TIME APPLY',              5,'LOGICAL REAL TIME APPLY',              6,'LOGICAL APPLY',                'UNKNOWN'), decode(DSPRT,0,'MAXIMUM PERFORMANCE',              1,'MAXIMUM PROTECTION',              2,'MAXIMUM AVAILABILITY',              3,'RESYNCHRONIZATION',                'UNKNOWN'),DSDNM, to_number(DSCNT), to_number(DSACT), to_number(DSLTA), to_number(DSLSA), to_number(DSLTR), to_number(DSLSR), DSERR, decode(DSSRL,0,'NO',                'YES'), DSDBUN, decode(DSPRC, 1, 'CHECK CONFIGURATION',               2, 'CHECK STANDBY REDO LOG',               3, 'CHECK CONNECTIVITY',               4, 'DESTINATION HAS A GAP',               5, 'OK',                  'STATUS NOT AVAILABLE'), decode(DSPRT, 1, 'YES',                2, 'YES',                decode(DSSYNC, 1, 'YES', 'NO')),  decode(DSGAP, 1, 'NO GAP',                2, 'LOG SWITCH GAP',                3, 'RESOLVABLE GAP',                4, 'UNRESOLVABLE GAP',                5, 'LOCALLY UNRESOLVABLE GAP',                NULL),  con_id  from x$kcrrdstat
+++GV$ARCHIVE_GAP+++                  select USERENV('Instance'), high.thread#, low.lsq, high.hsq, 1  from   (select a.thread#, rcvsq, min(a.sequence#)-1 hsq    from      v$archived_log a,      (select thread#, resetlogs_change#, max(sequence#) rcvsq       from v$log_history       where (thread#, resetlogs_change#, resetlogs_time) in         (select lh.thread#, lh.resetlogs_change#, lh.resetlogs_time          from v$log_history lh, v$database_incarnation di          where lh.resetlogs_time = di.resetlogs_time            and lh.resetlogs_change# = di.resetlogs_change#            and di.status = 'CURRENT'        )       group by thread#, resetlogs_change#      ) b    where a.thread# = b.thread#      and a.resetlogs_change# = b.resetlogs_change#      and a.sequence# > rcvsq    group by a.thread#, rcvsq) high,  (select srl_lsq.thread#, nvl(lh_lsq.lsq, srl_lsq.lsq) lsq    from      (select thread#, min(sequence#)+1 lsq       from         v$log_history lh, x$kccfe fe, v$database_incarnation di       where to_number(fe.fecps) <= lh.next_change#         and to_number(fe.fecps) >= lh.first_change#         and fe.fedup!=0 and bitand(fe.festa, 12) = 12         and di.resetlogs_time = lh.resetlogs_time         and lh.resetlogs_change# = di.resetlogs_change#         and di.status = 'CURRENT'       group by thread#) lh_lsq,      (select thread#, max(sequence#)+1 lsq       from         v$log_history       where (select min( to_number(fe.fecps))              from x$kccfe fe              where fe.fedup!=0 and bitand(fe.festa, 12) = 12)       >= next_change#       group by thread#) srl_lsq    where srl_lsq.thread# = lh_lsq.thread#(+)   ) low  where low.thread# = high.thread#  and lsq < = hsq  and hsq > rcvsq
+++GV$ARCHIVE_PROCESSES+++            select  inst_id, to_number(kcrrxpid), decode(kcrrxsts,   1,'SCHEDULED',   2,'STARTING',   3,'ACTIVE',   4,'STOPPING',   5,'TERMINATED',   6,'INITING',     'STOPPED'), to_number(kcrrxseq), decode(kcrrxsta,   1,'BUSY',     'IDLE'), rtrim(decode(bitand(kcrrxrol,1),1,'CLEAR_LOGS ','') ||       decode(bitand(kcrrxrol,2),2,'HEART_BEAT ','') ||       decode(bitand(kcrrxrol,4),4,'NO_FAL ','')     ||       decode(bitand(kcrrxrol,8),8,'NO_SRL ','')), con_id  from x$kcrrarch
+++GV$ASH_INFO+++                     SELECT inst_id, total_size, fixed_size, sampling_interval,    decode(oldest_sample_id, 0, to_number(null), oldest_sample_id),    decode(oldest_sample_id, 0, to_timestamp(null),           oldest_sample_time),    decode(latest_sample_id, 0, to_number(null), latest_sample_id),    decode(latest_sample_id, 0, to_timestamp(null),           latest_sample_time),    sample_count, dropped_sample_count, sampled_bytes,    sampler_elapsed_time,    disk_filter_ratio, flushed_bytes, flusher_elapsed_time,    total_flusher_count, emergency_flusher_count, con_id FROM  x$kewam
+++GV$ASM_ACFSREPL+++                 select                         xv.inst_id,                   xv.fsname_kfvacfsrepl,        xv.voldev_kfvacfsrepl,        decode(xv.site_kfvacfsrepl, 0, 'PRIMARY', 1, 'STANDBY'),   xv.lag_kfvacfsrepl,           decode(xv.status_kfvacfsrepl, 0, 'ONLINE', 1, 'INITIALIZING', 2, 'PAUSED'),   decode(xv.initstatus_kfvacfsrepl, 0, 'NONE', 1, 'DIRECTORIES', 2, 'FILES'),   xv.dirsscan_kfvacfsrepl,      xv.percent_kfvacfsrepl,       to_date(xv.lastsync_kfvacfsrepl,'MM/DD/RR HH24:MI:SS',                                'NLS_CALENDAR=Gregorian'),  xv.crsrun_kfvacfsrepl,        xv.crstotal_kfvacfsrepl,      xv.pmntpt_kfvacfsrepl,        xv.smntpt_kfvacfsrepl,        xv.psvcname_kfvacfsrepl,      xv.ssvcname_kfvacfsrepl,      xv.phost_kfvacfsrepl,         xv.shost_kfvacfsrepl,         xv.remalias_kfvacfsrepl,      xv.tags_kfvacfsrepl,          decode(xv.compression_kfvacfsrepl, 0, 'OFF', 1, 'ON'),   xv.dbglvl_kfvacfsrepl,        xv.con_id                     from x$kfvacfsrepl xv
+++GV$ASM_ACFSREPLTAG+++              select                        xv.inst_id,                  xv.fsname_kfvacfsrepltag,    xv.voldev_kfvacfsrepltag,    xv.tag_kfvacfsrepltag,       xv.con_id                    from x$kfvacfsrepltag xv
+++GV$ASM_ACFSSNAPSHOTS+++            select   xv.inst_id, xv.name_kfvacfss,                                               xv.voldev_kfvacfss, xv.sname_kfvacfss,                                      to_date(xv.time_kfvacfss,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),   decode(xv.type_kfvacfss, 1, 'RW', 2, 'RO'), xv.sparent_kfvacfss,             xv.con_id                                                                   from x$kfvacfss xv
+++GV$ASM_ACFSTAG+++                  select                      xv.inst_id,                xv.tagname_kfvacfstag,     xv.mntptname_kfvacfstag,   xv.pathname_kfvacfstag,    xv.con_id                  from x$kfvacfstag xv
+++GV$ASM_ACFSVOLUMES+++              select   xv.inst_id, xv.name_kfvacfsv, xv.voldev_kfvacfsv,    xv.vollab_kfvacfsv,                                  decode(xv.privol_kfvacfsv, 0, 'FALSE', 1, 'TRUE'),   xv.totsz_kfvacfsv/(1024*1024),                       xv.totfree_kfvacfsv/(1024*1024), xv.con_id           from x$kfvacfsv xv
+++GV$ASM_ACFS_ENCRYPTION_INFO+++     select   xv.inst_id, xv.name_kfvacfsencr,                                              xv.voldev_kfvacfsencr,                                                        decode(xv.set_kfvacfsencr, 0, 'NO', 1, 'YES', 'UNKNOWN'),                     decode(xv.enabled_kfvacfsencr, 0, 'DISABLED', 1, 'ENABLED', 'UNKNOWN'),       decode(xv.alg_kfvacfsencr, 0, 'NONE', 1, 'AES', 'UNKNOWN'),                   decode(xv.keylen_kfvacfsencr, 0, 'NONE', 16, '128', 24, '192', 32,                   '256',  'UNKNOWN'),                                                    to_date(xv.rtime_kfvacfsencr,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  xv.con_id   from x$kfvacfsencr xv
+++GV$ASM_ACFS_SECURITY_INFO+++       select   xv.inst_id, xv.name_kfvacfsrealm,                                            xv.voldev_kfvacfsrealm,                                                      decode(xv.prepared_kfvacfsrealm, 0, 'NO', 1, 'YES', 'UNKNOWN'),              decode(xv.enabled_kfvacfsrealm, 0, 'DISABLED', 1, 'ENABLED', 'UNKNOWN'),     xv.con_id                                                                    from x$kfvacfsrealm xv
+++GV$ASM_ACFS_SEC_ADMIN+++           select                                            xv.inst_id,                                      xv.adminname_kfvacfsadmin,                       xv.con_id                                        from x$kfvacfsadmin xv
+++GV$ASM_ACFS_SEC_CMDRULE+++         select   xv.inst_id,                                          xv.cmdrulename_kfvacfscmdrule,                       xv.name_kfvacfscmdrule, xv.voldev_kfvacfscmdrule,    xv.con_id                                            from x$kfvacfscmdrule xv
+++GV$ASM_ACFS_SEC_REALM+++           select   xv.inst_id, xv.realmname_kfvacfsrealms, xv.realmstatus_kfvacfsrealms,   xv.realmencrstatus_kfvacfsrealms, xv.realmencrkeylen_kfvacfsrealms,     decode(xv.realmencralgo_kfvacfsrealms,  1, 'AES', 'UNKNOWN'),           xv.realmdesc_kfvacfsrealms, xv.name_kfvacfsrealms,                      xv.voldev_kfvacfsrealms,                                                xv.con_id                                                               from x$kfvacfsrealms xv
+++GV$ASM_ACFS_SEC_REALM_FILTER+++    select   xv.inst_id, xv.realmname_kfvacfsrealmfilter,                  xv.cmdrulename_kfvacfsrealmfilter,                            xv.rulesetname_kfvacfsrealmfilter,                            xv.name_kfvacfsrealmfilter, xv.voldev_kfvacfsrealmfilter,     xv.con_id                                                     from x$kfvacfsrealmfilter xv
+++GV$ASM_ACFS_SEC_REALM_GROUP+++     select   xv.inst_id, xv.realmname_kfvacfsrealmgroup,                xv.groupname_kfvacfsrealmgroup,                            xv.name_kfvacfsrealmgroup, xv.voldev_kfvacfsrealmgroup,    xv.con_id                                                  from x$kfvacfsrealmgroup xv
+++GV$ASM_ACFS_SEC_REALM_USER+++      select   xv.inst_id, xv.realmname_kfvacfsrealmuser,               xv.username_kfvacfsrealmuser,                            xv.name_kfvacfsrealmuser, xv.voldev_kfvacfsrealmuser,    xv.con_id                                                from x$kfvacfsrealmuser xv
+++GV$ASM_ACFS_SEC_RULE+++            select   xv.inst_id, xv.rulename_kfvacfsrule, xv.ruletype_kfvacfsrule,           xv.rulevalue_kfvacfsrule, xv.rulevalue2_kfvacfsrule,                    decode(xv.ruleoption_kfvacfsrule,  1, 'ALLOW' , 2, 'DENY', 'UNKNOWN'),  xv.name_kfvacfsrule, xv.voldev_kfvacfsrule,                             xv.con_id                                                               from x$kfvacfsrule xv
+++GV$ASM_ACFS_SEC_RULESET+++         select                                                       xv.inst_id, xv.rulesetname_kfvacfsruleset,                  decode(xv.rulesetoption_kfvacfsruleset,  1, 'ALL_TRUE' ,           2, 'ANY_TRUE', 'UNKNOWN'),                           xv.name_kfvacfsruleset, xv.voldev_kfvacfsruleset,           xv.con_id                                                   from x$kfvacfsruleset xv
+++GV$ASM_ACFS_SEC_RULESET_RULE+++    select   xv.inst_id, xv.rulesetname_kfvacfsrulesetrule,                xv.rulename_kfvacfsrulesetrule,                               xv.name_kfvacfsrulesetrule, xv.voldev_kfvacfsrulesetrule,     xv.con_id                                                     from x$kfvacfsrulesetrule xv
+++GV$ASM_ALIAS+++                    select inst_id, name_kfals, group_kfals, number_kfals, incarn_kfals,  entnum_kfals,  entinc_kfals, parent_kfals,  refer_kfals,   decode(bitand(entflg_kfals, 12), 4, 'Y', 8, 'Y', 'N'),  decode(bitand(entflg_kfals, 15), 1, 'N', 2, 'Y', 4, 'Y', 8, 'N'), con_id  from x$kfals  where decode(bitand(entflg_kfals, 12), 4, 'Y', 8, 'Y', 'N') = 'Y' OR        decode(bitand(entflg_kfals, 16), 16, 'Y', 'N') = 'Y'
+++GV$ASM_ATTRIBUTE+++                select inst_id, name_kfenv, value_kfenv, group_kfenv,  entnum_kfenv,  entinc_kfenv,  decode(readonly_kfenv, 0, 'N', 1, 'Y', 'UNKNOWN') readonly_kfenv,  decode(system_kfenv, 0, 'N', 1, 'Y', 'UNKNOWN') system_kfenv, con_id  from x$kfenv  where hidden_kfenv = 0
+++GV$ASM_AUDIT_CLEANUP_JOBS+++       select inst_id, job_name_kzajobs, job_status_kzajobs, audit_trail_kzajobs,  job_frequency_kzajobs, con_id from x$kzajobs
+++GV$ASM_AUDIT_CLEAN_EVENTS+++       select inst_id, audit_trail_kzahist, cleanup_time_kzahist,  delete_count_kzahist, was_forced_kzahist, con_id from x$kzahist
+++GV$ASM_AUDIT_CONFIG_PARAMS+++      select inst_id, parameter_name_kzaparams, parameter_value_kzaparams,   audit_trail_kzaparams, con_id from x$kzaparams
+++GV$ASM_AUDIT_LAST_ARCH_TS+++       select inst_id, audit_trail_kzats, last_archive_ts_kzats, con_id from  x$kzats
+++GV$ASM_CLIENT+++                   select inst_id, gn_kfncl, instname_kfncl, dbname_kfncl, clustername_kfncl,  decode(status_kfncl, 1, 'CONNECTED', 2, 'DISCONNECTED', 3, 'BROKEN'),   softver_kfncl, compver_kfncl, con_id  from x$kfncl
+++GV$ASM_DISK+++                     select   d.inst_id, d.grpnum_kfdsk, d.number_kfdsk,   d.compound_kfdsk, d.incarn_kfdsk,   decode(d.mntsts_kfdsk,    1, 'MISSING', 2, 'CLOSED', 3, 'OPENED', 4, 'CACHED',    5, 'IGNORED', 6, 'IGNORED', 7, 'CLOSING', 8, 'IGNORED', 9, 'IGNORED',    'INVALID'),   decode(d.hdrsts_kfdsk,    1, 'UNKNOWN', 2, 'CANDIDATE', 3, 'MEMBER', 4, 'FORMER',    5, 'CONFLICT', 6, 'INCOMPATIBLE', 7, 'PROVISIONED', 8, 'FOREIGN',    'INVALID'),   decode(d.grpnum_kfdsk, 0, 'ONLINE', decode(d.mode_kfdsk,    0, 'UNKNOWN', 127, 'ONLINE', 21, 'OFFLINE', 1, 'OFFLINE', 'SYNCING')),   decode(d.state_kfdsk,    1, 'UNKNOWN', 2, 'NORMAL', 3, 'UNUSED', 4, 'DROPPING',    5, decode(d.mode_kfdsk, 127, 'DROPPING', 'FORCING'),    6, 'FORCING', 7, 'DROPPED', 8, 'ADDING', 'INVALID'),   decode(d.redun_kfdsk,    16, 'UNPROT', 17, 'UNPROT', 18, 'MIRROR', 19, 'MIRROR',    20, 'MIRROR', 21, 'MIRROR', 22, 'MIRROR', 23, 'MIRROR',    32, 'PARITY', 33, 'PARITY', 34, 'PARITY', 35, 'PARITY',    36, 'PARITY', 37, 'PARITY', 38, 'PARITY', 39, 'PARITY',    'UNKNOWN'),   d.libnam_kfdsk, d.osmb_kfdsk, d.totmb_kfdsk, d.totmb_kfdsk - d.usedmb_kfdsk,  d.hotmb_kfdsk, d.coldmb_kfdsk,   d.asmname_kfdsk, d.failname_kfdsk, d.label_kfdsk, d.path_kfdsk,   d.udid_kfdsk, d.product_kfdsk, d.crdate_kfdsk,   d.mtdate_kfdsk, case when d.mode_kfdsk = '127' then 0    else d.timer_kfdsk end,   k.read_kfkid, k.write_kfkid, k.rerr_kfkid, k.werr_kfkid,   k.rtout_kfkid, k.wtout_kfkid, k.rtime_kfkid/1000000, k.wtime_kfkid/1000000,   k.bytesr_kfkid, k.bytesw_kfkid,   decode(d.prefrd_kfdsk,    0, ' ', 1, 'Y', 2, 'N', 3, 'U'),   d.asmhashval_kfdsk,   k.hread_kfkid, k.hwrite_kfkid, k.hbytesr_kfkid, k.hbytesw_kfkid,   k.cread_kfkid, k.cwrite_kfkid, k.cbytesr_kfkid, k.cbytesw_kfkid,    decode(bitand(d.flags_kfdsk, 512), 512, 'Y', 'N'), d.blksz_kfdsk,   decode(bitand(d.flags_kfdsk, 256), 256, 'QUORUM', 'REGULAR'), d.con_id   from x$kfdsk d, x$kfkid k  where d.mntsts_kfdsk != 0 and d.kfkid_kfdsk = k.idptr_kfkid(+)
+++GV$ASM_DISKGROUP+++                select   g.inst_id, g.number_kfgrp, g.name_kfgrp,   g.sector_kfgrp, g.blksize_kfgrp, g.ausize_kfgrp,   decode(g.state_kfgrp,     0, 'INVALID', 1, 'UNKNOWN', 2, 'DISMOUNTED', 3, 'CREATING',     4, 'MOUNTING', 5, decode(bitand(g.lflags_kfgrp, 1), 1,        'QUIESCING', 'MOUNTED'),     6, 'DISMOUNTING', 7, 'CONNECTED',     8, 'BROKEN', 9, 'CONNECTING', 10, 'BREAKING', 11, 'DROPPING',     12, 'DROPPING', 255, 'RESTRICTED'),   decode(g.type_kfgrp, 1, 'EXTERN', 2, 'NORMAL', 3, 'HIGH'),   g.totmb_kfgrp, g.freemb_kfgrp, g.hotmb_kfgrp, g.coldmb_kfgrp,   g.minspc_kfgrp, g.usable_kfgrp, g.offline_kfgrp,   g.compat_kfgrp, g.dbcompat_kfgrp,   decode(bitand(g.flags32_kfgrp, 2048), 2048, 'Y', 'N'), g.con_id   from x$kfgrp g where state_kfgrp != 0
+++GV$ASM_DISKGROUP_SPARSE+++         select   g.inst_id, g.number_kfgrp_sparse,   g.allocatedmatmb_kfgrp_sparse, g.totmatmb_kfgrp_sparse,   g.con_id  from x$kfgrp_sparse g
+++GV$ASM_DISKGROUP_STAT+++           select   g.inst_id, g.number_kfgrp, g.name_kfgrp,   g.sector_kfgrp, g.blksize_kfgrp, g.ausize_kfgrp,   decode(g.state_kfgrp,     0, 'INVALID', 1, 'UNKNOWN', 2, 'DISMOUNTED', 3, 'CREATING',     4, 'MOUNTING', 5, decode(bitand(g.lflags_kfgrp, 1), 1,        'QUIESCING', 'MOUNTED'),     6, 'DISMOUNTING', 7, 'CONNECTED',     8, 'BROKEN', 9, 'CONNECTING', 10, 'BREAKING', 11, 'DROPPING',     12, 'DROPPING', 255, 'RESTRICTED'),   decode(g.type_kfgrp, 1, 'EXTERN', 2, 'NORMAL', 3, 'HIGH'),   g.totmb_kfgrp, g.freemb_kfgrp, g.hotmb_kfgrp, g.coldmb_kfgrp,   g.minspc_kfgrp, g.usable_kfgrp, g.offline_kfgrp,   g.compat_kfgrp, g.dbcompat_kfgrp,   decode(bitand(g.flags32_kfgrp, 2048), 2048, 'Y', 'N'), g.con_id   from x$kfgrp_stat g where state_kfgrp != 0 and number_kfgrp != 0
+++GV$ASM_DISK_IOSTAT+++              select   d.inst_id, d.instname, d.dbname, d.clustername, d.group_number,   d.disk_number, d.failgroup, d.reads,   d.writes, d.read_errs, d.write_errs, d.read_timeout, d.write_timeout,   d.read_time/1000000, d.write_time/1000000,   d.bytes_read, d.bytes_written,   d.hreads, d.hwrites, d.hbytes_read, d.hbytes_written,   d.creads, d.cwrites, d.cbytes_read, d.cbytes_written, d.con_id   from x$kfnsDskIost d
+++GV$ASM_DISK_IOSTAT_SPARSE+++       select   d.inst_id, d.instname_kfndiosprs, d.dbname_kfndiosprs,   d.clustername_kfndiosprs, d.grpnum_kfndiosprs, d.dsknum_kfndiosprs,   d.sparse_reads_kfndiosprs, d.sparse_read_time_kfndiosprs/1000000,   d.sparse_bytes_read_kfndiosprs, d.con_id   from x$kfndiosprs d
+++GV$ASM_DISK_SPARSE+++              select   d.inst_id, d.grpnum_kfdsk_sparse, d.number_kfdsk_sparse,   d.compound_kfdsk_sparse, d.incarn_kfdsk_sparse,   d.allocatedmatmb_kfdsk_sparse, d.totmatmb_kfdsk_sparse, k.sread_kfkid,   k.srtime_kfkid/1000000, k.sbytesr_kfkid, d.con_id  from x$kfdsk_sparse d, x$kfkid k  where d.kfkid_kfdsk_sparse = k.idptr_kfkid(+)
+++GV$ASM_DISK_SPARSE_STAT+++         select   d.inst_id, d.grpnum_kfdsk_sparse, d.number_kfdsk_sparse,   d.compound_kfdsk_sparse, d.incarn_kfdsk_sparse,   d.allocatedmatmb_kfdsk_sparse, d.totmatmb_kfdsk_sparse, k.sread_kfkid,   k.srtime_kfkid/1000000, k.sbytesr_kfkid, d.con_id  from x$kfdsk_sparse_stat d, x$kfkid k  where d.kfkid_kfdsk_sparse = k.idptr_kfkid(+)
+++GV$ASM_DISK_STAT+++                select   d.inst_id, d.grpnum_kfdsk, d.number_kfdsk,   d.compound_kfdsk, d.incarn_kfdsk,   decode(d.mntsts_kfdsk,    1, 'MISSING', 2, 'CLOSED', 3, 'OPENED', 4, 'CACHED',    5, 'IGNORED', 6, 'IGNORED', 7, 'CLOSING', 8, 'IGNORED', 9, 'IGNORED',    'INVALID'),   decode(d.hdrsts_kfdsk,    1, 'UNKNOWN', 2, 'CANDIDATE', 3, 'MEMBER', 4, 'FORMER',    5, 'CONFLICT', 6, 'INCOMPATIBLE', 7, 'PROVISIONED', 8, 'FOREIGN',    'INVALID'),   decode(d.grpnum_kfdsk, 0, 'ONLINE', decode(d.mode_kfdsk,    0, 'UNKNOWN', 127, 'ONLINE', 21, 'OFFLINE', 1, 'OFFLINE', 'SYNCING')),   decode(d.state_kfdsk,    1, 'UNKNOWN', 2, 'NORMAL', 3, 'UNUSED', 4, 'DROPPING',    5, decode(d.mode_kfdsk, 127, 'DROPPING', 'FORCING'),    6, 'FORCING', 7, 'DROPPED', 8, 'ADDING', 'INVALID'),   decode(d.redun_kfdsk,    16, 'UNPROT', 17, 'UNPROT', 18, 'MIRROR', 19, 'MIRROR',    20, 'MIRROR', 21, 'MIRROR', 22, 'MIRROR', 23, 'MIRROR',    32, 'PARITY', 33, 'PARITY', 34, 'PARITY', 35, 'PARITY',    36, 'PARITY', 37, 'PARITY', 38, 'PARITY', 39, 'PARITY',    'UNKNOWN'),   d.libnam_kfdsk, d.osmb_kfdsk, d.totmb_kfdsk, d.totmb_kfdsk - d.usedmb_kfdsk,  d.hotmb_kfdsk, d.coldmb_kfdsk,   d.asmname_kfdsk, d.failname_kfdsk, d.label_kfdsk, d.path_kfdsk,   d.udid_kfdsk, d.product_kfdsk, d.crdate_kfdsk,   d.mtdate_kfdsk, case when d.mode_kfdsk = '127' then 0    else d.timer_kfdsk end,   k.read_kfkid, k.write_kfkid, k.rerr_kfkid, k.werr_kfkid,   k.rtout_kfkid, k.wtout_kfkid, k.rtime_kfkid/1000000, k.wtime_kfkid/1000000,   k.bytesr_kfkid, k.bytesw_kfkid,   decode(d.prefrd_kfdsk,    0, ' ', 1, 'Y', 2, 'N', 3, 'U'),   d.asmhashval_kfdsk,   k.hread_kfkid, k.hwrite_kfkid, k.hbytesr_kfkid, k.hbytesw_kfkid,   k.cread_kfkid, k.cwrite_kfkid, k.cbytesr_kfkid, k.cbytesw_kfkid,   decode(bitand(d.flags_kfdsk, 512), 512, 'Y', 'N'), d.blksz_kfdsk,   decode(bitand(d.flags_kfdsk, 256), 256, 'QUORUM', 'REGULAR'), d.con_id  from x$kfdsk_stat d, x$kfkid k  where d.mntsts_kfdsk != 0 and d.kfkid_kfdsk = k.idptr_kfkid(+)   and d.grpnum_kfdsk > 0
+++GV$ASM_ESTIMATE+++                 select inst_id, number_kfgxp, stmtid_kfgxp, ts_kfgxp,    sum(count_kfgxp*size_kfgxp), con_id  from x$kfgxp group by   inst_id, con_id, number_kfgxp, stmtid_kfgxp, id_kfgxp, ts_kfgxp
+++GV$ASM_FILE+++                     select   inst_id, group_kffil, number_kffil, compound_kffil, incarn_kffil,   blksiz_kffil, blkcnt_kffil, filsiz_kffil, filspc_kffil, sftype_kffil,   decode(redun_kffil, 17, 'UNPROT', 18, 'MIRROR', 19, 'HIGH',          35, 'PARITY', 36, 'PARITY', 37, 'PARITY', 38, 'PARITY'),   decode(ftype_kffil,  26, 'CUSTOM', 27, 'CUSTOM',          decode(bitand(fdflg_kffil, 2), 2, 'FINE', 'COARSE') ),    crdate_kffil,   mddate_kffil, decode(thinned_kffil, 0, 'U', 4294967295, 'N', 'Y'),   permissions_kffil, usrent_kffil, usrinc_kffil, grpent_kffil, grpinc_kffil,   decode(prizn_kffil, 1, 'HOT', 'COLD'),   decode(seczn_kffil, 1, 'HOT', 'COLD'),   hreads_kffil, hwrites_kffil, hbytesr_kffil, hbytesw_kffil,   creads_kffil, cwrites_kffil, cbytesr_kffil, cbytesw_kffil, con_id   from x$kffil  where incarn_kffil <> 0 and visible_kffil > 0
+++GV$ASM_FILESYSTEM+++               select   xv.inst_id, xv.name_kfvacfs,   to_date(xv.time_kfvacfs,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  xv.blksz_kfvacfs/(1024),                                        decode(xv.state_kfvacfs, 0, 'NOT AVAILABLE', 1, 'AVAILABLE', 2, 'OFFLINE'),   decode(xv.corrupt_kfvacfs, 1, 'TRUE', 0, 'FALSE'),              xv.numvol_kfvacfs,  xv.totsz_kfvacfs/(1024*1024),               xv.totfree_kfvacfs/(1024*1024),                                 xv.totsnap_kfvacfs/(1024*1024),                                 decode(xv.replstate_kfvacfs, 0, 'NO REPL', 1, 'PRIMARY', 2, 'STANDBY'),   xv.con_id                                                       from x$kfvacfs xv
+++GV$ASM_OPERATION+++                select   inst_id, number_kfgbrb, 'REBAL',   decode(op_kfgbrb, 1, 'RESYNC', 2, 'RESILVER', 3, 'REBALANCE', 'COMPACT'),   decode(error_kfgbrb, 0,          decode(sign(state_kfgbrb - op_kfgbrb), 0,                 decode((select state_kfgmg from x$kfgmg where                          number_kfgmg=number_kfgbrb and op_kfgmg=1 and                          pass_kfgmg=op_kfgbrb), 3, 'REAP',                        decode((select rebalst_kfgmg from x$kfgmg where                                 number_kfgmg=number_kfgbrb and op_kfgmg = 1                                 and pass_kfgmg=op_kfgbrb), 1, 'EST', 3, 'EST',                                5, 'EST', 0, 'WAIT', '', 'WAIT', 'RUN')),                  1, 'DONE', 'WAIT'), 'ERRS'),   power_kfgbrb,   (select actual_kfgmg from x$kfgmg where number_kfgmg=number_kfgbrb    and op_kfgmg = 1 and pass_kfgmg=op_kfgbrb),   (select sofar_kfgmg from x$kfgmg where number_kfgmg=number_kfgbrb    and op_kfgmg = 1 and pass_kfgmg=op_kfgbrb),   (select work_kfgmg from x$kfgmg where number_kfgmg=number_kfgbrb    and op_kfgmg = 1 and pass_kfgmg=op_kfgbrb),   (select rate_kfgmg from x$kfgmg where number_kfgmg=number_kfgbrb    and op_kfgmg = 1 and pass_kfgmg=op_kfgbrb),   (select time_kfgmg from x$kfgmg where number_kfgmg=number_kfgbrb    and op_kfgmg = 1 and pass_kfgmg=op_kfgbrb),   decode(error_kfgbrb, 0, '', 'ORA-' || error_kfgbrb), con_id  from x$kfgbrb
+++GV$ASM_TEMPLATE+++                 select inst_id, group_kftmta, entry_kftmta,   decode(redundancy_kftmta, 17, 'UNPROT', 18, 'MIRROR', 19, 'HIGH',          35, 'PARITY', 36, 'PARITY', 37, 'PARITY', 38, 'PARITY'),   decode(bitand(flags_kftmta, 1), 1, 'FINE', 'COARSE'),   decode(bitand(flags_kftmta, 4), 4, 'Y', 'N'),   name_kftmta, decode(prizn_kftmta, 1, 'HOT', 'COLD'),   decode(seczn_kftmta, 1, 'HOT', 'COLD'), con_id               from x$kftmta  where hidden_kftmta = 0
+++GV$ASM_USER+++                     select inst_id, group_kfzudr, entnum_kfzudr, refer_kfzudr,  entinc_kfzudr, cid_kfzudr, uid_kfzudr, osuser_kfzudr, con_id  from x$kfzudr
+++GV$ASM_USERGROUP+++                select inst_id, group_kfzgdr, entnum_kfzgdr, refer_kfzgdr,  entinc_kfzgdr, ownernum_kfzgdr, ownerinc_kfzgdr, name_kfzgdr, con_id  from x$kfzgdr
+++GV$ASM_USERGROUP_MEMBER+++         select inst_id, group_kfzuagr, usernum_kfzuagr, userinc_kfzuagr,  ugroupnum_kfzuagr, ugroupinc_kfzuagr, con_id  from x$kfzuagr
+++GV$ASM_VOLUME+++                   select   xv.inst_id, xv.group_kfvol, xv.name_kfvol, xv.compound_kfvol,   xf.filsiz_kffil/(1024*1024), xv.volnum_kfvol,   decode(xf.redun_kffil, 17, 'UNPROT', 18, 'MIRROR', 19, 'HIGH',           35, 'PARITY', 36, 'PARITY', 37, 'PARITY', 38, 'PARITY'),   xf.strpwd_kffil, POWER(2, xf.strpsz_kffil)/1024, xf.number_kffil,   xf.incarn_kffil, xv.drl_filenum_kfvol, xv.usage_kfvol,          decode(xv.state_kfvol, 0, 'DISABLED', 1, 'ENABLED', 2, 'REMOTE'),   xv.extent_size_mb_kfvol * xf.strpwd_kffil,       xv.device_kfvol, xv.mountpath_kfvol, xv.con_id             from x$kffil xf, x$kfvol xv                             where xv.group_kfvol = xf.group_kffil and xv.filenum_kfvol <> 0 and   xv.filenum_kfvol = xf.number_kffil
+++GV$ASM_VOLUME_STAT+++              select   xv.inst_id, xv.group_kfvol, xv.name_kfvol,             xv.compound_kfvol, xv.volnum_kfvol,                    xs.reads_kfvolstat, xs.writes_kfvolstat,               xs.read_errs_kfvolstat, xs.write_errs_kfvolstat,       xs.read_time_kfvolstat/1000, xs.write_time_kfvolstat/1000,   xs.bytes_read_kfvolstat, xs.bytes_written_kfvolstat, xv.con_id    from x$kfvol xv, x$kfvolstat xs                        where xv.compound_kfvol = xs.compound_kfvolstat        and xs.volnum_kfvolstat <> 0
+++GV$AUTO_BMR_STATISTICS+++          select userenv('Instance'),FILENO_KRBABRSTAT,BLOCKNO_KRBABRSTAT,  CORRUPT_SCN_KRBABRSTAT, FIXED_TIME_KRBABRSTAT, ORA_KRBABRSTAT,  ERRSTR_KRBABRSTATX, CON_ID from x$krbabrstat order by  ROWNO_KRBABRSTATX
+++GV$AW_AGGREGATE_OP+++              select inst_id, name_xsagopft as name, desc_xsagopft as longname, case when weight_xsagopft >= 0 then weight_xsagopft else null end as default_weight, con_id from x$xsagop where not bitand(flags_xsagopft, 32) = 0
+++GV$AW_ALLOCATE_OP+++               select inst_id, name_xsagopft as name, desc_xsagopft as longname, con_id from x$xsagop where not bitand(flags_xsagopft, 64) = 0
+++GV$AW_CALC+++                      select inst_id, session_id, agcachhit, agcachmiss, scachesuccess, scachefailure, pgcachhit, pgcachmiss, pgnewpage, pgscrounge, pgcachewrite, pgpoolsize, cdmlcmd, pdmlcmd, aggr_func_logical_na, aggr_func_precompute, aggr_func_calcs, con_id from x$xsaggr
+++GV$AW_LONGOPS+++                   select inst_id, session_id, cursor_name,  decode(command,                 1, 'QUERY',                     2, 'FETCH',                     3, 'IMPORT',                    4, 'EXECUTE',                   5, 'UPDATE',                    6, 'SOLVE',                     7, 'CLEAR',                     8, 'LOAD CUBE',                 9, 'LOAD DIMENSION',            10, 'DIMENSION COMPILE', '?'),  decode(status,        1, 'EXECUTING',       2, 'FETCHING',        3, 'FINISHED', '?'),  rows_processed, seq_number, sql_id, target, target_desc,  to_date(start_time, 'MM/DD/RR HH24:MI:SS', 'NLS_CALENDAR=Gregorian'),  to_date(last_update_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  elapsed_seconds,  sofar, totalwork,  decode (units,     1, 'ROWS',         2, 'NODES',        3, 'VALUES', '?'), message, username, con_id  from x$xslongops
+++GV$AW_OLAP+++                      select a.inst_id, s.ksusenum, a.awnum,  decode(a."MODE", 0, 'READ ONLY', 1, 'READ WRITE', 2, 'MULTIWRITE',  3, 'EXCLUSIVE', 'UNKNOWN'), a.gen_xsawso,  a.temp_lob_count, a.temp_lob_read, a.perm_lob_read, a.changed_cache,  a.unchanged_cache, a.con_id  from x$ksuse s, x$xsawso a  where s.addr = a.KSSOBOWN and bitand(a.flags, 128) = 0
+++GV$AW_SESSION_INFO+++              select inst_id, session_id, client, state, sesshandle, userid, tottrns,         trntime/1000000, tottrntime/1000000,         (tottrntime/tottrns)/1000000,         trncputime/1000000, tottrncputime/1000000,         (tottrncputime/tottrns)/1000000, con_id  from x$xssinfo
+++GV$BACKUP+++                       select inst_id,hxfil, decode(hxerr, 0,decode(bitand(fhsta, 1), 0,'NOT ACTIVE','ACTIVE'), 1,'FILE MISSING', 2,'OFFLINE NORMAL', 3,'NOT VERIFIED', 4,'FILE NOT FOUND', 5,'CANNOT OPEN FILE', 6,'CANNOT READ HEADER', 7,'CORRUPT HEADER', 8,'WRONG FILE TYPE', 9,'WRONG DATABASE', 10,'WRONG FILE NUMBER', 11,'WRONG FILE CREATE', 12,'WRONG FILE CREATE', 16,'DELAYED OPEN', 'UNKNOWN ERROR'), to_number(fhbsc),  to_date(fhbti,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), con_id from x$kcvfhonl
+++GV$BACKUP_ASYNC_IO+++              select inst_id, sid, ser, setid, rman_status_recid, rman_status_stamp, devtype, decode(type, 1, 'INPUT', 2, 'OUTPUT', 3, 'AGGREGATE', 'UNKNOWN'), decode(status, 1, 'NOT STARTED',                2, 'IN PROGRESS', 3, 'FINISHED', 'UNKNOWN'), filename, set_count, set_stamp, block_size * buffer_size, buffer_count, decode(total_blocks, 0, null, total_blocks) * block_size, to_date(open_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_date(close_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), abs((to_date(close_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian') - to_date(open_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')) * 8640000),decode(aggregate_count, 0, null, aggregate_count) * 1, blocks * block_size, decode(instr(open_time,close_time), 1, null, round((blocks * block_size) /    abs(((to_date(close_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian') - to_date(open_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')) * 86400)))) * 1, async_short_count + async_long_count + async_ready, async_ready, async_short_count, async_short_tottime, async_short_maxtime, async_long_count, async_long_tottime, async_long_maxtime, con_id from x$ksfqp where bitand(flags,2) = 2
+++GV$BACKUP_COMPRESSION_PROGRESS+++  select inst_id, ksulosno, ksuloctx, ksulosfr, ksulotot,         decode(ksuloif0, 1, 'LOCAL', 'EXADATA'),         ksuloif1, ksuloif2, ksuloif3, ksuloif4,         to_date(ksulostm, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),         to_date(ksulolut, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),         decode(sign(ksulotot - ksulosfr), -1, to_number(NULL),                decode(ksulosfr, 0, to_number(NULL),                       round(ksuloetm * ((ksulotot - ksulosfr) / ksulosfr)))),         ksuloetm,         con_id   from  x$ksulop   where ksulopna = 'backup piece compression'
+++GV$BACKUP_CORRUPTION+++            select inst_id,fcrid,fcstm,fcbss,fcbsc,fcpno,fcdfp,fcblk,fccnt,to_number(fcscn),decode(bitand(fcflg,1),1,'YES','NO'),decode(bitand(fcflg,65534),2,'ALL ZERO',4,'FRACTURED',8,'CHECKSUM',                        16,'CORRUPT', 32, 'NOLOGGING',                         64, 'LOGICAL', 'UNKNOWN'), con_id  from x$kccfc where bitand(fcflg, 65534) != 32
+++GV$BACKUP_DATAFILE+++              select inst_id,bfrid,bfstm,bfbss,bfbsc,bfdfp,to_number(bfcrs),to_date(bfcrt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(bfrls),to_date(bfrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(bfflg,1+8),1,bflvl,NULL),to_number(bfics),to_number(bfcps),to_date(bfcpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(bfafs),bfncb,bfmcb,bflcb,bffsz,bfbct,bfbsz,bflor,to_date(bftsm, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bfdfp, 0, decode(bitand(bfflg,2),2,'S','B'), NULL), decode(bitand(bfflg,4),4,'YES','NO'),bfbrd, decode(bitand(bfflg,16),16,'YES','NO'), bffdi, decode(bitand(bfflg,32),0,'NO','YES'), bfplus, bfprls, bfprlt, bfssz, decode(bitand(bfflg,128),0,'NO','YES'), bfssb, con_id, decode(bitand(bfflg, 512), 0, 'NO', 'YES') from x$kccbf where bitand(bfflg, 64) != 64
+++GV$BACKUP_DEVICE+++                select inst_id, devtype, devname, con_id from x$ksfqdvnt
+++GV$BACKUP_NONLOGGED+++              select                                                                         fc.inst_id,                                                                  fc.fcrid,                                                                    fc.fcstm,                                                                    fc.fcbss,                                                                    fc.fcbsc,                                                                    fc.fcpno,                                                                    fc.fcdfp,                                                                    fc.fcblk,                                                                    fc.fccnt,                                                                    to_number(fc.fcscn),                                                         NULL,                                                                        NULL,                                                                        NULL,                                                                        NULL,                                                                        'UNKNOWN',                                                                   fc.con_id                                                                  from                                                                           x$kccfc fc                                                                 where                                                                          bitand(fcflg, 65534) = 32
+++GV$BACKUP_PIECE+++                 select inst_id,bprid,bpstm,bpbss,bpbsc,bpnum,bitand(bpflg, 12)/4 + (bitand(bpext, 64-1) * 4) + 1,bpdev,bphdl,bpcmt,bpmdh,bitand(bpflg, 4080) / 16,decode(bitand(bpflg,2),1,'YES','NO'),bptag,decode(bitand(bpflg, 1+4096+8192),0,'A',1,decode(bitand(bpflg2, 1), 1, 'F','D'),4096,'X',8192,'U','?'),decode(bitand(bpflg,1),1,'YES','NO'),to_date(bptsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_date(bptim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),abs((to_date(bptim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')- to_date(bptsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'))*86400),((floor(bpext/512) * 4294967296) + bpsz1) * 512, decode(bitand(bpflg, 16384),0,'NO','YES'), bprsi,bprst,decode(bitand(bpext, 64),64,'YES','NO'), decode(bitand(bpflg, 16384),0,'NO',decode(bitand(bpext, 256),0,'NO','YES')), decode(bitand(bpext, 128),128,'YES','NO'), decode(bitand(bpflg, 16384),16384,'NO',decode(bitand(bpext,256),0,'NO','YES')),decode(bitand(bpflg2, 1), 1, 'YES', 'NO'), decode(bitand(bpflg2, 1), 1, decode(bitand(bpflg2, 2), 2, 'YES', 'NO'), NULL), con_id  from x$kccbp
+++GV$BACKUP_REDOLOG+++               select inst_id,blrid,blstm,blbss,blbsc,blthp,blseq,to_number(blrls),to_date(blrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(bllos),to_date(bllot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(blnxs),to_date(blnxt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),blbct,blbsz, decode(bitand(blflg, 1), 1, 'YES', 'NO'), con_id from x$kccbl where bitand(blflg, 2) != 2
+++GV$BACKUP_SET+++                   select inst_id,bsrid,bsstm,bsbss,bsbsc,case when bitand(bstyp,16)=16 then 'I'     else decode(bitand(bstyp,11),1,'D',2,'I',8,'L') end,decode(bitand(bstyp,4+64),4,'YES',68,'SBY','NO'),decode(bitand(bstyp,16+8192),16,bslvl,NULL),bspct,to_date(bsbst,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_date(bstsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(bstyp, 4096),4096,0, abs((to_date(bstsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')-  to_date(bsbst,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'))*86400)),bsbsz, decode(bitand(bstyp,128),128,'YES','NO'),  decode(bitand(bstyp, 1792), 0, 'NO',                                           'YES'),          to_date(bskpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(bstyp, 1792), 256,  'LOGS',                                     512,  'NOLOGS',                                   1024, 'BACKUP_LOGS',                                     NULL),          decode(bitand(bstyp, 16384), 16384, 'YES', 'NO'), decode(bitand(bstyp, 32768), 32768, 'YES', 'NO'), decode(bitand(bstyp, 32768), 32768,                              decode(bitand(bsflg2, 1), 1, 'NO', 'YES'), NULL), decode(bitand(bstyp, 32768), 32768,                              decode(bitand(bsflg2, 2), 2, 'YES', 'NO'), NULL), con_id from x$kccbs where bitand(bstyp,32) != 32 or bitand(bstyp, 32768) = 32768
+++GV$BACKUP_SPFILE+++                select inst_id,birid,bistm,bibss,bibsc,  to_date(bimdt, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian') , bifsz, to_date(bitsm, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), bidun, con_id  from x$kccbi  where bitand(biflg, 1) != 1
+++GV$BACKUP_SYNC_IO+++               select inst_id, sid, ser, setid, rman_status_recid, rman_status_stamp, devtype, decode(type, 1, 'INPUT', 2, 'OUTPUT', 3, 'AGGREGATE', 'UNKNOWN'), decode(status, 1, 'NOT STARTED',                2, 'IN PROGRESS', 3, 'FINISHED', 'UNKNOWN'), filename, set_count, set_stamp, block_size * buffer_size, buffer_count, decode(total_blocks, 0, null, total_blocks) * block_size, to_date(open_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_date(close_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), abs((to_date(close_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian') - to_date(open_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')) * 8640000),decode(aggregate_count, 0, null, aggregate_count) * 1, blocks * block_size, decode(instr(open_time,close_time), 1, null, round((blocks * block_size) /   abs(((to_date(close_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian') - to_date(open_time, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')) * 86400)))) * 1, sync_count, sync_tottime, sync_maxtime, decode(sync_tottime, 0, NULL,        round((blocks * block_size) / sync_tottime * 100)) * 1,  con_id from x$ksfqp where bitand(flags,2) = 0
+++GV$BGPROCESS+++                    select p.inst_id, p.ksbdppro,p.ksbdpser,p.ksbdpnam,d.ksbdddsc,p.ksbdperr,  p.con_id  from x$ksbdp p,x$ksbdd d where p.indx=d.indx  and p.ksbdpnam not like 'TEST%'
+++GV$BH+++                           select bh.inst_id, file#, dbablk, class, decode(state,0,'free',1,'xcur',2,'scur',3,'cr', 4,'read',5,'mrec',6,'irec',7,'write',8,'pi', 9,'memory',10,'mwrite',11,'donated', 12,'protected',  13,'securefile', 14,'siop',15,'recckpt', 16, 'flashfree',  17, 'flashcur', 18, 'flashna'), 0, 0, 0, bh.le_addr, le_id1, le_id2, decode(bitand(flag,1), 0, 'N', 'Y'), decode(bitand(flag,16), 0, 'N', 'Y'), decode(bitand(flag,1536), 0, 'N', 'Y'), decode(bitand(flag,16384), 0, 'N', 'Y'), decode(bitand(flag,65536), 0, 'N', 'Y'), 'N', obj, ts#, lobid,  bitand(OBJ_FLAG, 240)/16, decode(bitand(OBJ_FLAG, 48)/16, 1, 'KEEP', 2, 'NONE', 'DEFAULT'), decode(bitand(OBJ_FLAG, 192)/64, 1, 'KEEP', 2, 'NONE', 'DEFAULT'), bh.con_id from x$bh bh, x$le le where bh.le_addr = le.le_addr (+)
+++GV$BLOCKING_QUIESCE+++             select inst_id, sid_kgskvft, con_id from x$kgskvft         where active_kgskvft = 1         and cg_name_kgskvft <> 'SYS_GROUP'        and cg_name_kgskvft <> '_ORACLE_BACKGROUND_GROUP_'
+++GV$BSP+++                          select inst_id, reqcr, reqcur, reqdata, requndo,          reqtx, rescur, respriv, reszero, resdisk,                 resfail, fairdc, faircl, 0, flush, 0,                     flushf, flushmx, light, signal, con_id                            from x$kclcrst
+++GV$BTS_STAT+++                     SELECT inst_id,          tsn, tsv, maxsize, cursize, used, utime,          dalloc, dfree, nalloc, nfree, dtime,          talloc, tfree, ttime, flag, con_id          FROM  X$KTFBNSTAT
+++GV$BT_SCAN_CACHE+++                select INST_ID,                                                BT_CACHE_ALLOC, BTTARGET, OBJCOUNT,                            L1_ALLOC,                                                      MINCACHEDTEMP, CON_ID                                          from X$KCBDWS,                                                 (select sum(CNUM_DWB)/sum(CNUM_SET) as BT_CACHE_ALLOC           from X$KCBWDS)
+++GV$BT_SCAN_OBJ_TEMPS+++            select INST_ID,                                         TSN, OBJ, SIZE_IN_BLKS, TEMP,                           decode(POLICY, 0, 'INVALID',                                           1, 'MEM_ONLY',                                          2, 'MEM_FLASH',                                         3, 'MEM_PART',                                          4, 'FLASH_ONLY',                                        5, 'FLASH_PART',                                        6, 'DISK'),                              CACHED_IN_L1,                                           CON_ID                                                  from X$KCBDWOBJ
+++GV$BUFFERED_PUBLISHERS+++          select inst_id, queue_id, queue_schema, queue_name, sender_name,  sender_address, sender_protocol, num_msgs, cnum_msgs, last_enqueued_msg,  unbrowsed_msgs, overspilled_msgs, memory_usage,  elapsed_enqueue_time/10000, enqueue_cpu_time/10000, last_enqueue_time,   decode(bitand(publisher_flags, 7),  1, 'IN FLOW CONTROL: TOO MANY UNBROWSED MESSAGES',  2, 'IN FLOW CONTROL: OVERSPILLED MESSAGES',  4, 'IN FLOW CONTROL: INSUFFICIENT MEMORY AND UNBROWSED MESSAGES',  0, 'PUBLISHING MESSAGES'), con_id  from x$buffered_publishers
+++GV$BUFFERED_QUEUES+++              select inst_id, queue_id, queue_schema, queue_name, startup_time,  num_msgs, spill_msgs,  cnum_msgs, cspill_msgs, expired_msgs,   oldest_msgid, oldest_msg_enqtm,   elapsed_enqueue_time/10000, elapsed_dequeue_time/10000,  elapsed_transformation_time/10000, elapsed_rule_evaluation_time/10000,  enqueue_cpu_time/10000, dequeue_cpu_time/10000, avg_msg_age,  last_enqueue_time, last_dequeue_time,  decode(bitand(flags, 1),  1, 'QUEUE IS IN RECOVERY MODE',  0, 'NORMAL'), queue_size, con_id from x$buffered_queues where bitand(flags, 16) = 0
+++GV$BUFFERED_SUBSCRIBERS+++         select s.inst_id, s.queue_id, q.queue_schema, q.queue_name,  s.subscriber_id, s.subscriber_name,  s.subscriber_address, s.protocol,  s.subscriber_type, q.startup_time, s.last_browsed_seq,  NVL((select cs.LAST_DEQUEUED_LCR_NUM_KNSTCAPS         from x$knstcaps cs        where cs.appname_knstcaps = s.subscriber_name          and bitand(cs.spare1_knstcaps, 2) = 2          and cs.propname_knstcaps IS NULL          and cs.inst_id = s.inst_id          and cs.con_id = s.con_id),       s.last_browsed_num),  s.last_dequeued_seq,  NVL((select cs.LAST_BROWSED_LCR_NUM_KNSTCAPS         from x$knstcaps cs        where cs.appname_knstcaps = s.subscriber_name          and bitand(cs.spare1_knstcaps, 2) = 2          and cs.propname_knstcaps IS NULL          and cs.inst_id = s.inst_id          and cs.con_id = s.con_id),       s.last_dequeued_num),  s.current_enq_seq, s.num_msgs, s.cnum_msgs, s.total_dequeued_msg,  s.total_spilled_msg, s.expired_msgs, s.message_lag,  s.elapsed_dequeue_time/10000, s.dequeue_cpu_time/10000,  s.avg_msg_age, s.last_dequeue_time,  s.oldest_msgid, s.oldest_msg_enqtm, s.con_id  from x$buffered_subscribers s, x$buffered_queues q  where s.inst_id = q.inst_id and s.queue_id = q.queue_id and  bitand(q.flags, 16) = 0 and  ((s.con_id = q.con_id)or (s.con_id is null and q.con_id is null))
+++GV$BUFFER_POOL+++                  select  inst_id,                               bp_id,                                 bp_name,                               bp_blksz,                              decode(bp_state, 0, 'STATIC',     1, 'ALLOCATING',                                2, 'ACTIVATING', 3, 'SHRINKING'),               bp_currgrans * bp_gransz,              bp_size,                               bp_tgtgrans  * bp_gransz,              bp_tgtgrans  * bp_bufpergran,          bp_prevgrans * bp_gransz,              bp_prevgrans * bp_bufpergran,          0, 0,                                  bp_lo_sid,                             bp_hi_sid,                             bp_set_ct,                             con_id                         from x$kcbwbpd where bp_id > 0 and bp_currgrans > 0                     and bp_tgtgrans > 0
+++GV$BUFFER_POOL_STATISTICS+++       select kcbwbpd.inst_id, kcbwbpd.bp_id, kcbwbpd.bp_name, kcbwbpd.bp_blksz, sum(kcbwds.cnum_set),sum(kcbwds.cnum_repl), sum(kcbwds.cnum_write), sum(kcbwds.cnum_set), sum(kcbwds.buf_got), sum(kcbwds.sum_wrt), sum(kcbwds.sum_scn), sum(kcbwds.fbwait), sum(kcbwds.wcwait), sum(kcbwds.bbwait), sum(kcbwds.fbinsp), sum(kcbwds.dbinsp), sum(kcbwds.dbbchg), sum(kcbwds.dbbget), sum(kcbwds.conget), sum(kcbwds.pread), sum(kcbwds.pwrite), kcbwbpd.con_id from x$kcbwds kcbwds, x$kcbwbpd kcbwbpd where kcbwds.set_id >= kcbwbpd.bp_lo_sid and kcbwds.set_id <= kcbwbpd.bp_hi_sid and kcbwbpd.bp_size != 0 group by kcbwbpd.inst_id, kcbwbpd.bp_id, kcbwbpd.bp_name, kcbwbpd.bp_blksz, kcbwbpd.con_id
+++GV$CACHE+++                        WITH bh AS (SELECT b.inst_id, file#, dbablk block#, class class#,                     decode(state,0,'free',1,'xcur',2,'scur',3,'cr',                            4,'read',5,'mrec',6,'irec',7,'write',8,'pi',                            9,'memory',10,'mwrite',11,'donated',                            12,'protected', 13,'securefile', 14,'siop',                            15,'recckpt', 16, 'flashfree',                            17, 'flashcur', 18, 'flashna') status,                     0 xnc, 0 forced_reads, 0 forced_writes,                     b.le_addr lock_element_addr, le_id1 lock_element_name,                     obj objd, b.con_id              FROM x$bh b, x$le le              WHERE b.le_addr = le.le_addr (+))  SELECT bh.inst_id,         bh.file#,         bh.block#,         bh.class#,         bh.status,         bh.xnc,         bh.forced_reads,         bh.forced_writes,         ob.name,         ob.subname partition_name,         decode (ob.type#,  1, 'INDEX',                            2, 'TABLE',                            3, 'CLUSTER',                            4, 'VIEW',                            5, 'SYNONYM',                            6, 'SEQUENCE',                            7, 'PROCEDURE',                            8,  'FUNCTION',                            9, 'PACKAGE',                           10, 'NON-EXISTENT',                           11, 'PACKAGE BODY',                           12, 'TRIGGER',                           13, 'TYPE',                           14, 'TYPE BODY',                           19, 'TABLE PARTITION',                           20, 'INDEX PARTITION',                           21, 'LOB',                           22, 'LIBRARY',                           28, 'JAVA SOURCE',                           29, 'JAVA CLASS',                           30, 'JAVA RESOURCE',                           56, 'JAVA DATA',                           'UNKNOWN') kind,         ob.owner#,         lock_element_addr,         lock_element_name,         bh.con_id  FROM   bh, obj$ ob  WHERE  (bh.objd = ob.dataobj#)  UNION ALL  SELECT bh.inst_id,         bh.file#,         bh.block#,         bh.class#,         bh.status,         bh.xnc,         bh.forced_reads,         bh.forced_writes,         un.name,         NULL              partition_name,         'UNDO'            kind,         un.user#          owner#,         lock_element_addr,         lock_element_name,         bh.con_id  FROM   bh, undo$ un  WHERE  (bh.class# >= 11) and         (un.us# = floor(bh.class# - 11) / 2)
+++GV$CACHE_LOCK+++                   SELECT USERENV('Instance'), file#, block#, status, xnc, forced_reads,         forced_writes, name, kind, owner#, lock_element_addr,         lock_element_name, indx, class, con_id  FROM   v$cache_lock
+++GV$CACHE_TRANSFER+++               WITH bh AS (SELECT b.inst_id, file#, dbablk block#, class class#,                     decode(state,0,'free',1,'xcur',2,'scur',3,'cr',                            4,'read',5,'mrec',6,'irec',7,'write',8,'pi',                            9,'memory',10,'mwrite',11,'donated',                            12,'protected', 13,'securefile', 14,'siop',                            15,'recckpt', 16, 'flashfree',                            17, 'flashcur', 18, 'flashna') status,                     0 xnc, 0 forced_reads, 0 forced_writes,                     b.le_addr lock_element_addr, le_id1 lock_element_name,                     obj objd, b.con_id              FROM x$bh b, x$le le              WHERE b.le_addr = le.le_addr (+))  SELECT bh.inst_id,         bh.file#,         bh.block#,         bh.class#,         bh.status,         bh.xnc,         bh.forced_reads,         bh.forced_writes,         ob.name,         ob.subname partition_name,         decode (ob.type#,  1, 'INDEX',                            2, 'TABLE',                            3, 'CLUSTER',                            4, 'VIEW',                            5, 'SYNONYM',                            6, 'SEQUENCE',                            7, 'PROCEDURE',                            8,  'FUNCTION',                            9, 'PACKAGE',                           10, 'NON-EXISTENT',                           11, 'PACKAGE BODY',                           12, 'TRIGGER',                           13, 'TYPE',                           14, 'TYPE BODY',                           19, 'TABLE PARTITION',                           20, 'INDEX PARTITION',                           21, 'LOB',                           22, 'LIBRARY',                           28, 'JAVA SOURCE',                           29, 'JAVA CLASS',                           30, 'JAVA RESOURCE',                           56, 'JAVA DATA',                           'UNKNOWN') kind,         ob.owner#,         lock_element_addr,         lock_element_name,         bh.con_id  FROM   bh, obj$ ob  WHERE  (bh.objd = ob.dataobj#) AND         (bh.forced_reads + bh.forced_writes) > 0  UNION ALL  SELECT bh.inst_id,         bh.file#,         bh.block#,         bh.class#,         bh.status,         bh.xnc,         bh.forced_reads,         bh.forced_writes,         un.name,         NULL             partition_name,         'UNDO'           kind,         un.user#         owner#,         lock_element_addr,         lock_element_name,         bh.con_id  FROM  bh, undo$ un  WHERE   (bh.class# >= 11) AND         (un.us# = floor((bh.class# - 11) / 2)) AND         (bh.forced_reads + bh.forced_writes) > 0
+++GV$CALLTAG+++                      select w.inst_id, w.kywmnfnum, w.kywmnfpc, w.kywmnfwrc,          decode(bitand(w.kywmnfflg,1), 0, 0, 1),          decode(bitand(w.kywmnfflg,2), 0, 0, 1),          s.service_name, w.kywmnfmod, w.kywmnfact,          s.username, s.program, s.con_id         from x$kywmnf w, v$session s where w.kywmnfnum = s.sid
+++GV$CELL+++                         SELECT INST_ID, CELLPATH_CELLROW, CELLHASHVAL_CELLROW, CON_ID,  CELLTYPE_CELLROW FROM X$CELL_NAME
+++GV$CELL_CONFIG+++                  SELECT INST_ID, CELLNAME, CELLHASH, CONFTYPE, CONFVAL, CON_ID         FROM X$KCFISOSSC
+++GV$CELL_CONFIG_INFO+++             SELECT INST_ID, CELLNAME, CELLHASH, CONFTYPE, CONFVAL_HASH, CONFVAL,          CON_ID FROM X$KCFISOSSAWR
+++GV$CELL_DB+++                      SELECT c.CELLPATH_CELLROW, cd.CELL_HASH, cd.INCARNATION_NUM, cd.METRIC_TIMESTAMP, cd.DB, cd.DB_ID, cd.METRIC_ID, md.METRIC_NAME, cd.METRIC_VALUE, md.METRIC_TYPE, cd.INST_ID, cd.CON_ID FROM X$KXDCM_DB cd, X$KXDCM_METRIC_DESC md,      X$CELL_NAME c WHERE cd.METRIC_ID = md.METRIC_ID AND cd.CELL_HASH = c.CELLHASHVAL_CELLROW AND cd.INST_ID = md.INST_ID AND cd.CON_ID = md.CON_ID AND cd.INST_ID = c.INST_ID AND cd.CON_ID = c.CON_ID AND md.METRIC_ID not in (290, 291)
+++GV$CELL_DB_HISTORY+++              SELECT c.CELLPATH_CELLROW, cd.CELL_HASH, cd.INCARNATION_NUM, cd.BEGIN_TIME, cd.END_TIME, cd.DB, cd.DB_ID, cd.METRIC_ID, md.METRIC_NAME, cd.METRIC_VALUE, md.METRIC_TYPE, cd.INST_ID, cd.CON_ID FROM X$KXDCM_DB_HISTORY cd, X$KXDCM_METRIC_DESC md,      X$CELL_NAME c WHERE cd.METRIC_ID = md.METRIC_ID AND cd.CELL_HASH = c.CELLHASHVAL_CELLROW AND cd.INST_ID = md.INST_ID AND cd.CON_ID = md.CON_ID AND cd.INST_ID = c.INST_ID AND cd.CON_ID = c.CON_ID
+++GV$CELL_DISK+++                    SELECT c.CELLPATH_CELLROW, cd.CELL_HASH, cd.INCARNATION_NUM, cd.METRIC_TIMESTAMP, cd.DISK, cd.DISK_ID, cd.METRIC_ID, md.METRIC_NAME, cd.METRIC_VALUE, md.METRIC_TYPE, cd.INST_ID, cd.CON_ID FROM X$KXDCM_DISK cd, X$KXDCM_METRIC_DESC md,      X$CELL_NAME c WHERE cd.METRIC_ID = md.METRIC_ID AND cd.CELL_HASH = c.CELLHASHVAL_CELLROW AND cd.INST_ID = md.INST_ID AND cd.CON_ID = md.CON_ID AND cd.INST_ID = c.INST_ID AND cd.CON_ID = c.CON_ID
+++GV$CELL_DISK_HISTORY+++            SELECT c.CELLPATH_CELLROW, cd.CELL_HASH, cd.INCARNATION_NUM, cd.BEGIN_TIME, cd.END_TIME, cd.DISK, cd.DISK_ID, cd.METRIC_ID, md.METRIC_NAME, cd.METRIC_VALUE, md.METRIC_TYPE, cd.INST_ID, cd.CON_ID FROM X$KXDCM_DISK_HISTORY cd, X$KXDCM_METRIC_DESC md,      X$CELL_NAME c WHERE cd.METRIC_ID = md.METRIC_ID AND cd.CELL_HASH = c.CELLHASHVAL_CELLROW AND cd.INST_ID = md.INST_ID AND cd.CON_ID = md.CON_ID AND cd.INST_ID = c.INST_ID AND cd.CON_ID = c.CON_ID
+++GV$CELL_GLOBAL+++                  SELECT c.CELLPATH_CELLROW, cg.CELL_HASH, cg.INCARNATION_NUM, cg.METRIC_TIMESTAMP, cg.METRIC_ID, md.METRIC_NAME, cg.METRIC_VALUE, md.METRIC_TYPE, cg.INST_ID, cg.CON_ID FROM X$KXDCM_GLOBAL cg, X$KXDCM_METRIC_DESC md,      X$CELL_NAME c WHERE cg.METRIC_ID = md.METRIC_ID AND cg.CELL_HASH = c.CELLHASHVAL_CELLROW AND cg.INST_ID = md.INST_ID AND cg.CON_ID = md.CON_ID AND cg.INST_ID = c.INST_ID AND cg.CON_ID = c.CON_ID
+++GV$CELL_GLOBAL_HISTORY+++          SELECT c.CELLPATH_CELLROW, cg.CELL_HASH, cg.INCARNATION_NUM, cg.BEGIN_TIME, cg.END_TIME, cg.METRIC_ID, md.METRIC_NAME, cg.METRIC_VALUE, md.METRIC_TYPE, cg.INST_ID, cg.CON_ID FROM X$KXDCM_GLOBAL_HISTORY cg, X$KXDCM_METRIC_DESC md,      X$CELL_NAME c WHERE cg.METRIC_ID = md.METRIC_ID AND cg.CELL_HASH = c.CELLHASHVAL_CELLROW AND cg.INST_ID = md.INST_ID AND cg.CON_ID = md.CON_ID AND cg.INST_ID = c.INST_ID AND cg.CON_ID = c.CON_ID
+++GV$CELL_IOREASON+++                SELECT c.CELLPATH_CELLROW, r.CELL_HASH, r.INCARNATION_NUM, r.METRIC_TIMESTAMP, r.REASON_ID, nm.REASON_NAME, r.METRIC_ID, md.METRIC_NAME, r.METRIC_VALUE, md.METRIC_TYPE, r.INST_ID, r.CON_ID FROM X$KXDCM_IOREASON r, X$KXDCM_IOREASON_NAME nm,      X$KXDCM_METRIC_DESC md, X$CELL_NAME c WHERE r.METRIC_ID = md.METRIC_ID AND r.CELL_HASH = c.CELLHASHVAL_CELLROW AND r.REASON_ID = nm.REASON_ID AND r.INST_ID = md.INST_ID AND r.CON_ID = md.CON_ID AND r.INST_ID = nm.INST_ID AND r.CON_ID = nm.CON_ID AND r.INST_ID = c.INST_ID AND r.CON_ID = c.CON_ID
+++GV$CELL_IOREASON_NAME+++           SELECT REASON_ID, REASON_NAME, INST_ID, CON_ID FROM X$KXDCM_IOREASON_NAME
+++GV$CELL_METRIC_DESC+++             SELECT METRIC_ID, METRIC_NAME, METRIC_TYPE, INST_ID, CON_ID FROM X$KXDCM_METRIC_DESC
+++GV$CELL_OFL_THREAD_HISTORY+++      SELECT INST_ID, CELL_NAME, GROUP_NAME, PROCESS_ID, SNAPSHOT_ID, SNAPSHOT_TIME, THREAD_ID, JOBTYPE, WAITSTATE, WAITOBJ, SQL_ID, DATABASE_ID, INSTANCE_ID, SESSION_ID, SESSION_SERIAL_NUM, CON_ID FROM X$KCFISOSSL
+++GV$CELL_OPEN_ALERTS+++             SELECT c.CELLPATH_CELLROW, cd.CELL_HASH, cd.BEGIN_TIME, cd.SEQ_NO, cd.MESSAGE, CASE WHEN cd.STATEFUL = 0 THEN 'N'      ELSE 'Y' END, cd.SEVERITY, cd.INST_ID, cd.CON_ID FROM X$KXDCM_OPEN_ALERTS cd, X$CELL_NAME c WHERE cd.CELL_HASH = c.CELLHASHVAL_CELLROW AND cd.INST_ID = c.INST_ID AND cd.CON_ID = c.CON_ID
+++GV$CELL_REQUEST_TOTALS+++          SELECT INST_ID, CELLNAME, SNAPSHOT_ID, SNAPSHOT_TIME, STATNAME, STAT_VALUE, CON_ID FROM X$KCFISOSST
+++GV$CELL_STATE+++                   SELECT INST_ID, CELLNAME, STATTYPE, OBJNAME, STATVAL, CON_ID FROM X$KCFISOSS
+++GV$CELL_THREAD_HISTORY+++          SELECT INST_ID, CELLNAME, SNAPSHOT_ID, SNAPSHOT_TIME, THREAD_ID, JOBTYPE, WAITSTATE, WAITOBJ, SQL_ID, DATABASE_ID, INSTANCE_ID, SESSION_ID, SESSION_SERIAL_NUM, CON_ID FROM X$KCFISOSSN
+++GV$CHANNEL_WAITS+++                select            a.inst_id, a.NAME_KSRCDES, b.TOTPUB_KSRCCTX, b.WAITCOUNT_KSRCCTX,            b.WAITTIME_KSRCCTX, a.con_id          from X$KSRCDES a, X$KSRCCTX b          where b.NAME_KSRCCTX=a.indx and b.WAITCOUNT_KSRCCTX>0
+++GV$CIRCUIT+++                      select inst_id,kmcvcadr,kmcvcdpc,decode(kmcvcpro,kmcvcdpc, hextoraw('00'),kmcvcpro),kmcvcwat,kmcvcses,kmcvcsta,kmcvcque,kmcvcsz0, kmcvcsz1,kmcvcsz2,kmcvcsz3,kmcvcnmg,kmcvcnmb,kmcvcbrk,kmcvcpre,kmcvcpvc, con_id from x$kmcvc where bitand(ksspaflg,1) != 0
+++GV$CLASS_CACHE_TRANSFER+++         select 0, 'data block', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  from dual
+++GV$CLASS_PING+++                   select 0, 'data block', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  0 from dual
+++GV$CLIENT_RESULT_CACHE_STATS+++    select  INST_ID,             KPOQSTA_CACHE_ID,        KPOQSTA_STAT_ID,        KPOQSTA_NAME,        KPOQSTA_VALUE,        CON_ID  from x$kpoqsta
+++GV$CLIENT_SECRETS+++               SELECT INST_ID, CLIENT, SECRET_TAG, CREATION_TIME, ACTIVATION_TIME, OWNER, OWNER_ID, decode(BITAND(DESCRIPTION, 24), 8, 'HSM',  16, 'SOFTWARE KEYSTORE',      'UNDEFINED'), decode(BITAND(FLAG, 16),  0, 'NO',  16, 'YES',      'UNDEFINED'), OWNER_DBNAME, OWNER_DBID, OWNER_INSTANCE_NAME, OWNER_INSTANCE_NUMBER, OWNER_INSTANCE_SERIAL, OWNER_PDBNAME, OWNER_PDBID, OWNER_PDBUID, OWNER_PDBGUID, CON_ID FROM X$KZCKMCS
+++GV$CLIENT_STATS+++                 select c.inst_id, c.clsnam, m.extid, m.sname, c.statval, c.con_id  from x$kewecls c, x$kewssmap m  where c.clspos = m.offst and m.aggid = 6
+++GV$CLONEDFILE+++                   select INST_ID, SNAPSHOTFILENAME, CLONEFILENAME, SNAPSHOTBLKREAD,  SNAPSHOTREQUEST, FILENUMBER, CON_ID, BLOCKS_ALLOCATED  from x$ksfdsscloneinfo
+++GV$CLUSTER_INTERCONNECTS+++        SELECT INST_ID, NAME_SKGXPIA, IP_SKGXPIA,          decode(PUB_SKGXPIA, 'Y', 'YES', 'N', 'NO'),          decode(PICKED_SKGXPIA, 'OSD', 'OS dependent software',                 'OCR', 'Oracle Cluster Repository',                 'CI', 'cluster_interconnects parameter'), CON_ID                  FROM X$SKGXPIA
+++GV$CONFIGURED_INTERCONNECTS+++     SELECT INST_ID, NAME_KSXPIA, IP_KSXPIA,          decode(PUB_KSXPIA, 'Y', 'YES', 'N', 'NO'),          decode(PICKED_KSXPIA, 'OSD', 'OS dependent software',                'OCR', 'Oracle Cluster Repository',                'CI', 'cluster_interconnects parameter'), CON_ID         FROM X$KSXPIA
+++GV$CONTAINERS+++                   select inst_id, con_id, dbid, con_uid, guid, name,         decode(state, 0, 'MOUNTED', 1, 'READ WRITE', 2, 'READ ONLY',                3, 'MIGRATE'),         decode(restricted, 0, 'NO', 1, 'YES'), stime, create_scn, total_size,         block_size, decode(recovery_status, 0, 'ENABLED', 1, 'DISABLED'),         snapshot_parent_con_id from x$con
+++GV$CONTEXT+++                      select namespace, attribute, value, con_id from x$context
+++GV$CONTROLFILE+++                  select inst_id,decode(bitand(cfflg,1),0,'',1,'INVALID'),cfnam, decode(bitand(cffl2,1),0,'NO','YES'), cfbsz, cffsz, con_id  from x$kcccf
+++GV$CONTROLFILE_RECORD_SECTION+++   select inst_id,decode(indx,0,'DATABASE',1, 'CKPT PROGRESS', 2, 'REDO THREAD',3,'REDO LOG',4,'DATAFILE',5,'FILENAME',6,'TABLESPACE',7,'TEMPORARY FILENAME',8,'RMAN CONFIGURATION',9,'LOG HISTORY',10,'OFFLINE RANGE',11,'ARCHIVED LOG',12,'BACKUP SET',13,'BACKUP PIECE',14,'BACKUP DATAFILE',15, 'BACKUP REDOLOG',16,'DATAFILE COPY',17,'BACKUP CORRUPTION',18,'COPY CORRUPTION',19,'DELETED OBJECT',20,'PROXY COPY',21,'BACKUP SPFILE',23,'DATABASE INCARNATION',24,'FLASHBACK LOG',25, 'RECOVERY DESTINATION', 26,'INSTANCE SPACE RESERVATION', 27, 'REMOVABLE RECOVERY FILES', 28, 'RMAN STATUS', 29, 'THREAD INSTANCE NAME MAPPING', 30, 'MTTR', 31, 'DATAFILE HISTORY', 32, 'STANDBY DATABASE MATRIX', 33, 'GUARANTEED RESTORE POINT', 34, 'RESTORE POINT', 35, 'DATABASE BLOCK CORRUPTION', 36, 'ACM OPERATION', 37, 'FOREIGN ARCHIVED LOG', 38, 'PDB RECORD', 39, 'AUXILIARY DATAFILE COPY', 40, 'MULTI INSTANCE REDO APPLY', 41, 'PDBINC RECORD', 'UNKNOWN'),rsrsz,rsnum,rsnus,rsiol,rsilw,rsrlw, con_id from x$kccrs where indx not in (22)
+++GV$CON_SYSSTAT+++                  select inst_id,ksusgstn,ksusdnam,ksusdcls,ksusgstv,ksusdhsh, con_id from x$con_ksusgsta
+++GV$CON_SYSTEM_EVENT+++             select d.inst_id, d.kslednam, (s.ksleswts_un + s.ksleswts_fg + s.ksleswts_bg), (s.kslestmo_un + s.kslestmo_fg + s.kslestmo_bg), round((s.kslestim_un + s.kslestim_fg + s.kslestim_bg)/10000),  round((s.kslestim_un + s.kslestim_fg + s.kslestim_bg)/ (10000 * (s.ksleswts_un + s.ksleswts_fg + s.ksleswts_bg)), 2), (s.kslestim_un + s.kslestim_fg + s.kslestim_bg), s.ksleswts_fg, s.kslestmo_fg, round(s.kslestim_fg/10000), round(s.kslestim_fg/decode(s.ksleswts_fg, 0, 1, 10000 * s.ksleswts_fg), 2), s.kslestim_fg, d.ksledhash, d.ksledclassid, d.ksledclass#, d.ksledclass, s.con_id  from x$con_kslei s, x$ksled d  where (s.ksleswts_un > 0 or s.ksleswts_fg > 0 or s.ksleswts_bg > 0) and s.kslesevt = d.indx
+++GV$CON_SYSTEM_WAIT_CLASS+++        select s.inst_id, s.kslscsclsid, s.kslscscls, s.kslscsclsname, (s.kslscswts_un + s.kslscswts_fg + s.kslscswts_bg), round((s.kslscstim_un + s.kslscstim_fg + s.kslscstim_bg)/10000), s.kslscswts_fg, round(s.kslscstim_fg/10000), s.con_id  from x$con_kslscs s where s.kslscswts_un > 0 or s.kslscswts_fg > 0 or s.kslscswts_un > 0
+++GV$CON_SYS_TIME_MODEL+++           select map.inst_id, map.extid, map.sname, sysv.kewsval, sysv.con_id  from x$kewssmap map, x$con_kewssysv sysv  where map.offst = sysv.kewsidx and map.aggid = 1 and  (map.stype = 2 or map.stype = 3)
+++GV$COPY_CORRUPTION+++              select inst_id,ccrid,ccstm,ccdcp,ccdcs,ccdfp,ccblk,cccnt,to_number(ccscn),decode(bitand(ccflg,1),1,'YES','NO'),decode(bitand(ccflg,65534),2,'ALL ZERO',4,'FRACTURED',8,'CHECKSUM',                        16,'CORRUPT', 32, 'NOLOGGING',                         64, 'LOGICAL', 'UNKNOWN'), con_id  from x$kcccc  where bitand(ccflg, 65534) != 32
+++GV$COPY_NONLOGGED+++                select                                                                         cc.inst_id,                                                                  cc.ccrid,                                                                    cc.ccstm,                                                                    cc.ccdcp,                                                                    cc.ccdcs,                                                                    cc.ccdfp,                                                                    cc.ccblk,                                                                    cc.cccnt,                                                                    to_number(cc.ccscn),                                                         NULL,                                                                        NULL,                                                                        NULL,                                                                        NULL,                                                                        'UNKNOWN',                                                                   cc.con_id                                                                  from                                                                           x$kcccc cc                                                                 where                                                                          bitand(ccflg, 65534) = 32
+++GV$CORRUPT_XID_LIST+++             select  INST_ID, CORRUPT_XID, CON_ID from x$ktucus
+++GV$CPOOL_CC_INFO+++                select  POOL_NAME,        CCLASS_NAME,        INST_ID,         CON_ID from x$kpplcc_info
+++GV$CPOOL_CC_STATS+++               select  CCLASS_NAME,        INST_ID,        NUM_REQUESTS,        NUM_HITS,        NUM_MISSES,        NUM_WAITS,        WAIT_TIME,        CLIENT_REQ_TIMEOUTS,        NUM_AUTHENTICATIONS,         CON_ID from x$kpplcc_stats
+++GV$CPOOL_CONN_INFO+++               select  c.KMPCSOTCMON ,          b.SADDR,          a.CONNECTION_ADDR,          a.USERNAME,         a.PROXY_USER,         a.CCLASS_NAME,         a.PURITY,         a.TAG,         a.SERVICE,         a.PROCESS_ID,         a.PROGRAM,         a.MACHINE,         a.TERMINAL,         a.CONNECTION_MODE,         DECODE(c.KMPCSOSTATE, 0 , 'NONE',                                1 , 'CONNECTING',                               2 , 'NONE',                                3 , 'ACTIVE',                                4 , 'WAITING',                                5 , 'IDLE',                                6 , 'NONE',                                7 , 'CLOSING') CONNECTION_STATUS,           c.kmpcsocqcregid,          c.KMPCSOSTIME,          a.INST_ID,           a.CON_ID           from  X$KPPLCONN_INFO a left join V$SESSION b           on a.sid = b.sid and a.serial# = b.serial#, X$KMPCSO c           where a.CONNECTION_ADDR = c.KMPCSOADDR
+++GV$CPOOL_STATS+++                  select  POOL_NAME,        INST_ID,        NUM_OPEN_SERVERS,        NUM_BUSY_SERVERS,        NUM_AUTH_SERVERS,        NUM_REQUESTS,        NUM_HITS,        NUM_MISSES,        NUM_WAITS,        WAIT_TIME,        CLIENT_REQ_TIMEOUTS,        NUM_AUTHENTICATIONS,        NUM_PURGED,        HISTORIC_MAX,         CON_ID from x$kpplcp_stats
+++GV$CR_BLOCK_SERVER+++              select inst_id, reqcr, reqcur, reqdata, requndo,             reqtx, reqother, rescur, respriv, reszero, resdisk,          resfail, stale, fairdc, faircl, 0, flush, 0,                 flushf, flushmx, light, signal, con_id                       from x$kclcrst
+++GV$CURRENT_BLOCK_SERVER+++         select inst_id, pin1, pin10, pin100, pin1000, pin10000,          flush1, flush10, flush100, flush1000, flush10000,                write1, write10, write100, write1000, write10000,                cleandc, rcvdc, queuedc, evictdc, writedc, con_id                from x$kclcurst
+++GV$DATABASE+++                     select di.inst_id,di.didbi,di.didbn,to_date(di.dicts,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(di.dirls),to_date(di.dirlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(di.diprs),to_date(di.diprc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(di.dimla,0,'NOARCHIVELOG',1,'ARCHIVELOG','MANUAL'),to_number(di.discn),to_number(di.difas),decode(bitand(di.diflg,256),256,'CREATED',decode(bitand(di.diflg,1024),1024,'STANDBY',decode(bitand(di.diflg,32768),32768,'CLONE',decode(bitand(di.diflg,4096),4096,'BACKUP','CURRENT')))),to_date(di.dicct,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),di.dicsq,to_number(di.dickp_scn),to_date(di.dickp_tim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(di.diflg,4),4,'REQUIRED',decode(di.diirs,0,'NOT ALLOWED','ALLOWED')),to_date(di.divts,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(di.didor,0,'MOUNTED',decode(di.didor,1,'READ WRITE',decode(di.didor,2,'READ ONLY',decode(di.didor,3,'READ ONLY WITH APPLY','CLOSED BY SWITCHOVER')))),decode(bitand(di.diflg,65536),65536,'MAXIMUM PROTECTION',decode(bitand(di.diflg,128),128,'MAXIMUM AVAILABILITY',decode(bitand(di.diflg,134217728),134217728,'RESYNCHRONIZATION',decode(bitand(di.diflg,8),8,'UNPROTECTED','MAXIMUM PERFORMANCE')))),decode(di.diprt,1,'MAXIMUM PROTECTION',2,'MAXIMUM AVAILABILITY',3,'RESYNCHRONIZATION',4,'MAXIMUM PERFORMANCE',5,'UNPROTECTED',  'UNKNOWN'),decode(di.dirae,0,'DISABLED',1,'SEND',2,'RECEIVE',3,'ENABLED','UNKNOWN'),to_number(di.diacid),to_number(di.diacid),decode(bitand(di.difl2,32768),32768,'SNAPSHOT STANDBY',decode(bitand(di.diflg,33554432),33554432,'LOGICAL STANDBY',decode(bitand(di.diflg,1024),1024,'PHYSICAL STANDBY',decode(bitand(di.difl3,8),8,'FAR SYNC', 'PRIMARY')))),to_number(di.diars),decode(bitand(difl2,1),1,'ENABLED','DISABLED'),decode(di.disos,0,'IMPOSSIBLE',1,'NOT ALLOWED',2,'SWITCHOVER LATENT',3,'SWITCHOVER PENDING',4,'TO PRIMARY',5,'TO STANDBY',6,'RECOVERY NEEDED',7,'SESSIONS ACTIVE',8,'PREPARING SWITCHOVER',9,'PREPARING DICTIONARY',10,'TO LOGICAL STANDBY',11,'FAILED DESTINATION',12,'RESOLVABLE GAP',13,'LOG SWITCH GAP',14,'UNRESOLVABLE GAP',NULL),decode(di.didgd,0,'DISABLED','ENABLED'),decode(bitand(di.diflg,1048576),1048576,'ALL',decode(bitand(di.diflg,2097152),2097152,'STANDBY','NONE')),decode(bitand(diflg,1073741824),1073741824, 'YES',               decode(bitand(diflg, 131072 + 262144 + 524288),0,                      decode(bitand(difl2,2 + 64), 0,'NO','IMPLICIT'),                     'IMPLICIT')),decode(bitand(di.diflg,131072),131072,'YES','NO'),decode(bitand(di.diflg,262144),262144,'YES','NO'),decode(bitand(di.diflg,268435456),268435456,'YES',         decode(bitand(di2flag, 16384), 16384,                'STANDBY NOLOGGING FOR DATA AVAILABILITY',         decode(bitand(di2flag, 32768), 32768,                 'STANDBY NOLOGGING FOR LOAD PERFORMANCE','NO'))),di.diplid, di.dipln, di2.di2rdi, di2.di2inc,to_number(di.dicur_scn),decode(bitand(di2.di2flag,1),1,'YES',               decode(di2.di2rsp_oldest,0,'NO','RESTORE POINT ONLY')),decode(bitand(diflg,524288),524288,'YES','NO'),decode(bitand(difl2,2),2,'YES','NO'),di2.di2dbun, to_number(di2.di2actiscn), decode(di.difsts,0,'DISABLED',1,'BYSTANDER',2,'SYNCHRONIZED',3,'UNSYNCHRONIZED',4,'SUSPENDED',5,'STALLED',6,'LOADING DICTIONARY',7,'PRIMARY UNOBSERVED',8,'REINSTATE REQUIRED',10,'REINSTATE FAILED',11,'TARGET OVER LAG LIMIT',12,'TARGET UNDER LAG LIMIT',''), di.diftgt, di.difths,decode(di.difopr,1,'YES',2,'NO',3,'UNKNOWN',''), di.difobs, decode(bitand(difl2, 16384), 16384, 'YES', 'NO'), di2.di2pdbun, decode(bitand(di.difl2,64), 64, 'YES', 'NO'), decode(di2.di2min_req_capture_scn, 0, to_number(null),         di2.di2min_req_capture_scn), decode(bitand(di.difl3,2), 2, 'YES', 'NO'), di.con_id, di.diprct, to_number(sys_context('userenv','con_dbid')), decode(bitand(di2.di2flg, 32768), 32768, 'YES', 'NO') from x$kccdi di, x$kccdi2 di2
+++GV$DATABASE_BLOCK_CORRUPTION+++    select inst_id, cor.blkfno, cor.blksblk, cor.blktot, cor.blkscn,  decode(bitand(cor.blktype, 255), 2, 'ALL ZERO', 3,'FRACTURED', 4,'CHECKSUM',        5,'CORRUPT', 6, 'NOLOGGING', 7, 'LOGICAL', 'UNKNOWN'), cor.con_id  from x$kccblkcor cor, v$datafile df   where bitand(cor.blktype, 255) != 1 and bitand(cor.blktype, 255) != 6    and cor.blkfno = df.file#    and cor.blkcrs = df.creation_change#    and cor.blkcrt = df.creation_time
+++GV$DATABASE_INCARNATION+++         select userenv('Instance'),  icrid, to_number(icrls),         to_date(icrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),         to_number(icprs),         to_date(icprc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),         decode(bitand(icflg,3), 1,'ORPHAN', 2, 'CURRENT', 0, 'PARENT',                'ORPHAN'),         icrlc_i, icpinc, icalw, con_id  from x$kccic
+++GV$DATABASE_KEY_INFO+++            select INST_ID,                                  decode(ALG, 0, 'NONE',                                       1, '3DES168',                                    2, 'AES128',                                     3, 'AES192',                                     4, 'AES256'),                        ENCRYPTEDKEY,                                    MKID, CON_ID                                     from X$KCBDBK
+++GV$DATAFILE+++                     select inst_id,df_fenum,to_number(df_fecrc_scn), to_date(df_fecrc_tim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), df_fetsn,df_ferfn, decode(df_fetsn,        0,decode(bitand(df_feflg,4),                  4,'SYSTEM',                    decode(bitand(df_festa,2),                           0,'SYSOFF',                             'SYSTEM')),         decode(bitand(df_feflg,4),                4,'ONLINE',                  decode(bitand(df_festa,18),                         0,'OFFLINE',                         2,'ONLINE',                           'RECOVER'))),  decode(df_fedor_root,         2,'READ ONLY',          decode(bitand(df_feunknown, 1), 1, 'UNKNOWN',            decode(bitand(df_feflg,4),                   4,'READ WRITE',                     decode(bitand(df_festa,12),                            0, 'DISABLED',                            4, 'READ ONLY',                            12,'READ WRITE',                               'UNKNOWN')))),  to_number(df_fecps), to_date(df_fecpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(df_feurs), to_date(df_feurt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(df_fests), decode(df_fests,NULL,to_date(NULL),  to_date(df_festt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')), to_number(df_feofs),to_number(df_feonc_scn), to_date(df_feonc_tim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), df_fhfsz*df_febsz,df_fhfsz,df_fecsz*df_febsz,df_febsz,df_fnnam, df_fefdb, df_fnbof,  decode(df_fepax, 0, 'UNKNOWN', 65535, 'NONE', df_fnauxnam),     to_number(df_fhfirstunrecscn),                                  to_date(df_fhfirstunrectime,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), df_fepdi, df_fefcrs, df_fefcrt, decode(df_fefdb, 1, 'YES', 'NO'),  df_feplus, df_feprls, df_feprlt, con_id  from x$kcvdf df
+++GV$DATAFILE_COPY+++                select inst_id,dcrid,dcstm,dcnam,dctag,dcdfp,dcrfn,to_number(dccrs),to_date(dccrt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(dcrls),to_date(dcrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(dcflg,8),8,0,NULL),to_number(dccps),to_date(dccpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(dcafs),to_number(dcrfs),to_date(dcrft,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(dcflg, 2),0,'NO','YES'),decode(bitand(dcflg, 4),0,'NO','YES'),dcncb,dcmcb,dclcb,dcbct,dcbsz,dclor,decode(bitand(dcflg, 1),0,'NO','YES'),decode(bitand(dcflg, 1+32+64+4096),0,'A',1,'D',32,'X',64,'U',                                   4096+1,'F','?'),to_date(dctsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), decode(dcdfp, 0, decode(bitand(dcflg, 16),16,'S','B'),NULL), decode(bitand(dcflg, 1792), 0, 'NO',                                           'YES'),          to_date(dckpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(dcflg, 1792), 256,  'LOGS',                              512,  'NOLOGS',                            1024, 'BACKUP_LOGS',                                     NULL),         decode(bitand(dcflg, 128),0,'NO','YES'), decode(bitand(dcflg, 2048),0,'NO','YES'), dcrsi, dcrst, decode(bitand(dcflg, 4096),0,'NO','YES'), decode(bitand(dcflg, 4096+8192),0,NULL,4096,'NO','YES'), dcfdi, decode(bitand(dcflg, 16384), 0, 'NO', 'YES'), dcplus, dcprls, dcprlt, decode(bitand(dcflg, 32768), 0, 'NO', 'YES'), con_id, decode(bitand(dcflg2, 1), 0, 'NO', 'YES') from x$kccdc
+++GV$DATAFILE_HEADER+++              select inst_id,hxfil,decode(hxons, 0, 'OFFLINE', 'ONLINE'),decode(hxerr, 0, NULL, 1,'FILE MISSING',2,'OFFLINE NORMAL', 3,'NOT VERIFIED', 4,'FILE NOT FOUND',5,'CANNOT OPEN FILE', 6,'CANNOT READ HEADER', 7,'CORRUPT HEADER',8,'WRONG FILE TYPE', 9,'WRONG DATABASE', 10,'WRONG FILE NUMBER',11,'WRONG FILE CREATE', 12,'WRONG FILE CREATE', 16,'DELAYED OPEN',14, 'WRONG RESETLOGS', 15,'OLD CONTROLFILE', 'UNKNOWN ERROR'),hxver,decode(hxnrcv, 0,'NO', 1,'YES', NULL),decode(hxifz, 0,'NO', 1,'YES', NULL),to_number(fhcrs),to_date(fhcrt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),fhtnm,fhtsn,fhrfn,to_number(fhrls),to_date(fhrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(fhscn),to_date(fhtim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),fhcpc,fhfsz*fhbsz,fhfsz,hxfnm, decode(hxlmdba, 0, NULL, hxlmdba), decode(hxlmld_scn, to_number('0'), NULL, hxlmld_scn), decode(hxuopc_scn, 0, NULL, hxuopc_scn), con_id from x$kcvfh
+++GV$DATAGUARD_CONFIG+++             select DGCDBUN,         DGCPDBUN,         decode(DGCDROLE, 1, 'PRIMARY DATABASE',                          2, 'PHYSICAL STANDBY',                          3, 'SNAPSHOT STANDBY',                          4, 'FAR SYNC INSTANCE',                          5, 'LOGICAL STANDBY',                          6, 'BACKUP APPLIANCE',                             'UNKNOWN'),         to_number(DGCSCN),         CON_ID  from x$krstdgc
+++GV$DATAGUARD_STATS+++              select INST_ID, SOURCE_DBID, SOURCE_DB_UNIQUE_NAME, NAME, VALUE, UNIT, TIME_COMPUTED, DATUM_TIME, CON_ID from x$krstpvrs
+++GV$DATAGUARD_STATUS+++             select inst_id, decode(agfac,1,'Crash Recovery',              2,'Log Transport Services',              3,'Log Apply Services',              4,'Role Management Services',              5,'Remote File Server',              6,'Fetch Archive Log',              7,'Data Guard',              8,'Network Services',                'UNKNOWN'), decode(agsev,1,'Informational',              2,'Warning',              3,'Error',              4,'Fatal',              5,'Control',                'UNKNOWN'), agdid, agseq, agoer, decode(bitand(agflg, 1),0,'NO','YES'), to_date(agdat,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), agtxt, con_id from x$krstalg order by agseq
+++GV$DATAPUMP_JOB+++                 SELECT inst_id, kupvjid, kupvjjob, kupvjowner,                 kupvjctrlque, kupvjstatque, kupvjoperation,                 kupvjmode, kupvjmasterid, kupvjstate, kupvjworkers,                 kupvjflags, kupvjserialnum, kupvjquetabnum, con_id          FROM   x$kupvj
+++GV$DATAPUMP_SESSION+++             SELECT inst_id, kupvaid, kupvajobid, kupvasesaddr,                 decode(kupvasestype,1,'DBMS_DATAPUMP',2,'MASTER',3,'WORKER',                        4,'EXTERNAL TABLE','OTHER'), con_id          FROM   x$kupva
+++GV$DBFILE+++                       select inst_id,fnfno,fnnam, con_id from x$kccfn where fnnam is not null and bitand(fnflg, 4) != 4 and fntyp=4
+++GV$DBLINK+++                       select inst_id,nconam, ncouid, decode(bitand(hstflg, 32), 0, 'NO', 'YES'),  decode(bitand(hstflg, 8), 0, 'NO', 'YES'),  decode(hstpro, 1, 'V5', 2, 'V6', 3, 'V6_NLS', 4, 'V7', 'UNKN'),  ncouct, decode(bitand(ncoflg, 2), 0, 'NO', 'YES'),  decode(bitand(ncoflg, 8), 0, 'NO', 'YES'), nco2pstr, con_id  from x$uganco where bitand(hstflg, 1) != 0
+++GV$DB_CACHE_ADVICE+++              select A.inst_id, A.bpid, B.bp_name, A.blksz,                      decode (A.status, 2, 'ON', 'OFF'),                                 A.poolsz,                                                          round((A.poolsz / A.actual_poolsz), 4),                            A.nbufs,                                                           decode (A.base_preads, 0, to_number(null),                                 round((A.preads / A.base_preads), 4)),                     decode (A.base_preads, 0, A.actual_preads,                                 round((A.preads * (A.actual_preads / A.base_preads)), 0)), A.estd_time_for_disk_reads,                                        decode (A.total_db_time, 0, A.estd_time_for_disk_reads,                    round((100 *                                                              A.estd_time_for_disk_reads / A.total_db_time), 1)), A.estd_rac_reads,                                                  A.estd_rac_time, A.con_id                                          from x$kcbsc A, x$kcbwbpd B                                        where A.bpid = B.bp_id and A.inst_id = B.inst_id                   order by A.inst_id, A.bpid, A.poolsz
+++GV$DB_OBJECT_CACHE+++              select inst_id,kglnaown,kglnaobj,kglnadlk,kglhdnsd,kglobtyd, kglobhs0+kglobhs1+kglobhs2+kglobhs3+kglobhs4+kglobhs5+kglobhs6, kglhdldc,kglhdexc,kglhdlkc,kglobpc0,decode(kglhdkmk,0,'NO','YES'),kglhdclt, kglhdivc, kglnahsh,              decode(kglhdlmd,                        0, 'NONE',                       1, 'NULL',                       2, 'SHARED',                     3, 'EXCLUSIVE',                  'UNKOWN'),                decode(kglhdpmd,                        0, 'NONE',                       1, 'NULL',                       2, 'SHARED',                     3, 'EXCLUSIVE',                  'UNKOWN'),                decode(kglobsta,                        1, 'VALID',                      2, 'VALID_AUTH_ERROR',           3, 'VALID_COMPILE_ERROR',        4, 'VALID_UNAUTH',               5, 'INVALID_UNAUTH',             6, 'INVALID',                    'UNKOWN'),                substr(to_char(kglnatim,'YYYY-MM-DD/HH24:MI:SS'),1,19), substr(to_char(kglnaptm,'YYYY-MM-DD/HH24:MI:SS'),1,19), kglobt23, kglobt24, kglobprop, kglnahsv, con_id, KGLNACON,  kglhdadr  from x$kglob where kglnaobj is not null
+++GV$DB_PIPES+++                     select inst_id,decode(kglobt00,1,kglobt17,null),kglnaobj, decode(kglobt00,1,'PRIVATE','PUBLIC'), kglobhs0+kglobhs1+kglobhs2+kglobhs3+kglobhs4+kglobhs5+kglobhs6, con_id, KGLNACON from x$kglob where kglhdnsp=7 and kglobsta != 0
+++GV$DB_TRANSPORTABLE_PLATFORM+++    select INST_ID, PLATFORM_ID, PLATFORM_NAME,          decode(endian_format, 1,'Big' ,0,'Little','UNKNOWN FORMAT'), con_id          from x$kcpxpl          where endian_format =            (select endian_format from x$kcpxpl pl, x$kccdi di             where pl.platform_id = di.diplid)
+++GV$DEAD_CLEANUP+++                 select inst_id,         ksuclndpcc_type, ksuclndpcc_proc, ksuclndpcc_sess, ksuclndpcc_state,         ksuclndpcc_dead_time, ksuclndpcc_cleanup_attempts,         ksuclndpcc_last_attempt, ksuclndpcc_cleanup_time,         ksuclndpcc_num_blocked,         con_id    from x$ksuclndpcc
+++GV$DELETED_OBJECT+++               select inst_id,dlrid,dlstm,decode(dltyp,11,'ARCHIVED LOG',13,'BACKUP PIECE',16,'DATAFILE COPY',20,'PROXY COPY',34,'RESTORE POINT',35,'DATABASE BLOCK CORRUPTION', 37,'FOREIGN ARCHIVED LOG', 255,'BACKUP PIECE AVAILABLE',254,'BACKUP PIECE EXPIRED',253,'PROXY COPY AVAILABLE',252,'PROXY COPY EXPIRED',251,'BACKUP PIECE UNAVAILABLE',250,'PROXY COPY UNAVAILABLE',249,'DATAFILE COPY AVAILABLE',248,'DATAFILE COPY EXPIRED',247,'DATAFILE COPY UNAVAILABLE',246,'ARCHIVED LOG AVAILABLE',245,'ARCHIVED LOG EXPIRED',244,'ARCHIVED LOG UNAVAILABLE',243,'BACKUP SET KEEP OPTIONS',242,'BACKUP SET KEEP UNTIL',241,'PROXY COPY KEEP OPTIONS',240,'PROXY COPY KEEP UNTIL',239,'DATAFILE COPY KEEP OPTIONS',238,'DATAFILE COPY KEEP UNTIL',237,'DATAFILE RENAME ON RESTORE',236,'TEMPFILE RENAME', 235,'PREVIOUS PIECE BACKUP SET', 234,'PLUGGED READONLY RENAME', 233,'BACKUP RECORD CLEANUP', 230,'INSTANT RESTORE', 'UNKNOWN'),dlobp,dlosm,dltsd,decode(dlbss, 0, to_number(NULL), dlbss), decode(dlbss, 0, to_number(NULL), dlbsc), con_id from x$kccdl
+++GV$DETACHED_SESSION+++             SELECT indx, inst_id, ksupgsnm, ksupgsid, ksupgser, ksupgspd, con_id   FROM x$ksupgs
+++GV$DG_BROKER_CONFIG+++             SELECT USERENV('Instance'),         substr(a.value,1,30),                           b.value,         decode(c.value, 'PRIMARY', 'PRIMARY',                         'PHYSICAL', 'PHYSICAL STANDBY',                         'LOGICAL', 'LOGICAL STANDBY',                         'SNAPSHOT', 'SNAPSHOT STANDBY',                         'FAR_SYNC_INSTANCE', 'FAR SYNC INSTANCE',                         'BACKUP_APPLIANCE', 'BACKUP APPLIANCE',                        'OTHER'),         substr(d.value,1,30),                          decode(a.e_d, ' E ', 'TRUE', 'FALSE'),         a.rsrc_err,         substr(e.value,1,30),                           di.con_id  FROM      (SELECT object_id, status, value, e_d, rsrc_err FROM x$drc d, x$vinst v         WHERE attribute='DATABASE' AND type='SITE' and act='YES'         AND d.value=v.name) a,      (SELECT object_id, value FROM x$drc WHERE attribute='connect_string') b,      (SELECT object_id, value FROM x$drc WHERE attribute='role') c,      (SELECT object_id, value FROM x$drc WHERE attribute='receive_from') d,      (SELECT value FROM x$drc WHERE attribute='version') e,      x$kccdi di  WHERE a.object_id=b.object_id AND        a.object_id=c.object_id AND        a.object_id=d.object_id
+++GV$DIAG_INFO+++                    SELECT inst_id, name, value, con_id FROM x$diag_info
+++GV$DISPATCHER+++                   select inst_id,kmmdinam,kmmdiadd,kmmdipro,kmmdista, decode(kmmdiacc,0,'NO','YES'),kmmdinmg,kmmdinmb,kmmdibrk, kmmdinvo,kmmditnc,kmmdiidl,kmmdibsy,kmmdiler,kmmdidci, con_id from x$kmmdi where kmmdiflg != 0
+++GV$DISPATCHER_CONFIG+++            select inst_id, indx, kmmdpnet, kmmdpopt, kmmdpcon, kmmdpses,  decode(bitand(kmmdpflg, 12), 0, 'OFF', 4, 'IN', 8, 'OUT', 'BOTH'),  kmmdplsn,kmmdpsnm, con_id from x$kmmdp
+++GV$DISPATCHER_RATE+++              select inst_id,kmmdinam,kmmdipro,kmmdicrle,kmmdicre,kmmdicepl,kmmdicrm, kmmdicrus,kmmdicrys,kmmdicyus,kmmdicruc,kmmdicryc,kmmdicyuc,kmmdicru, kmmdicry,kmmdicyu,kmmdicic,kmmdicoc,kmmdicrr,kmmdimrle,kmmdimre,kmmdimepl, kmmdimrm,kmmdimrus,kmmdimrys,kmmdimyus,kmmdimruc,kmmdimryc,kmmdimyuc, kmmdimru,kmmdimry,kmmdimyu,kmmdimic,kmmdimoc,kmmdimrr,kmmdiarle,kmmdiare, kmmdiaepl,kmmdiarm,kmmdiarus,kmmdiarys,kmmdiayus,kmmdiaruc,kmmdiaryc, kmmdiayuc,kmmdiaru,kmmdiary,kmmdiayu,kmmdiaic,kmmdiaoc,kmmdiarr, kmmdinrle,kmmdinrm,kmmdinrus,kmmdinruc,kmmdinru,kmmdinic,kmmdinoc,kmmdinrr, kmmdisrle,kmmdisrm,kmmdisrus,kmmdisruc,kmmdisru,kmmdisic,kmmdisoc,kmmdisrr, con_id from x$kmmdi where kmmdiflg!=0
+++GV$DLM_ALL_LOCKS+++                select USERENV('Instance'), HANDLE, GRANT_LEVEL, REQUEST_LEVEL,          RESOURCE_NAME1, RESOURCE_NAME2, PID, TRANSACTION_ID0,          TRANSACTION_ID1, GROUP_ID,          OPEN_OPT_DEADLOCK, OPEN_OPT_PERSISTENT, OPEN_OPT_PROCESS_OWNED,          OPEN_OPT_NO_XID, CONVERT_OPT_GETVALUE,          CONVERT_OPT_PUTVALUE, CONVERT_OPT_NOVALUE,          CONVERT_OPT_DUBVALUE, CONVERT_OPT_NOQUEUE,          CONVERT_OPT_EXPRESS, CONVERT_OPT_NODEADLOCKWAIT,          CONVERT_OPT_NODEADLOCKBLOCK, WHICH_QUEUE, STATE,          AST_EVENT0, OWNER_NODE, BLOCKED, BLOCKER, CON_ID from          V$GES_ENQUEUE
+++GV$DLM_CONVERT_LOCAL+++            select inst_id, kjicvtnam, kjicvtalt, kjicvtalc, con_id from x$kjicvt
+++GV$DLM_CONVERT_REMOTE+++           select inst_id, kjicvtnam, kjicvtart, kjicvtarc, con_id from x$kjicvt
+++GV$DLM_LATCH+++                    select USERENV('Instance'), addr, latch#, level#, name, gets, misses,  sleeps,immediate_gets, immediate_misses, waiters_woken,  waits_holding_latch, spin_gets, sleep1, sleep2, sleep3, sleep4,  sleep5, sleep6, sleep7, sleep8, sleep9, sleep10, sleep11,  wait_time, con_id  from V$LATCH where NAME like 'ges %' or NAME like 'gcs %'
+++GV$DLM_LOCKS+++                    select USERENV('Instance'), HANDLE, GRANT_LEVEL, REQUEST_LEVEL,          RESOURCE_NAME1,          RESOURCE_NAME2, PID, TRANSACTION_ID0, TRANSACTION_ID1, GROUP_ID,          OPEN_OPT_DEADLOCK, OPEN_OPT_PERSISTENT, OPEN_OPT_PROCESS_OWNED,          OPEN_OPT_NO_XID, CONVERT_OPT_GETVALUE,          CONVERT_OPT_PUTVALUE, CONVERT_OPT_NOVALUE,          CONVERT_OPT_DUBVALUE, CONVERT_OPT_NOQUEUE,          CONVERT_OPT_EXPRESS, CONVERT_OPT_NODEADLOCKWAIT,          CONVERT_OPT_NODEADLOCKBLOCK, WHICH_QUEUE, STATE,          AST_EVENT0, OWNER_NODE, BLOCKED, BLOCKER, CON_ID          from V$GES_BLOCKING_ENQUEUE
+++GV$DLM_MISC+++                     select inst_id, min(indx), kjisftdesc, sum(kjisftval), con_id from x$kjisft group by kjisftdesc, inst_id, con_id
+++GV$DLM_RESS+++                     select inst_id, kjirftrp, kjirftrn, kjirftcq, kjirftgq, kjirftpr, kjirftmn, kjirftncl, kjirftvs, kjirftvb, con_id from x$kjirft union all select inst_id, kjbrresp, kjbrname, decode(kjbrcvtq, '00', 0, 1), decode(kjbrgrantq, '00', 0, 1), 1, kjbrmaster, kjbrncvl, 'KJUSERVS_NOVALUE', '0x0', con_id from x$kjbr
+++GV$DLM_TRAFFIC_CONTROLLER+++       select inst_id, kjitrftlid,            kjitrftrid, kjitrftrrd, kjitrftinc,            kjitrftta,  kjitrfttl,  kjitrfttr,             decode(kjitrfttw,0, 'NO        ', 'YES       '),            kjitrftss,  kjitrftsr,             kjitrftsql, kjitrftsqm, kjitrftsqt, kjitrftqtb, kjitrftqtw,            kjitrftst,             kjitrftpxy, con_id           from x$kjitrft
+++GV$DNFS_CHANNELS+++                select inst_id, pnum, svrname, path, local, state, ch_id, svr_id,          sends, recvs, pings, spreco, dpreco, resends, sent, resent, recv,          sendq, pendq, restartq, con_id, rdma, rdma_credits, clientport,          active_speed, peak_fmr, current_fmr, fmrreg_count          from x$dnfs_channels
+++GV$DNFS_FILES+++                   select inst_id, filename, filesize, pnum, svr_id, con_id          from x$dnfs_files
+++GV$DNFS_SERVERS+++                 select inst_id, id, svrname, dirname, mntport, nfsport, nfsversion,          wtmax, rtmax, con_id, rdmaenable, rdmaport from x$dnfs_servers
+++GV$DNFS_STATS+++                   select inst_id, pnum, nfs_null, nfs_getattr, nfs_setattr,          nfs_lookup, nfs_access, nfs_readlink, nfs_read, nfs_write,          nfs_create, nfs_mkdir, nfs_symlink, nfs_mknod, nfs_remove, nfs_rmdir,          nfs_rename, nfs_link, nfs_readdir, nfs_readdirplus,          nfs_fsstat, nfs_fsinfo, nfs_pathconf, nfs_commit, nfs_mount,          nfs_readbytes, nfs_writebytes, con_id          from x$dnfs_stats
+++GV$DYNAMIC_REMASTER_STATS+++       select inst_id, 'AFFINITY', drms, total_drm_time, objects_per_drm, 0,  frz_t, cleanup_t, replay_t, fixwrite_t, sync_t, res_cleaned, replay_s,  replay_r, my_objects, con_id FROM x$kjdrmafnstats union  select inst_id, 'READ-MOSTLY', drms, total_drm_time, objects_per_drm, 0,  frz_t, cleanup_t, replay_t, fixwrite_t, sync_t, res_cleaned, 0, 0,  readmostly_objs, con_id FROM x$kjdrmreadmostlystats
+++GV$EDITIONABLE_TYPES+++            select inst_id, kkaeetnam, kkaeetnum, con_id from x$kkaeet
+++GV$EMON+++                         SELECT INST_ID,          EID_KPONESTAT, SID_KPONESTAT, START_KPONESTAT,         DECODE(QOS_KPONESTAT,0,'REGULAR','RELIABLE'),         DECODE(STATUS_KPONESTAT,0,'IDLE','ACTIVE'),         SCT_KPONESTAT, NTFN_KPONESTAT,          GRPNTFN_KPONESTAT, INGRPNTFN_KPONESTAT, NUMOCI_KPONESTAT,         NUMPLS_KPONESTAT, NUMEML_KPONESTAT,         NUMHTP_KPONESTAT, POSTSPROC_KPONESTAT,         POSTSPEND_KPONESTAT, NUMANON_KPONESTAT ,         NUMAQ_KPONESTAT, NUMDBC_KPONESTAT,         ANONTIME_KPONESTAT/1000000, AQTIME_KPONESTAT/1000000,         DBCTIME_KPONESTAT/1000000, PLSTIME_KPONESTAT/1000000 ,         OCITIME_KPONESTAT/1000000, EMLTIME_KPONESTAT/1000000 ,         HTPTIME_KPONESTAT/1000000, EMONLAT_KPONESTAT,         REGEXP_KPONESTAT, REGPRG_KPONESTAT , REGINV_KPONESTAT,          LUT_KPONESTAT, LASTERR_KPONESTAT, LET_KPONESTAT, CON_ID          FROM X$KPONESTAT            UNION ALL           SELECT INST_ID,          EID_KPONDESTAT, SID_KPONDESTAT, START_KPONDESTAT,         'SECURE',         DECODE(STATUS_KPONDESTAT,0,'IDLE','ACTIVE'),         NULL, NUMAQ_KPONDESTAT,          0, 0, DECODE(LOCTYPE_KPONDESTAT, 0, NUMAQ_KPONDESTAT, 0),          DECODE(LOCTYPE_KPONDESTAT, 1, NUMAQ_KPONDESTAT, 0), 0,         0, 0,         0, 0,         DECODE(LOCTYPE_KPONDESTAT, 0, NUMAQ_KPONDESTAT, 0), 0,         0, DECODE(LOCTYPE_KPONDESTAT, 0, AQTIME_KPONDESTAT/1000000, 0),         0, DECODE(LOCTYPE_KPONDESTAT, 1, AQTIME_KPONDESTAT/1000000, 0),          DECODE(LOCTYPE_KPONDESTAT, 0, AQTIME_KPONDESTAT/1000000, 0), 0 ,         0, EMONLAT_KPONDESTAT,         0, 0 , REGINV_KPONDESTAT,          NULL, LASTERR_KPONDESTAT, LET_KPONDESTAT, CON_ID          FROM X$KPONDESTAT
+++GV$EMX_USAGE_STATS+++              select inst_id,        report_kexsvus,        count_kexsvus,        login_elapsed_time_kexsvus,        initreq_elapsed_time_kexsvus,        sql_elapsed_time_kexsvus,        send_elapsed_time_kexsvus,        elapsed_time_kexsvus,        last_req_time_kexsvus,        con_id   from X$KEXSVUS
+++GV$ENABLEDPRIVS+++                 select inst_id,-kzsprprv, con_id from x$kzspr
+++GV$ENCRYPTED_TABLESPACES+++        select INST_ID, TS#,                             decode(ALG, 0, 'NONE',                                       1, '3DES168',                                    2, 'AES128',                                     3, 'AES192',                                     4, 'AES256'),                        decode(ENCTS, 0, 'NO', 'YES'),                   ENCRYPTEDKEY,                                    MKID, BLKS_ENC, BLKS_DEC, CON_ID                 from X$KCBTEK where ENCTS <> 0 and               DROPPEDTS = 0
+++GV$ENCRYPTION_KEYS+++              SELECT INST_ID, MKID, TAG, CREATION_TIME, ACTIVATION_TIME, CREATOR, CREATOR_ID, USER, USER_ID, decode(BITAND(DESCRIPTION,7), 0, 'UNDEFINED',  1, 'TDE',  3, 'TDE IN PDB',     'UNDEFINED'), decode(BITAND(DESCRIPTION, 24), 0, 'UNDEFINED',   8, 'HSM',  16, 'SOFTWARE KEYSTORE',      'UNDEFINED'), decode(BITAND(FLAG,15), 0, 'UNDEFINED',  1, 'LOCAL',  2, 'IMPORTED',  4, 'IMPORTED BUT KEY METADATA CREATED LOCALLY',  8, 'UNKNOWN BUT KEY METADATA CREATED LOCALLY',     'UNDEFINED'), decode(BITAND(FLAG, 16), 0, 'NO', 16, 'YES',     'UNDEFINED'), CREATOR_DBNAME, CREATOR_DBID, CREATOR_INSTANCE_NAME, CREATOR_INSTANCE_NUMBER, CREATOR_INSTANCE_SERIAL, CREATOR_PDBNAME, CREATOR_PDBID, CREATOR_PDBUID, CREATOR_PDBGUID, ACTIVATING_DBNAME, ACTIVATING_DBID, ACTIVATING_INSTANCE_NAME, ACTIVATING_INSTANCE_NUMBER, ACTIVATING_INSTANCE_SERIAL, ACTIVATING_PDBNAME, ACTIVATING_PDBID, ACTIVATING_PDBUID, ACTIVATING_PDBGUID, CON_ID FROM X$KZCKMEK
+++GV$ENCRYPTION_WALLET+++            SELECT INST_ID, WRL_TYPE, WRL_PARAMETER, decode(BITAND(STATUS,255), 1, 'UNDEFINED',                                     2, 'CLOSED',                                     4, 'OPEN',                                     8, 'OPEN_NO_MASTER_KEY',                                     16, 'OPEN_UNKNOWN_MASTER_KEY_STATUS',                                     34, 'CLOSED',                                     36, 'OPEN',                                     40, 'OPEN_NO_MASTER_KEY',                                     48, 'OPEN_UNKNOWN_MASTER_KEY_STATUS',                                     64, 'NOT_AVAILABLE'), WALLET_TYPE, decode(BITAND(WALLET_ORDER,15), 2, 'SECONDARY', 1, 'PRIMARY',  0, 'SINGLE',  'UNDEFINED'), decode(BITAND(FBKPUP,15), 3, 'YES', 2, 'NO', 1, 'UNDEFINED'), CON_ID FROM X$KZEKMENCWAL
+++GV$ENQUEUE_LOCK+++                 select s.inst_id,l.addr,l.ksqlkadr,s.ksusenum,r.ksqrsidt,         r.ksqrsid1,r.ksqrsid2, l.ksqlkmod, l.ksqlkreq,l.ksqlkctim,l.ksqlklblk,        r.con_id  from x$ksqeq l,x$ksuse s,x$ksqrs r where l.ksqlkses=s.addr and  bitand(l.ksspaflg,1)!=0 and (l.ksqlkmod!=0 or l.ksqlkreq!=0) and  l.ksqlkres=r.addr
+++GV$ENQUEUE_STAT+++                 select inst_id, ksqsttyp, sum(ksqstreq), sum(ksqstwat), sum(ksqstsgt),           sum(ksqstfgt), sum(ksqstwtm), con_id    from X$KSQST group by inst_id, ksqsttyp, con_id having sum(ksqstreq) > 0
+++GV$ENQUEUE_STATISTICS+++           select st.inst_id, eqt.name, st.ksqsttyp, st.ksqstrsn,           st.ksqstreq, st.ksqstwat, st.ksqstsgt, st.ksqstfgt, st.ksqstwtm,           st.ksqstexpl, st.ksqstevidx, st.con_id    from X$KSQST st, X$KSQEQTYP eqt    where (st.inst_id = eqt.inst_id) and (st.ksqsttyp = eqt.resname) and          (st.indx > 0)
+++GV$EVENTMETRIC+++                  SELECT inst_id, begtime, endtime, intsize_csec,            wait#, wait_id, nsess_wait, time_waited, wait_count,            time_waited_fg, wait_count_fg, con_id          FROM   x$kewmevmv          WHERE flag1 = 1 AND GROUPID = 0
+++GV$EVENT_HISTOGRAM+++              select d.inst_id, d.indx, d.kslednam, s.kslsesmaxdur, s.kslsesval,  decode(s.kslsesval, 0, NULL, s.kslsestimestamp), s.con_id  from x$kslseshist s, x$ksled d  where s.kslsesenum = d.indx
+++GV$EVENT_HISTOGRAM_MICRO+++        select d.inst_id, d.indx, d.kslednam, s.kslsesfmaxdur, s.kslsesmaxdur,  s.kslsesval, decode(s.kslsesval, 0, NULL, s.kslsestimestamp), s.con_id  from x$kslseshist_micro s, x$ksled d  where s.kslsesenum = d.indx
+++GV$EVENT_NAME+++                   select inst_id, indx, ksledhash, kslednam, ksledp1, ksledp2, ksledp3,  ksledclassid, ksledclass#, ksledclass, ksleddsp, con_id  from x$ksled
+++GV$EXECUTION+++                    select inst_id, pid, val0, func, decode(id,1,'call',2,'return',3,'longjmp'), nvals,  val2, val3, seqh, seql, con_id from x$kstex where op=10
+++GV$FALSE_PING+++                   WITH p AS (SELECT bh.inst_id,                    bh.file#,                    bh.block#,                    bh.class#,                    bh.status,                    bh.xnc,                    bh.forced_reads,                    bh.forced_writes,                    ob.name,                    ob.subname partition_name,                    decode (ob.type#,  1, 'INDEX',                                       2, 'TABLE',                                       3, 'CLUSTER',                                       4, 'VIEW',                                       5, 'SYNONYM',                                       6, 'SEQUENCE',                                       7, 'PROCEDURE',                                       8,  'FUNCTION',                                       9, 'PACKAGE',                                      10, 'NON-EXISTENT',                                      11, 'PACKAGE BODY',                                      12, 'TRIGGER',                                      13, 'TYPE',                                      14, 'TYPE BODY',                                      19, 'TABLE PARTITION',                                      20, 'INDEX PARTITION',                                      21, 'LOB',                                      22, 'LIBRARY',                                      28, 'JAVA SOURCE',                                      29, 'JAVA CLASS',                                      30, 'JAVA RESOURCE',                                      56, 'JAVA DATA',                                      'UNKNOWN') kind,                    ob.owner#,                    lock_element_addr,                    lock_element_name,                    bh.con_id             FROM   (SELECT b.inst_id, file#, dbablk block#, class class#,                            decode(state,0,'free',1,'xcur',2,'scur',3,'cr',                                   4,'read',5,'mrec',6,'irec',7,'write',8,'pi',                                   9,'memory',10,'mwrite',11,'donated',                                  12,'protected', 13,'securefile', 14,'siop',                                  15,'recckpt', 16, 'flashfree',                                  17, 'flashcur', 18, 'flashna') status,                            0 xnc, 0 forced_reads, 0 forced_writes,                            b.le_addr lock_element_addr,                            le_id1 lock_element_name, obj objd, b.con_id                     FROM x$bh b, x$le le                     WHERE b.le_addr = le.le_addr (+)) bh, obj$ ob             WHERE  (bh.objd = ob.dataobj#) AND                    (bh.forced_reads + bh.forced_writes) > 0             UNION ALL             SELECT bh2.inst_id,                    bh2.file#,                    bh2.block#,                    bh2.class#,                    bh2.status,                    bh2.xnc,                    bh2.forced_reads,                    bh2.forced_writes,                    un.name,                    NULL             partition_name,                    'UNDO'           kind,                    un.user#         owner#,                    lock_element_addr,                    lock_element_name,                    bh2.con_id             FROM   (SELECT b.inst_id, file#, dbablk block#, class class#,                            decode(state,0,'free',1,'xcur',2,'scur',3,'cr',                                   4,'read',5,'mrec',6,'irec',7,'write',8,'pi',                                   9,'memory',10,'mwrite',11,'donated',                                  12,'protected', 13,'securefile', 14,'siop',                                  15,'recckpt', 16, 'flashfree',                                  17, 'flashcur', 18, 'flashna') status,                            0 xnc, 0 forced_reads, 0 forced_writes,                            b.le_addr lock_element_addr,                            le_id1 lock_element_name, obj objd, b.con_id                     FROM x$bh b, x$le le                     WHERE b.le_addr = le.le_addr (+)) bh2, undo$ un             WHERE  (b
+++GV$FAST_START_SERVERS+++           SELECT inst_id, state, wdone, pid, xid, con_id from x$ktprxrs
+++GV$FAST_START_TRANSACTIONS+++      SELECT inst_id, usn, slt, seq, state, wkd, twk, pid, etime, parentusn, parentslt, parentseq, xid, pxid, svrs, con_id from x$ktprxrt UNION ALL SELECT inst_id, usn, slt, seq, state, twk-wkl, twk, NULL, etime, NULL, NULL, NULL, xid, NULL, svrs, con_id from x$kturhist
+++GV$FILEMETRIC+++                   SELECT inst_id, begtime, endtime, intsize_csec,            fileid, creationtime, avrdtime, avwrtime,            phyread, phywrite, phybkrd, phybkwr, con_id          FROM   x$kewmflmv          WHERE flag1 = 1
+++GV$FILEMETRIC_HISTORY+++           SELECT inst_id, begtime, endtime, intsize_csec,            fileid, creationtime, avrdtime, avwrtime,            phyread, phywrite, phybkrd, phybkwr, con_id          FROM   x$kewmflmv
+++GV$FILESPACE_USAGE+++              SELECT inst_id, KTTEFINFOTSN, KTTEFINFOFNO, KTTEFINFOUSP,          KTTEFINFOSIZE, KTTEFINFOMSIZE, KTTEFINFOSCNB,          KTTEFINFOSCNW, KTTEFINFOFLAG, CON_ID          FROM   X$KTTEFINFO
+++GV$FILESTAT+++                     select k.inst_id, k.kcfiofno,k.kcfiopyr,k.kcfiopyw,k.kcfiopbr,k.kcfiofbr, k.kcfiopbw,k.kcfiosbr,round(k.kcfioprt / 10000),round(k.kcfiopwt / 10000), round(k.kcfiosbt / 10000),round(k.kcfioavg / 10000), round(k.kcfiolst / 10000),round(k.kcfiomin / 10000), round(k.kcfiormx / 10000),round(k.kcfiowmx / 10000), k.con_id  from x$kcfio k,x$kccfe fe, x$kccfn fn where fe.fedup <> 0 and fe.fenum = fn.fnfno and fn.fnfno=k.kcfiofno and fn.fntyp = 4 and bitand(fn.fnflg, 4) != 4 and fn.fnnam is not null
+++GV$FILE_CACHE_TRANSFER+++          select x.inst_id, kcfiofno,                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x.con_id   from x$kcfio x, x$kccfe fe                    where x.kcfiofno = fe.fenum
+++GV$FILE_HISTOGRAM+++               select k.inst_id, k.kcfiofno,k.kcfiomaxdur,k.kcfioval, k.con_id from x$kcfiohist k,x$kccfe fe, x$kccfn fn where fe.fedup <> 0 and fe.fenum = fn.fnfno and fn.fnfno=k.kcfiofno and fn.fntyp = 4 and bitand(fn.fnflg, 4) != 4 and fn.fnnam is not null
+++GV$FILE_OPTIMIZED_HISTOGRAM+++     select k.inst_id, k.kcfiofno,k.kcfiomaxdur,k.kcfioval, k.con_id from x$kcfiofchist k,x$kccfe f where f.fedup <> 0 and  f.fenum=k.kcfiofno
+++GV$FILE_PING+++                    select x.inst_id, kcfiofno,              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x.con_id    from x$kcfio x, x$kccfe fe               where x.kcfiofno = fe.fenum
+++GV$FIXED_TABLE+++                  select inst_id,kqftanam, kqftaobj, 'TABLE', indx, con_id from x$kqfta union all select inst_id,kqfvinam, kqfviobj, 'VIEW', 65537, con_id from x$kqfvi union all select inst_id,kqfdtnam, kqfdtobj, 'TABLE', 65537, con_id from x$kqfdt
+++GV$FIXED_VIEW_DEFINITION+++        select i.inst_id,kqfvinam,kqftpsel, i.con_id   from x$kqfvi i, x$kqfvt t where i.indx = t.indx
+++GV$FLASHBACK_DATABASE_LOG+++       select inst_id,           to_number(fblogscn),           to_date(fblogtim, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),           fblogretn,          totsize, to_number(fblogesiz), con_id           from x$krfblog,           ( select sum(flebsz * flenblks) totsize             from x$kccfle where fledup != 0 )
+++GV$FLASHBACK_DATABASE_LOGFILE+++   select /*+ no_merge(fn) */                  fle.inst_id, fn.fnnam,                  fle.flelno, fle.flethr, fle.fleseq,                  fle.flenblks * fle.flebsz,                  to_number(fle.flelscn),                  to_date(fle.fleltim, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),                  decode(bitand(fle.fleflg,7), 1, 'RESERVED',                                               2, 'FREE',                                               4, 'TO DELETE',                                                  'NORMAL'),                  fle.con_id           from (select fnnam, fnnum from x$kccfn where fntyp = 24) fn,                 x$kccfle fle           where (fn.fnnum = fle.flefnh)             and (fle.fledup != 0)
+++GV$FLASHBACK_DATABASE_STAT+++      select inst_id,  to_date(btime, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  to_date(etime, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  fbw*512, dbw*512, redow*512, to_number(fbsz), con_id  from x$krfgstat
+++GV$FLASHFILESTAT+++                select k.inst_id, k.kcbfciofno, k.kcbfcioname, k.kcbfciosize, k.kcbfciosta,  k.kcbfcioreads, k.kcbfciotime,  k.con_id from x$kcbfcio k
+++GV$FOREIGN_ARCHIVED_LOG+++         select inst_id,rlrid,rlstm,rlnam,rldst,rlthp,rlseq,to_number(rlrls),to_date(rlrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(rlxlc),to_number(rllos),to_date(rllot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(rlnxs),to_date(rlnxt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),rlbct,rlbsz,decode(bitand(rlflg, 16+32+64+128+256),    16, 'ARCH',    32, 'FGRD',    64, 'RMAN',    128,'SRMN',    256,'LGWR',        'UNKNOWN'),decode(bitand(rlflg, 4),    4,  'RFS',    decode(bitand(rlflg, 16+32+64+128+256),    16, 'ARCH',    32, 'FGRD',    64, 'RMAN',    128,'SRMN',    256,'LGWR',        'UNKNOWN')),decode(bitand(rlflg, 2),0,'NO','YES'),decode(bitand(rlflg, 1024),0,'NO','YES'),decode(bitand(rlflg, 1),0,'NO','YES'),decode(bitand(rlflg, 1+2048+4096),    0,   'A',    1,   'D',    2048,'X',    4096,'U',         '?'),to_date(rltsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(rlflg,8192),0,'NO','YES'),decode(bitand(rlflg,16384),0,'NO','YES'), decode(bitand(rlflg,32768),0,'NO','YES'), rltoa,decode(bitand(rlfl2,64),0,'NO','YES'),  decode(bitand(rlfl2,128),0,'NO','YES'), decode(bitand(rlflg,512),0,'NO','YES'),  decode(bitand(rlfl2,256+512+1024),       256, 'TERMINAL',       512, 'ACTIVATION',      1024, 'RESETLOGS',      decode(bitand(rlflg,32768),0,'','SWITCHOVER')), rldbi, con_id from x$kccrl
+++GV$FS_FAILOVER_HISTOGRAM+++        select INST_ID,WAIT_TIME,WAIT_COUNT,decode(WAIT_COUNT, 0, NULL, LAST_UPDATE_TIME), CON_ID from x$rfahist
+++GV$FS_FAILOVER_STATS+++            select INST_ID, FTIME, REASON, CON_ID from x$rfafo
+++GV$FS_OBSERVER_HISTOGRAM+++        select INST_ID,WAIT_TIME,WAIT_COUNT,decode(WAIT_COUNT, 0, NULL, LAST_UPDATE_TIME), CON_ID from x$rfahist
+++GV$GCSHVMASTER_INFO+++             select inst_id,  KJDRPCMHVID, KJDRPCMHVCMAS, KJDRPCMHVPMAS, KJDRPCMHVRMCNT, CON_ID  from x$kjdrpcmhv
+++GV$GCSPFMASTER_INFO+++             select INST_ID,  KJDRPCMPFID, KJDRPCMPOID,  decode(KJDRPCMPTYPE, 0, 'Affinity', 1, 'Read mostly'),  KJDRPCMPFCMAS, KJDRPCMPFPMAS, KJDRPCMPFRMCNT, CON_ID,  KJDRPCMHVRMTOTAL, KJDRPCMHVRMREMOTE, KJDRPCMHVREMOTECOST,  KJDRPCMHVRMBNFT,  KJDRPCMHVRMTOTALCR, KJDRPCMHVRMREMOTECR, KJDRPCMHVREMOTECRCOST,  KJDRPCMHVRMBNFTCR  from x$kjdrpcmpf
+++GV$GC_ELEMENT+++                   select inst_id, le_addr, indx, le_id2,          le_id1, le_mode, le_blks, le_rls, le_acq,          le_write, le_recovery, le_local, le_flags, con_id          from x$le
+++GV$GC_ELEMENTS_WITH_COLLISIONS+++  select USERENV('Instance'), lock_element_addr, con_id          from v$bh where (forced_writes + forced_reads) > 10              group by lock_element_addr, con_id          having count(*) >= 2
+++GV$GES_BLOCKING_ENQUEUE+++         select USERENV('Instance'), HANDLE, GRANT_LEVEL, REQUEST_LEVEL,          RESOURCE_NAME1, RESOURCE_NAME2, PID, TRANSACTION_ID0,          TRANSACTION_ID1, GROUP_ID, OPEN_OPT_DEADLOCK, OPEN_OPT_PERSISTENT,          OPEN_OPT_PROCESS_OWNED, OPEN_OPT_NO_XID, CONVERT_OPT_GETVALUE,          CONVERT_OPT_PUTVALUE, CONVERT_OPT_NOVALUE,          CONVERT_OPT_DUBVALUE, CONVERT_OPT_NOQUEUE,          CONVERT_OPT_EXPRESS, CONVERT_OPT_NODEADLOCKWAIT,          CONVERT_OPT_NODEADLOCKBLOCK, WHICH_QUEUE, STATE,          AST_EVENT0, OWNER_NODE, BLOCKED, BLOCKER, CON_ID          from V$GES_ENQUEUE          where (REQUEST_LEVEL != 'KJUSERNL') and          (BLOCKED = 1 or BLOCKER = 1)
+++GV$GES_DEADLOCKS+++                select inst_id, did, dd_time, number_of_sessions,          master_instance, victim_instance, victim_pid, victim_resnm,         victim_sid, victim_serial#, victim_req_level, con_id          from x$kjdddeadlocks
+++GV$GES_DEADLOCK_SESSIONS+++        select inst_id, did, sid, serial#, instance, blocker_sid,          blocker_serial#, blocker_instance, osuser, app_name,          blocked_res_name, request_level, blocker_res_name, grant_level,          con_id from x$kjdddeadlockses
+++GV$GES_ENQUEUE+++                  select inst_id, kjilkftlkp, kjilkftgl, kjilkftrl, kjilkftrn1, kjilkftrn2, kjilkftpid, kjilkftxid0, kjilkftxid1, kjilkftgid, kjilkftoodd, kjilkftoopt, kjilkftoopo, kjilkftoonxid, kjilkftcogv, kjilkftcopv, kjilkftconv, kjilkftcodv, kjilkftconq, kjilkftcoep, kjilkftconddw, kjilkftconddb, kjilkftwq, kjilkftls, kjilkftaste0, kjilkfton, kjilkftblked, kjilkftblker, con_id from x$kjilkft union all select inst_id, kjbllockp, kjblgrant, kjblrequest, kjblname, kjblname2, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, kjblqueue, kjbllockst, 0, kjblowner, kjblblocked, kjblblocker, con_id from x$kjbl
+++GV$GG_APPLY_COORDINATOR+++         select x.inst_id,x.sid_knst,x.serial_knst, x.applynum_knstacr, x.applyname_knstacr,decode(x.state_knstacr,0,'INITIALIZING',        1,'APPLYING',2,'SHUTTING DOWN CLEANLY',3,'ABORTING',4,'IDLE'),x.total_applied_knstacr,decode(bitand(flag_knstacr, 1),        0, total_waitdeps_knstacr,        1, (select sum(total_waitdeps_knstasl) from x$knstasl            where applynum_knstacr = applynum_knstasl)       ), x.total_waitcommits_knstacr,total_admin_knstacr,x.total_assigned_knstacr,x.total_received_knstacr, x.total_ignored_knstacr,x.total_rollbacks_knstacr, x.total_errors_knstacr, x.unassigned_complete_knstacr,x.lwm_time_knstacr, x.lwm_msg_num_knstacr,x.lwm_msg_time_knstacr,x.hwm_time_knstacr, x.hwm_msg_num_knstacr, x.hwm_msg_time_knstacr,x.startup_time_knstacr, x.elapsed_schedule_time_knstacr, x.elapsed_idle_time_knstacr, cast(utl_raw.cast_to_varchar2(x.lwm_position_knstacr) as varchar2(64)), cast(utl_raw.cast_to_varchar2(x.hwm_position_knstacr) as varchar2(64)), x.processed_msg_num_knstacr, x.con_id, x.active_server_cnt_knstacr from x$knstacr x  where x.type_knst=1    and bitand(x.purpose_flag_knstacr, 8) = 8    and exists (select 1 from v$session s                   where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$GG_APPLY_READER+++              select x.inst_id,x.sid_knst,x.serial_knst,x.applynum_knstasl, x.applyname_knstasl, decode(hs.state_knstasl,0,'IDLE; ',8,'DEQUEUE MESSAGES; ',        10,'SCHEDULE MESSAGES; ',        15,'INITIALIZING; ',16,'SPILLING; ',        17,'PAUSED - WAITING FOR DDL TO COMPLETE; ',        20, 'GENERATE DEPENDENCY HASH VALUES; ') || decode(x.state_knstasl,0,'IDLE',8,'DEQUEUE MESSAGES',10,'SCHEDULE MESSAGES',        15,'INITIALIZING',16,'SPILLING',        17,'PAUSED - WAITING FOR DDL TO COMPLETE'), x.total_msg_knstasl, x.total_spill_msg_knstasl, x.last_rcv_time_knstasl, x.last_rcv_msg_time_knstasl, x.sga_used_knstasl, x.elapsed_dequeue_time_knstasl, x.elapsed_schedule_time_knstasl, x.elapsed_spill_time_knstasl, x.spill_lwm_scn_knstasl, x.proxy_sid_knstasl, x.proxy_serial_knstasl, x.proxy_spid_knstasl, (SELECT sesstat.ksusestv         FROM   x$ksusd stat, x$ksusesta sesstat, x$ksuse sess WHERE  x.proxy_sid_knstasl=sesstat.ksusenum    AND  x.proxy_sid_knstasl=sess.indx    AND  x.proxy_serial_knstasl=sess.ksuseser    AND  bitand(sess.ksspaflg,1)!=0    AND  bitand(sess.ksuseflg,1)!=0    AND  sesstat.ksusestn = stat.indx    AND  bitand(sesstat.ksspaflg,1)!=0    AND  bitand(sesstat.ksuseflg,1)!=0    AND  sesstat.ksusestn<(select ksusgstl from x$ksusgif)   AND  stat.ksusdnam = 'bytes received via SQL*Net from client'),cast(utl_raw.cast_to_varchar2(x.last_rcv_pos_knstasl) as varchar2(64)), cast(utl_raw.cast_to_varchar2(x.spill_lwm_pos_knstasl) as varchar2(64)), x.oldest_xidtxt_knstasl, x.num_dep_lcrs_knstasl, x.num_wmdeps_knstasl, x.num_in_memory_lcrs_knstasl, x.sga_allocated_knstasl, x.con_id from (select * from x$knstasl where type_knst=7       and bitand(flag_knstasl, 8) = 8       and exists (select 1 from v$session s                   where s.sid=sid_knst and s.serial#=serial_knst)) x,   (select * from x$knstasl where type_knst = 14     and bitand(flag_knstasl, 8) = 8    and exists (select 1 from v$session s                where s.sid=sid_knst and s.serial#=serial_knst)) hs where x.proxy_sid_knstasl = hs.sid_knst(+) and       x.proxy_serial_knstasl = hs.serial_knst(+) and       x.inst_id = hs.inst_id(+)
+++GV$GG_APPLY_RECEIVER+++            select x.inst_id, x.sid_knst, x.serial_knst, x.apply_name_knstanr,                x.startup_time_knstanr, x.src_dbname_knstanr,                x.acknowlegement_knstanr, x.last_rcv_msg_knstanr,                x.total_rcv_msgs_knstanr, x.available_msgs_knstanr,                decode(x.state_knstanr,                       0, 'Initializing',                       1, 'Sending unapplied txns',                       2, 'Waiting for message from client',                       3, 'Receiving LCRs',                       4, 'Evaluating rules',                       5, 'Enqueueing LCRS',                       6, 'Waiting for memory',                       7, 'Waiting for apply to read',                       8, 'Waiting for message from Replicat',                       9, 'Waiting for Replicat flush request to complete',                       10, 'Waiting for Replicat commit to complete', null),                cast(utl_raw.cast_to_varchar2(x.last_rcv_pos_knstanr) as                varchar2(64)),                cast(utl_raw.cast_to_varchar2(x.acknowlegement_pos_knstanr) as                varchar2(64)),                x.con_id          from   x$knstanr x, x$knstacr y          where  x.inst_id=y.inst_id and x.con_id=y.con_id and                 x.apply_name_knstanr=y.applyname_knstacr and                 y.type_knst=1 and bitand(y.purpose_flag_knstacr, 8)=8                 and exists (select 1 from v$session s                             where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$GG_APPLY_SERVER+++              select inst_id,sid_knst,serial_knst,applynum_knstasl, applyname_knstasl,slavid_knstasl,decode(state_knstasl,0,'IDLE',1,'POLL SHUTDOWN',2,'RECORD LOW-WATERMARK',3,'ADD PARTITION',4,'DROP PARTITION',5,'EXECUTE TRANSACTION',6,'WAIT COMMIT',7,'WAIT DEPENDENCY',8,'GET TRANSACTIONS',9,'WAIT FOR NEXT CHUNK',12,'ROLLBACK TRANSACTION',13,'TRANSACTION CLEANUP',14,'REQUEST UA SESSION',15,'INITIALIZING',16,'SPILL',18,'WAIT FOR CLIENT',19,'INACTIVE'), xid_usn_knstasl,xid_slt_knstasl,xid_sqn_knstasl,cscn_knstasl,depxid_usn_knstasl,depxid_slt_knstasl,depxid_sqn_knstasl,depcscn_knstasl,msg_num_knstasl,total_assigned_knstasl,total_admin_knstasl,total_rollbacks_knstasl,total_msg_knstasl, last_apply_time_knstasl, elapsed_apply_time_knstasl,cast(utl_raw.cast_to_varchar2(commit_position_knstasl) as varchar2(64)), cast(utl_raw.cast_to_varchar2(dep_commit_position_knstasl) as varchar2(64)), cast(utl_raw.cast_to_varchar2(last_apply_pos_knstasl) as varchar2(64)),  nosxid_knstasl, depnosxid_knstasl, con_id, total_lcrs_retried_knstasl, lcr_retry_iter_knstasl, total_txns_retried_knstasl, txn_retry_iter_knstasl, total_txns_discarded_knstasl  from x$knstasl x where type_knst=2 and bitand(flag_knstasl, 8) = 8  and (x.sid_knst = 0 or exists (select 1 from v$session s where s.sid=x.sid_knst and s.serial#=x.serial_knst))
+++GV$GLOBALCONTEXT+++                select inst_id, namespace, attribute, value,           username,clientidentifier, con_id           from x$globalcontext           where upper(namespace) not like 'SYS_%'
+++GV$GLOBAL_BLOCKED_LOCKS+++         select USERENV('instance'), addr, kaddr, sid, type, id1, id2, lmode,request,ctime, con_id from v$lock l where exists (select * from v$dlm_locks d  where substr(d.resource_name2,1,instr(d.resource_name2, ',',1,1)-1) = id1 and substr(d.resource_name2,instr(d.resource_name2,',',1,1)+1, instr(d.resource_name2 , ',',1,2)-instr(d.resource_name2, ',',1,1)-1) = id2 and substr(d.resource_name2,instr(d.resource_name2, ',',-1,1)+1,2) = type)
+++GV$GLOBAL_TRANSACTION+++           select inst_id,                                                               K2GTIFMT, K2GTITID_EXT, K2GTIBID, K2GTECNT, K2GTERCT, K2GTDPCT,               decode (K2GTDFLG, 0, 'ACTIVE', 1, 'COLLECTING', 2, 'FINALIZED',                                 4, 'FAILED', 8, 'RECOVERING', 16, 'UNASSOCIATED',                             32, 'FORGOTTEN', 64, 'READY FOR RECOVERY',                                    128, 'NO-READONLY FAILED', 256, 'SIBLING INFO WRITTEN',                       512,      '[ORACLE COORDINATED]ACTIVE',                                       512+1,    '[ORACLE COORDINATED]COLLECTING',                                   512+2,    '[ORACLE COORDINATED]FINALIZED',                                    512+4,    '[ORACLE COORDINATED]FAILED',                                       512+8,    '[ORACLE COORDINATED]RECOVERING',                                   512+16,   '[ORACLE COORDINATED]UNASSOCIATED',                                 512+32,   '[ORACLE COORDINATED]FORGOTTEN',                                    512+64,   '[ORACLE COORDINATED]READY FOR RECOVERY',                           512+128,  '[ORACLE COORDINATED]NO-READONLY FAILED',                           1024,     '[MULTINODE]ACTIVE',                                                1024+1,   '[MULTINODE]COLLECTING',                                            1024+2,   '[MULTINODE]FINALIZED',                                             1024+4,   '[MULTINODE]FAILED',                                                1024+8,   '[MULTINODE]RECOVERING',                                            1024+16,  '[MULTINODE]UNASSOCIATED',                                          1024+32,  '[MULTINODE]FORGOTTEN',                                             1024+64,  '[MULTINODE]READY FOR RECOVERY',                                    1024+128, '[MULTINODE]NO-READONLY FAILED',                                    1024+256, '[MULTINODE]SIBLING INFO WRITTEN',                                  'COMBINATION'), K2GTDFLG,                                   decode (K2GTETYP, 0, 'FREE', 1, 'LOOSELY COUPLED', 2, 'TIGHTLY COUPLED'),     con_id from X$K2GTE2
+++GV$GOLDENGATE_CAPABILITIES+++      select  inst_id, decode(featureIndex_knstoggc, 1, 'DBENCRYPTION', 2, 'DBLOGREADER', 3, 'TRIGGERSUPPRESSION', 4, 'TRANSIENTDUPLICATE', 5, 'DDLTRIGGEROPTIMIZATION', 6, 'GGSESSION', 7, 'DELETECASCADEHINT', 8, 'SUPPLEMENTALLOG'), count_knstoggc, timestamp_knstoggc, con_id from x$knstoggc
+++GV$GOLDENGATE_CAPTURE+++           SELECT x.inst_id, x.sid_knst, x.serial_knst, x.capnum_knstcap,         x.capname_knstcap, x.logminer_id_knstcap,         x.startup_time_knstcap,        case when (x.state_knstcap = 10 and                    d.loaded = 'ACTIVE')             then d.current_state || ' ' || d.progress              when (x.state_knstcap = 18)              then 'WAIT FOR ' || x.subscriber_num                               || ' SUBSCRIBER(S) INITIALIZING'              else DECODE(x.state_knstcap,                     0,  'INITIALIZING',    1,'CAPTURING CHANGES',                    2,  'EVALUATING RULE', 3,'ENQUEUING MESSAGE',                     4,  'SHUTTING DOWN',   5,'ABORTING',                     6,  'CREATING LCR',                     7,  DECODE(x.missing_logfile_info_knstcap,                                NULL, 'WAITING FOR DICTIONARY REDO',                                'WAITING FOR DICTIONARY REDO: ' ||                                x.missing_logfile_info_knstcap),                    8,  DECODE(x.missing_logfile_info_knstcap,                                NULL, 'WAITING FOR REDO',                                'WAITING FOR REDO: ' ||                                x.missing_logfile_info_knstcap),                    9,'PAUSED FOR FLOW CONTROL',                     10, 'DICTIONARY INITIALIZATION',                    11, 'WAITING FOR APPLY TO BE ENABLED',                     12, 'CONNECTING TO APPLY DATABASE',                     13, 'WAITING FOR PROPAGATION TO BE ENABLED',                     15, 'WAITING FOR A SUBSCRIBER TO BE ADDED',                     16, 'WAITING FOR BUFFERED QUEUE TO SHRINK',                     17, 'SUSPENDED FOR AUTO SPLIT/MERGE',                     19, 'WAITING FOR INACTIVE DEQUEUERS',                     20, 'WAITING FOR TRANSACTION',                     21, 'WAITING FOR CLIENT REQUESTS')         end         ||         DECODE(cs.state_knstcaps,         0,  ';INITIALIZING',         1, ';INITIALIZING RULE EVALUATION CONTEXT', 2, ';BROWSING LCR',         3, ';EVALUATING RULES', 4, ';DEQUEUING LCR', 5, ';SENDING LCR',         14, ';WAITING FOR CAPTURE TO TERMINATE',         15, ';WAITING FOR A SUBSCRIBER TO BE ADDED',         16, ';SUSPENDED DUE TO A DROPPED SUBSCRIBER',         17, ';SUSPENDED FOR AUTO SPLIT/MERGE',         18, ';WAITING ON EMPTY QUEUE', 19, ';WAITING FOR CLIENT',         20, ';WAITING FOR CAPTURE TO INITIALIZE',         21, ';WAITING TO ATTACH TO CAPTURE'),          m.msgs_filtered, m.msgs_kept, m.msgs_total, x.total_captured_knstcap,        x.recent_time_knstcap, x.recent_msg_num_knstcap,        x.recent_msg_time_knstcap, x.total_messages_created_knstcap,        x.total_full_evaluations_knstcap, x.total_msg_enq_knstcap,        x.enqueue_time_knstcap, x.enqueue_msg_num_knstcap,        x.enqueue_msg_time_knstcap,        DECODE(bitand(x.flags_knstcap, 1),               0, upstream.next_scn,               1, DECODE(bitand(x.flags_knstcap, 8),                         0, downstream.next_scn,                            downstream_real.next_scn)),         DECODE(bitand(x.flags_knstcap, 1),               0, upstream.next_time,               1, DECODE(bitand(x.flags_knstcap, 8),                         0, downstream.next_time,                            downstream_real.next_time)),                    x.elapsed_capture_time_knstcap, x.elapsed_rule_time_knstcap,        x.elapsed_enqueue_time_knstcap, x.elapsed_lcr_time_knstcap,         x.elapsed_wait_time_knstcap, x.elapsed_pause_time_knstcap,         x.state_changed_time_knstcap,         x.sga_used_knstcap,         x.sga_allocated_knstcap,        brm.value, srs.value,          x.con_id, x.spid_knstcap, x.extractname_knstcap,          DECODE(bitand(x.flags_knstcap, 64),                64, x.sid_knst, cs.sid_knst),        DECODE(bitand(x.flags_knstcap, 64),                64, x.serial_knst, cs.serial_knst),         cs.spid_knstcaps,         DECODE(bitand(x.flags_knstcap, 64),                64, x.apply_messages_sent_knstcap,                    cs.apply_messag
+++GV$GOLDENGATE_MESSAGE_TRACKING+++  SELECT inst_id, tracking_label_knstmt, tag_knstmt, component_name_knstmt,         component_type_knstmt, action_knstmt, action_details_knstmt,         timestamp_knstmt, message_create_time_knstmt, message_number_knstmt,         tracking_id_knstmt, source_database_name_knstmt, object_owner_knstmt,         object_name_knstmt, xid_knstmt, command_type_knstmt,         cast(utl_raw.cast_to_varchar2(message_position_knstmt)         as varchar2(64)), con_id  FROM   x$knstmt   WHERE  procusectxid_knstmt = 2
+++GV$GOLDENGATE_TABLE_STATS+++       SELECT inst_id, svrnm_knstxsts, slaveid_knstxsts, old_sname_knstxsts,         old_oname_knstxsts, new_sname_knstxsts, new_oname_knstxsts,         last_update_knstxsts, inscnt_knstxsts,         updcnt_knstxsts, delcnt_knstxsts, inscolsn_knstxsts,         updcolsn_knstxsts, delcolsn_knstxsts, discrdcnt_knstxsts,         ignrcnt_knstxsts, waitdepcnt_knstxsts, con_id, cdrinsre_knstxsts,         cdrupdre_knstxsts, cdrupdrm_knstxsts, cdrdelre_knstxsts,         cdrdelrm_knstxsts,         (cdrinsre_knstxsts + cdrupdre_knstxsts +          cdrupdrm_knstxsts + cdrdelre_knstxsts + cdrdelrm_knstxsts),         cdrresfail_knstxsts, lobcnt_knstxsts  FROM   x$knstxsts   WHERE  procusectxid_knstxsts = 2
+++GV$GOLDENGATE_TRANSACTION+++       SELECT inst_id, strmname_knsttxn, type_knsttxn,        xidusn_knsttxn, xidslt_knsttxn, xidsqn_knsttxn,         batch_xidusn_knsttxn, batch_xidslt_knsttxn, batch_xidsqn_knsttxn,         msg_count_knsttxn, actual_msg_count_knsttxn,         first_msg_time_knsttxn, first_msg_num_knsttxn,         last_msg_time_knsttxn,  last_msg_num_knsttxn,         cast(utl_raw.cast_to_varchar2(first_msg_pos_knsttxn) as varchar2(64)),        cast(utl_raw.cast_to_varchar2(last_msg_pos_knsttxn) as varchar2(64)),        nosxid_knsttxn,         con_id                                  FROM   x$knsttxn               WHERE procusectxid_knsttxn = 2
+++GV$HANG_STATISTICS+++              select inst_id, indx, kjznhngstatsdesc, kjznhngstatsval, con_id from x$kjznhngstats
+++GV$HEAT_MAP_SEGMENT+++             select i.INST_ID, i.object_name, i.subobject_name, i.obj#,          i.dataobj#, i.ts#, sysdate,          decode(i.segment_write, 0, 'NO', 'YES'),          decode(i.segment_read, 0, 'NO', 'YES'),          decode(i.full_scan, 0, 'NO', 'YES'),          decode(i.lookup_scan, 0, 'NO', 'YES'),          i.CON_ID          from X$HEATMAPSEGMENT1 i
+++GV$HM_CHECK+++                     select inst_id,       id,       name,       name_nls,       clsid,       decode(clsid, 1, 'GENERIC',                      2, 'PERSISTENT_DATA',                      3, 'ASM',                      'UNKNOWN'),        flags,       decode(bitand(flags,1), 0, 'N', 'Y'),        decode(bitand(flags,2), 0, 'N', 'Y'),        description,        con_id from  x$dbkh_check where bitand(flags,64) = 0
+++GV$HM_CHECK_PARAM+++               select inst_id,       id,       name,       check_id,       decode(type, 0, 'DBKH_PARAM_UB4',                     1, 'DBKH_PARAM_UB8',                     2, 'DBKH_PARAM_TEXT',                     3, 'DBKH_PARAM_DATE',                     4, 'DBKH_PARAM_UB4_LIST',                     5, 'DBKH_PARAM_UB8_LIST',                     6, 'DBKH_PARAM_TEXT_LIST',                     7, 'DBKH_PARAM_DATE_LIST',                    'UNKNOWN'),        default_value,       flags,       description,        con_id from  x$dbkh_check_param
+++GV$HM_FINDING+++                   select inst_id,       id,       run_id,       name,       pid,       cid_count,       clsname,       cast(ctime as timestamp),       cast(mtime as timestamp),       decode(priority, 0, 'CRITICAL',                         1, 'HIGH',                         2, 'LOW',                         'UNKNOWN'),       decode(status, 0, 'OPEN',                       1, 'CLOSED',                       2, 'UNDER-REPAIR',                       'UNKNOWN'),       decode(type, 0, 'INFORMATIONAL',                     1, 'FAILURE',                         'UNKNOWN'),      fdg_msg,       damage_msg,        con_id from x$dbkfdg
+++GV$HM_INFO+++                      select inst_id,       id,       decode(type, 0, 'RUN',                     1, 'RUN-RESUME',                     2, 'FINDING',                     3, 'RECOMMENDATION',                        'UNKNOWN'),        name,        value,        con_id from x$dbkinfo
+++GV$HM_RECOMMENDATION+++            select inst_id,       id,       fid,       runid,       name,       decode(type, 0, 'MANUAL',                     1, 'REPAIR',                       'UNKNOWN'),        rank,       cast(ctime as timestamp),       cast(etime as timestamp),       decode(status, 0, 'NOT RUN',                       1, 'RUNNING',                       2, 'SUCCESS',                       3, 'FAILED',                       'UNKNOWN'),       reco_msg,       script,        con_id from x$dbkreco
+++GV$HM_RUN+++                       select inst_id,       id,       name,       cname,       decode(runmode, 0, 'MANUAL',                        1, 'AUTO',                        2, 'REACTIVE',                        'UNKNOWN'),        timeout,       cast(stime as timestamp),       cast(rtime as timestamp),       cast(etime as timestamp),       cast(mtime as timestamp),       decode(status, 0, 'INITITAL',                       1, 'EXECUTING',                       2, 'INTERRUPTED',                       3, 'TIMEDOUT',                       4, 'CANCELLED',                       5, 'COMPLETED',                       6, 'ERROR',                       'UNKNOWN'),        incident,         num_incidents,         error_number,         problem_id,         con_id from x$dbkrun
+++GV$HS_AGENT+++                     select unique INST_ID, AGENT_ID, MACHINE, PROCESS, PROGRAM,          OSUSER, AGT_STARTTIME, AGENT_TYPE,          decode( AGENT_TYPE, 1, to_number(NULL),  FDS_CLASS_ID),          decode( AGENT_TYPE, 1, to_number(NULL),  FDS_INST_ID), con_id          from X$HS_SESSION
+++GV$HS_PARAMETER+++                 select A.INST_ID, HS_SESSION_ID, PARAMETER, VALUE, SOURCE,          ENV, A.CON_ID          from X$HS_SESSION A, X$HOFP B WHERE A.FDS_INST_ID = B.FDS_INST_ID
+++GV$HS_SESSION+++                   select INST_ID,          HS_SESSION_ID, AGENT_ID, SID,          decode( AGENT_TYPE, 1, NULL, DB_LINK),          decode( AGENT_TYPE, 1, to_number(NULL), DB_LINK_OWNER),          SES_STARTTIME, CON_ID          from X$HS_SESSION
+++GV$HVMASTER_INFO+++                select inst_id,  KJDRHVID, KJDRHVCMAS, KJDRHVPMAS, KJDRHVRMCNT, CON_ID  from x$kjdrhv
+++GV$IM_COLUMN_LEVEL+++              select INST_ID, OWNER, OBJN, TABLE_NAME, SEGMENT_COLUMN_ID,          COLUMN_NAME, INMEMORY_COMPRESSION, CON_ID from x$kdzcolcl
+++GV$IM_COL_CU+++                    select INST_ID, OBJD, TSN, HEAD_PIECE_ADDRESS, COLUMN_NUMBER, LENGTH,          ROW_LEN, TRANSFORMED_LEN, COMPRESSION_NUMBER,DICT_ENTRIES, MIN, MAX,          CON_ID from x$kdmimccol
+++GV$IM_HEADER+++                    select INST_ID, OBJD, TSN, IMCU_ADDR, ALLOCATED_LEN, USED_LEN,          IS_HEAD_PIECE, PREPOPULATED, REPOPULATED, TRICKLE_REPOPULATED,          ADDITIONAL_IMCU_PIECES, HEAD_PIECE_ADDRESS,          NEXT_PIECE_ADDRESS, COMPRESSION_LEVEL, NUM_DISK_EXTENTS,          NUM_TARGET_ROWS, NUM_TARGET_BLOCKS, HEADER_SIZE,          NUM_COLS, NUM_ROWS, BLK_CNT, CON_ID, TIME_TO_POPULATE, TIMESTAMP          from x$kdmimchead
+++GV$IM_SEGMENTS+++                  select           IMCS.INST_ID, NVL(UNAME, 'SYS'),          ONAME, SNAME,          decode(OBJTYPE, 2, 'TABLE', 19, 'TABLE PARTITION',          34, 'TABLE SUBPARTITION'), tsname,          imcs.membytes , imcs.bytes,          DATABYTES - BYTESINMEM,          case when (POPULATE_STATUS = 0) then 'COMPLETED'          when (POPULATE_STATUS = 1) then 'STARTED'          else NULL end,          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 34359738368), 34359738368,                 decode(bitand(imcs.segflag, 61572651155456),                 8796093022208, 'LOW',                 17592186044416, 'MEDIUM',                 35184372088832, 'HIGH',                 52776558133248, 'CRITICAL', 'NONE'),                 'NONE'),                 null),          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 8589934592), 8589934592,                        decode(bitand(imcs.segflag, 206158430208),                        68719476736,   'BY ROWID RANGE',                        137438953472,  'BY PARTITION',                        206158430208,  'BY SUBPARTITION',                        0,             'AUTO'), 'UNKNOWN'),null),          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 6597069766656),                        2199023255552, 'NO DUPLICATE',                        4398046511104, 'DUPLICATE',                        6597069766656, 'DUPLICATE ALL', 'UNKNOWN'),                 null),          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 841813590016),                               17179869184,  'NO MEMCOMPRESS',                              274877906944, 'FOR DML',                               292057776128, 'FOR QUERY LOW',                               549755813888, 'FOR QUERY HIGH',                               566935683072, 'FOR CAPACITY LOW',                               824633720832, 'FOR CAPACITY HIGH','UNKNOWN'),                 null), imcs.con_id          from x$imcsegments imcs          where imcs.segtype = 0
+++GV$IM_SEGMENTS_DETAIL+++           select INST_ID, TSN, RELFILE, BLOCK_ID, DATAOBJ, OBJ, BASEOBJ,          INC, SPARE_ID,          SEGTYPE, DISTDIM, MEMADDR, MEMEXTENTS, MEMBYTES,          EXTENTS, BLOCKS,DATABLOCKS,          BLOCKSINMEM, BYTES, CREATETIME, STATUS,          POPULATE_STATUS, CON_ID from x$imcsegments
+++GV$IM_SEG_EXT_MAP+++               select INST_ID, EXT_ADDR, EXT_LEN, START_DBA, SLEN, NUMA_ID,          FREENESS, TYPE,          STRP_CTRL_ID, STRP_BLK_ID, POOL_ID, CON_ID          from x$imcsegextmap
+++GV$IM_SMU_CHUNK+++                 select INST_ID, TSN, OBJD, OBJN,          STARTDBA, CHUNK_ID, CHUNK_ADDRESS, ULE_COUNT,          FIRST_LOG_UPDATE_ENTRY, FIRST_UPDATE_LOG_SCN,          CON_ID from x$ktmtxnchunk
+++GV$IM_SMU_HEAD+++                  select INST_ID, TSN, OBJD, OBJN,          STARTDBA, EXTENT_CNT, BLOCK_CNT, LOAD_SCN,          ITL_CNT, FIRST_LOG_UPDATE_ENTRY, TOTAL_ROWS,          INVALID_ROWS, INVALID_BLOCKS, CHUNKS,          CON_ID from x$ktmtxnhead
+++GV$IM_TBS_EXT_MAP+++               select INST_ID, START_DBA, END_DBA, DATAOBJ, IMCU_ADDR, LEN,          SMU_ADDR, CON_ID          from x$imctbsextmap
+++GV$IM_USER_SEGMENTS+++             select IMCS.INST_ID, ONAME, SNAME,           decode(OBJTYPE, 2, 'TABLE', 19, 'TABLE PARTITION',          34, 'TABLE SUBPARTITION'), tsname, imcs.membytes, imcs.bytes,          DATABYTES - BYTESINMEM,          case when (POPULATE_STATUS = 0) then 'COMPLETED'          when (POPULATE_STATUS = 1) then 'STARTED'          else NULL end,          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 34359738368), 34359738368,                 decode(bitand(imcs.segflag, 61572651155456),                 8796093022208, 'LOW',                 17592186044416, 'MEDIUM',                 35184372088832, 'HIGH',                 52776558133248, 'CRITICAL', 'NONE'),                 'NONE'),                 null),          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 8589934592), 8589934592,                        decode(bitand(imcs.segflag, 206158430208),                        68719476736,   'BY ROWID RANGE',                        137438953472,  'BY PARTITION',                        206158430208,  'BY SUBPARTITION',                        0,             'AUTO'), 'UNKNOWN'),null),          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 6597069766656),                        2199023255552, 'NO DUPLICATE',                        4398046511104, 'DUPLICATE',                        6597069766656, 'DUPLICATE ALL', 'UNKNOWN'),                 null),          decode(bitand(imcs.segflag, 4294967296), 4294967296,                 decode(bitand(imcs.segflag, 841813590016),                               17179869184,  'NO MEMCOMPRESS',                              274877906944, 'FOR DML',                               292057776128, 'FOR QUERY LOW',                               549755813888, 'FOR QUERY HIGH',                               566935683072, 'FOR CAPACITY LOW',                               824633720832, 'FOR CAPACITY HIGH','UNKNOWN'),                 null), imcs.con_id          from x$imcsegments imcs          where imcs.segtype = 0          and OWNID= userenv('SCHEMAID')
+++GV$INCMETER_CONFIG+++              select inst_id,       tilt,       cfactor,        wfactor,        wtfactor,        mtime,        con_id from x$dbkincmetcfg
+++GV$INCMETER_INFO+++                select inst_id,       incident_id,       ctime,        decode(is_disabled,  0, 'N',                             1, 'Y'),        decode(is_active,    0, 'N',                             1, 'Y'),        decode(is_pers_impt, 0, 'TRANSIENT',                             1, 'PERSISTENT',                                'UNKNOWN       '),        impact1,        impact2,        impact3,        impact4,         CON_ID from x$dbkincmetinfo
+++GV$INCMETER_SUMMARY+++             select inst_id,       decode(severity_idx, 0, 'NORMAL',                             1, 'WARNING',                             2, 'CRITICAL',                                'UNKNOWN       '),        critical_incidents,       warning_incidents,        last_hour_incidents,        ctime,        otictime,        opictime,        lictime,        con_id from x$dbkincmetsummary
+++GV$INDEXED_FIXED_COLUMN+++         select c.inst_id,kqftanam, kqfcoidx, kqfconam, kqfcoipo, c.con_id  from x$kqfco c, x$kqfta t where t.indx = c.kqfcotab and kqfcoidx != 0
+++GV$INMEMORY_AREA+++                select INST_ID, POOL, ALLOCATED_LEN, USED_LEN, STATUS, CON_ID          from x$ktsimau
+++GV$INSTANCE+++                     select ks.inst_id,ksuxsins,ksuxssid,ksuxshst,ksuxsver,ksuxstim,decode(ksuxssts,0,'STARTED',1,'MOUNTED',2,'OPEN',3,'OPEN MIGRATE','UNKNOWN'),decode(ksuxsshr,0,'NO',1,'YES',2,NULL),ksuxsthr,decode(ksuxsarc,0,'STOPPED',1,'STARTED','FAILED'),decode(ksuxslsw,0,NULL,2,'ARCHIVE LOG',3,'CLEAR LOG',4,'CHECKPOINT',       5,'REDO GENERATION'),decode(ksuxsdba,0,'ALLOWED','RESTRICTED'),decode(ksuxsshp,0,'NO','YES'),decode(kvitval,0,'ACTIVE',2147483647,'SUSPENDED','INSTANCE RECOVERY'),decode(ksuxsrol,1,'PRIMARY_INSTANCE',2,'SECONDARY_INSTANCE','UNKNOWN'), decode(qui_state,0,'NORMAL',1,'QUIESCING',2,'QUIESCED','UNKNOWN'), decode(bitand(ksuxsdst, 1), 0, 'NO', 1, 'YES', 'NO'), ks.con_id, decode(ksuxsmode,2,'READ MOSTLY','REGULAR'), decode(ksuxsedition, 2, 'PO', 4, 'SE', 8, 'EE', 16, 'XE', 32, 'CS',        40, 'CE', 'UNKNOWN'), ksuxsfam from x$ksuxsinst ks, x$kvit kv, x$quiesce qu where kvittag = 'kcbwst'
+++GV$INSTANCE_CACHE_TRANSFER+++      select inst_id, instance,  decode(class,1,'data block',2,'sort block',3,'save undo block',  4,'segment header',5,'save undo header',6,'free list',7,'extent map',  8,'1st level bmb',9,'2nd level bmb',10,'3rd level bmb',  11,'bitmap block',12,'bitmap index block',13,'file header block',14,'unused',  15,'undo header',16,'undo block'),  lost, lost_time,  cr_2hop + cr_3hop, cr_2hop_time + cr_3hop_time,  cr_2hop, cr_2hop_time, cr_3hop, cr_3hop_time,  cr_busy, cr_busy_time, cr_congested, cr_congested_time,  current_2hop + current_3hop, current_2hop_time + current_3hop_time,  current_2hop, current_2hop_time, current_3hop, current_3hop_time,  current_busy, current_busy_time, current_congested,  current_congested_time, con_id   from x$instance_cache_transfer
+++GV$INSTANCE_LOG_GROUP+++           select  USERENV('Instance'), THREAD# , STATUS , ENABLED , GROUPS , INSTANCE , OPEN_TIME , CURRENT_GROUP# , SEQUENCE# , CHECKPOINT_CHANGE# , CHECKPOINT_TIME , ENABLE_CHANGE# , ENABLE_TIME , DISABLE_CHANGE# , DISABLE_TIME, CON_ID from V$THREAD
+++GV$INSTANCE_PING+++                select inst_id, inst,  CUR_500B, AVE_500B, MAX_500B, ITER_500B, WAIT_500B, WAITSQ_500B,  CUR_8K, AVE_8K, MAX_8K, ITER_8K, WAIT_8K, WAITSQ_8K, CON_ID  from x$ksxpping
+++GV$INSTANCE_RECOVERY+++            select          T.INST_ID,          to_number(decode(CUR_EST_RCV_READS, -1, NULL, CUR_EST_RCV_READS)),          to_number(decode(ACTUAL_REDO_BLKS, -1, NULL, ACTUAL_REDO_BLKS)),          to_number(decode(MIN_LAG, 0, NULL, MIN_LAG)),          to_number(decode(LOGFILESZ, 0, NULL, LOGFILESZ)),          to_number(decode(CT_LAG, 0, NULL, CT_LAG)),          to_number(decode(CI_LAG, 0, NULL, CI_LAG)),          to_number(decode(ACTUAL_REDO_BLKS, 0, NULL, NULL)),          INUSE_NONRAC_MTTR_SEC+INUSE_RAC_MTTR_SEC,          to_number(decode(CUR_EST_IR_SEC, -1, CUR_EST_NONRAC_MTTR_SEC,                           CUR_EST_IR_SEC)),          (select ksusgstv - (select ksusgstv from X$KSUSGSTA where          ksusdnam='physical writes non checkpoint' and inst_id=t.inst_id)          from X$KSUSGSTA where ksusdnam = 'physical writes' and          inst_id=t.inst_id),          (select logfile_size from x$kctlax where indx=0 and          inst_id=t.inst_id),          to_number(decode(CUR_EST_CA_SEC, -1, NULL, CUR_EST_CA_SEC)),          MTTR_WRITES, LOGFILE_SIZE_WRITES, CKPT_SETTING_WRITES, OTHER_WRITES,          AUTO_WRITES, FULL_WRITES, T.CON_ID          from X$TARGETRBA T, X$ESTIMATED_MTTR E, X$KCTICW W where          T.INST_ID=E.INST_ID AND T.INST_ID=W.INST_ID
+++GV$IOFUNCMETRIC+++                 SELECT inst_id, begtime, endtime, intsize_csec,                 f.function_id, fn.function_name,                 small_read_mbps, small_write_mbps,                 large_read_mbps, large_write_mbps,                 small_read_iops, small_write_iops,                 large_read_iops, large_write_iops,                 decode(num_waits, 0, 0, wait_time / num_waits), f.con_id          FROM   x$kewmiofmv f,                 (select function_id, function_name from v$iostat_function                   group by function_id, function_name) fn          WHERE flag1 = 1            AND f.function_id = fn.function_id
+++GV$IOFUNCMETRIC_HISTORY+++         SELECT inst_id, begtime, endtime, intsize_csec,                 f.function_id, fn.function_name,                 small_read_mbps, small_write_mbps,                 large_read_mbps, large_write_mbps,                 small_read_iops, small_write_iops,                 large_read_iops, large_write_iops,                 decode(num_waits, 0, 0, wait_time / num_waits), f.con_id          FROM   x$kewmiofmv f,                 (select function_id, function_name from v$iostat_function                   group by function_id, function_name) fn          WHERE f.function_id = fn.function_id
+++GV$IOSTAT_CONSUMER_GROUP+++        SELECT A.inst_id, CONSUMER_GROUP_ID_KSFDSTCG,                                sum(round((SBRDATA_KSFDSTCG + A_SBRDATA_KSFDSTCG) / 2048)),                  sum(round((SBWDATA_KSFDSTCG + A_SBWDATA_KSFDSTCG) / 2048)),                  sum(round((MBRDATA_KSFDSTCG + A_MBRDATA_KSFDSTCG) / 2048)),                  sum(round((MBWDATA_KSFDSTCG + A_MBWDATA_KSFDSTCG) / 2048)),                  sum(SBRREQS_KSFDSTCG + A_SBRREQS_KSFDSTCG),                                  sum(SBWREQS_KSFDSTCG + A_SBWREQS_KSFDSTCG),                                  sum(MBRREQS_KSFDSTCG + A_MBRREQS_KSFDSTCG),                                  sum(MBWREQS_KSFDSTCG + A_MBWREQS_KSFDSTCG),                                  sum(WREQS_KSFDSTCG + A_WREQS_KSFDSTCG),                                      sum(WTIME_KSFDSTCG + A_WTIME_KSFDSTCG/1000),                                 A.con_id                                                                     FROM X$KSFDSTCG A , x$kgskcft B                                              WHERE B.class_id_kgskcft = A.consumer_group_id_ksfdstcg                      GROUP BY A.INST_ID, CONSUMER_GROUP_ID_KSFDSTCG, A.con_id
+++GV$IOSTAT_FILE+++                  SELECT k.inst_id, k.FILENO_KSFDSTFILE, 2, 'Data File',                         round(k.SBRDATA_KSFDSTFILE / 2048),                                           round(k.SBWDATA_KSFDSTFILE / 2048),                                           round(k.MBRDATA_KSFDSTFILE / 2048),                                           round(k.MBWDATA_KSFDSTFILE / 2048),                                           k.SBRSREQS_KSFDSTFILE, k.SBWSREQS_KSFDSTFILE,                                 k.SSBRREQS_KSFDSTFILE, k.MBRSREQS_KSFDSTFILE,                                 k.MBWSREQS_KSFDSTFILE, k.SBRSERV_KSFDSTFILE,                                  k.SBWSERV_KSFDSTFILE, k.SSBRLATENCY_KSFDSTFILE,                               k.MBRSERV_KSFDSTFILE, k.MBWSERV_KSFDSTFILE,                                   decode(bitand(k.FLAGS_KSFDSTFILE, 4), 0, 'ASYNC_OFF', 'ASYNC_ON'),            decode(k.ACCESS_KSFDSTFILE, 1,'OS_LIB', 2,'ODM_LIB',3,                               'ASM_MANAGED',4,'DNFS_LIB'),                                           k.RETRIES_KSFDSTFILE, f.CON_ID                                                FROM X$KSFDSTFILE k, x$kccfe f where f.fedup <> 0                             and f.fenum=k.FILENO_KSFDSTFILE and k.FILETYPE_KSFDSTFILE=2                  union                                                                         SELECT k.inst_id, k.FILENO_KSFDSTFILE, 6, 'Temp File',                         round(k.SBRDATA_KSFDSTFILE / 2048),                                           round(k.SBWDATA_KSFDSTFILE / 2048),                                           round(k.MBRDATA_KSFDSTFILE / 2048),                                           round(k.MBWDATA_KSFDSTFILE / 2048),                                           k.SBRSREQS_KSFDSTFILE, k.SBWSREQS_KSFDSTFILE,                                 k.SSBRREQS_KSFDSTFILE, k.MBRSREQS_KSFDSTFILE,                                 k.MBWSREQS_KSFDSTFILE, k.SBRSERV_KSFDSTFILE,                                  k.SBWSERV_KSFDSTFILE,  k.SSBRLATENCY_KSFDSTFILE,                              k.MBRSERV_KSFDSTFILE,  k.MBWSERV_KSFDSTFILE,                                  decode(bitand(k.FLAGS_KSFDSTFILE, 4), 0, 'ASYNC_OFF', 'ASYNC_ON'),            decode(k.ACCESS_KSFDSTFILE, 1,'OS_LIB', 2,'ODM_LIB',3,                               'ASM_MANAGED',4,'DNFS_LIB'),                                           k.RETRIES_KSFDSTFILE, f.CON_ID                                                FROM X$KSFDSTFILE k, x$kcctf f where f.tfdup <> 0                             and f.tfnum=k.FILENO_KSFDSTFILE and k.FILETYPE_KSFDSTFILE=6                  union                                                                         SELECT k.inst_id, k.FILENO_KSFDSTFILE, k.FILETYPE_KSFDSTFILE,                  decode(k.FILETYPE_KSFDSTFILE,                                                 1,'Control File', 3,'Log File', 4,'Archive Log',                              9,'Data File Backup', 10,'Data File Incremental Backup',                      11,'Archive Log Backup', 12,'Data File Copy', 17,'Flashback Log',             18,'Data Pump Dump File', 34, 'External Table','Other'),                      round(k.SBRDATA_KSFDSTFILE / 2048),                                           round(k.SBWDATA_KSFDSTFILE / 2048),                                           round(k.MBRDATA_KSFDSTFILE / 2048),                                           round(k.MBWDATA_KSFDSTFILE / 2048),                                           k.SBRSREQS_KSFDSTFILE, k.SBWSREQS_KSFDSTFILE,                                 k.SSBRREQS_KSFDSTFILE, k.MBRSREQS_KSFDSTFILE,                                 k.MBWSREQS_KSFDSTFILE, k.SBRSERV_KSFDSTFILE,                                  k.SBWSERV_KSFDSTFILE,  k.SSBRLATENCY_KSFDSTFILE,                              k.MBRSERV_KSFDSTFILE,  k.MBWSERV_KSFDSTFILE,                                  decode(bitand(k.FLAGS_KSFDSTFILE, 4), 0, 'ASYNC_OFF', 'ASYNC_ON'),            decode(k.ACCESS_KSFDSTFILE, 1,'OS_LIB', 2,'ODM_LIB',3,                               'ASM_MANAGED',
+++GV$IOSTAT_FUNCTION+++              SELECT inst_id, COMPONENT_ID_KSFDSTCMP,                                     decode(COMPONENT_ID_KSFDSTCMP,                                            0, 'RMAN', 1, 'DBWR', 2, 'LGWR', 3, 'ARCH',                               4, 'XDB',  5, 'Streams AQ',                                               6, 'Data Pump', 7, 'Recovery', 8, 'Buffer Cache Reads',                   9, 'Inmemory Populate',                                                   10, 'Direct Reads', 11, 'Direct Writes',                                  12, 'Smart Scan', 13, 'Archive Manager',                                  14, 'Others'),                                                            sum(round((SBRDATA_KSFDSTCMP + A_SBRDATA_KSFDSTCMP) / 2048)),             sum(round((SBWDATA_KSFDSTCMP + A_SBWDATA_KSFDSTCMP) / 2048)),             sum(round((MBRDATA_KSFDSTCMP + A_MBRDATA_KSFDSTCMP) / 2048)),             sum(round((MBWDATA_KSFDSTCMP + A_MBWDATA_KSFDSTCMP) / 2048)),             sum(SBRREQS_KSFDSTCMP + A_SBRREQS_KSFDSTCMP),                             sum(SBWREQS_KSFDSTCMP + A_SBWREQS_KSFDSTCMP),                             sum(MBRREQS_KSFDSTCMP + A_MBRREQS_KSFDSTCMP),                             sum(MBWREQS_KSFDSTCMP + A_MBWREQS_KSFDSTCMP),                             sum(WREQS_KSFDSTCMP + A_WREQS_KSFDSTCMP),                                 sum(WTIME_KSFDSTCMP + A_WTIME_KSFDSTCMP/1000),                            con_id                                                                  FROM X$KSFDSTCMP GROUP BY inst_id, COMPONENT_ID_KSFDSTCMP, con_id
+++GV$IOSTAT_FUNCTION_DETAIL+++       SELECT inst_id, COMPONENT_ID_KSFDSTCMP,                                     decode(COMPONENT_ID_KSFDSTCMP,                                            0, 'RMAN', 1, 'DBWR', 2, 'LGWR', 3, 'ARCH',                               4, 'XDB',  5, 'Streams AQ',                                               6, 'Data Pump', 7, 'Recovery', 8, 'Buffer Cache Reads',                   9, 'Inmemory Populate',                                                   10, 'Direct Reads', 11, 'Direct Writes',                                  12, 'Smart Scan', 13, 'Archive Manager',                                  14, 'Others'),                                                            FILETYPE_KSFDSTCMP,                                                       decode(FILETYPE_KSFDSTCMP,                                                1,'Control File', 2, 'Data File', 3, 'Log File',                          4,'Archive Log',  6, 'Temp File',                                         9,'Data File Backup', 10,'Data File Incremental Backup',                  11,'Archive Log Backup', 12, 'Data File Copy',                            13,'Parameter File', 14,'DR Config file', 15,'OSM File',                  16,'Change Tracking File', 17,'Flashback Log',                            18,'Data Pump Dump File', 19,'Cross Platform Data File',                  20,'Auto Backup File', 21,'OS file', 22,'Block Dump File',                23,'CSS Voting File', 24,'OCR File', 25,'ASM Staleness File',             26,'ASM Vol Device File', 27,'ASM Vol Dirty Region File',                 28,'Password File', 29, 'ADS AMS Relation File',                          30,'OCR Backup File', 31,'ASM Parameter File',                            32,'Flash File', 33,'ASM spfile backup',                                  34,'External Table File', 35,'Data File XTT Backup',                      36,'OS Audit File', 37,'Data File Incremental Backup',                    38,'AKM KeyStore', 39,'AKM AutoLogin KeyStore',                           40,'ORS Block Pool File', 41,'SQL Loader File',                           42,'AM Container File', 'Other'),                                         sum(round((SBRDATA_KSFDSTCMP + A_SBRDATA_KSFDSTCMP) / 2048)),             sum(round((SBWDATA_KSFDSTCMP + A_SBWDATA_KSFDSTCMP) / 2048)),             sum(round((MBRDATA_KSFDSTCMP + A_MBRDATA_KSFDSTCMP) / 2048)),             sum(round((MBWDATA_KSFDSTCMP + A_MBWDATA_KSFDSTCMP) / 2048)),             sum(SBRREQS_KSFDSTCMP + A_SBRREQS_KSFDSTCMP),                             sum(SBWREQS_KSFDSTCMP + A_SBWREQS_KSFDSTCMP),                             sum(MBRREQS_KSFDSTCMP + A_MBRREQS_KSFDSTCMP),                             sum(MBWREQS_KSFDSTCMP + A_MBWREQS_KSFDSTCMP),                             sum(WREQS_KSFDSTCMP + A_WREQS_KSFDSTCMP),                                 sum(WTIME_KSFDSTCMP + A_WTIME_KSFDSTCMP/1000),                            con_id                                                                  FROM X$KSFDSTCMP                                                          WHERE SBRDATA_KSFDSTCMP <> 0 OR A_SBRDATA_KSFDSTCMP <> 0 OR                     SBWDATA_KSFDSTCMP <> 0 OR A_SBWDATA_KSFDSTCMP <> 0 OR                     MBRDATA_KSFDSTCMP <> 0 OR A_MBRDATA_KSFDSTCMP <> 0 OR                     MBWDATA_KSFDSTCMP <> 0 OR A_MBWDATA_KSFDSTCMP <> 0 OR                     SBRREQS_KSFDSTCMP <> 0 OR A_SBRREQS_KSFDSTCMP <> 0 OR                     SBWREQS_KSFDSTCMP <> 0 OR A_SBWREQS_KSFDSTCMP <> 0 OR                     MBRREQS_KSFDSTCMP <> 0 OR A_MBRREQS_KSFDSTCMP <> 0 OR                     MBWREQS_KSFDSTCMP <> 0 OR A_MBWREQS_KSFDSTCMP <> 0 OR                     WREQS_KSFDSTCMP   <> 0 OR A_WREQS_KSFDSTCMP   <> 0 OR                     WTIME_KSFDSTCMP   <> 0 OR A_WTIME_KSFDSTCMP   <> 0                  GROUP BY inst_id, COMPONENT_ID_KSFDSTCMP, FILETYPE_KSFDSTCMP, con_id          ORDER BY inst_id, COMPONENT_ID_KSFDSTCMP
+++GV$IOSTAT_NETWORK+++               select  INST_ID,        KSRPCCLIENT,        KSRPCREADS,        KSRPCWRITES,        KSRPCRKB,        KSRPCWKB,        KSRPCRLATENCY,        KSRPCWLATENCY,         CON_ID from X$KSRPCIOS
+++GV$IOS_CLIENT+++                   select inst_id, clientid_kfias_clnt, cluster_kfias_clnt, node_kfias_clnt,   instname_kfias_clnt, dbname_kfias_clnt, group_kfias_clnt,   con_id  from x$kfias_clnt
+++GV$IO_CALIBRATION_STATUS+++        SELECT inst_id,                                              decode(status_kkkicr, 1, 'IN PROGRESS',                                            2, 'READY',                                                     'NOT AVAILABLE'),                   endtime_kkkicr, con_id                                       FROM X$KKKICR
+++GV$IO_OUTLIER+++                   SELECT inst_id, IO_COMPONENT_ID,                                            decode(IO_COMPONENT_ID,                                                   0, 'RMAN', 1, 'DBWR', 2, 'LGWR', 3, 'ARCH',                               4, 'XDB',  5, 'Streams AQ',                                               6, 'Data Pump', 7, 'Recovery', 8, 'Buffer Cache Reads',                   9, 'Inmemory Populate', 10, 'Direct Reads',                               11, 'Direct Writes', 13, 'Archive Manager',                               14, 'Others'),                                                          IO_SIZE,                                  WAIT_EVENT,                               FILE_NAME,                                IO_LATENCY,                               DISK1_NAME,                               DISK1_IO_LATENCY,                         DISK2_NAME,                               DISK2_IO_LATENCY,                         DISK3_NAME,                               DISK3_IO_LATENCY,                         CON_ID                                    FROM X$KSFDSTLL WHERE IO_COMPONENT_ID != 2
+++GV$IR_FAILURE+++                   select inst_id,       id,       pid,       cid_count,       clsname,       cast(ctime as date),       cast(mtime as date),       fdg_msg,       damage_msg,       decode(priority, 0, 'CRITICAL',                         1, 'HIGH',                         2, 'LOW',                         'UNKNOWN'),       decode(status, 0, 'OPEN',                       1, 'CLOSED',                       2, 'UNDER-REPAIR',                       'UNKNOWN'),        con_id from x$dbkfdg    where type = 1 and clsnameid = 2 and bitand(FLAGS,3) = 0
+++GV$IR_FAILURE_SET+++               select inst_id,       id,       failid,decode(bitand(flags,8), 0, 'NO', 'YES'),        con_id from x$dbkfset
+++GV$IR_MANUAL_CHECKLIST+++          select inst_id,       fid,       rank,decode(bitand(flags,65536), 0, 'NO', 'YES'),       reco_msg,        con_id from x$dbkreco where type = 0
+++GV$IR_REPAIR+++                    select inst_id,       id,       fid,       name,       rank,       cast(ctime as date),       cast(etime as date),       cast('UNKNOWN' as varchar2(20)),       reco_msg,       script,       est_rtime,       act_rtime,       decode(status, 0, 'NOT RUN',                       1, 'RUNNING',                       2, 'SUCCESS',                       3, 'FAILED',                       'UNKNOWN'),        con_id from x$dbkreco where type = 1
+++GV$JAVAPOOL+++                     select inst_id, ksmchcom, sum(ksmchsiz), con_id from x$ksmjch  group by inst_id, ksmchcom, con_id order by ksmchcom
+++GV$JAVA_LIBRARY_CACHE_MEMORY+++    select inst_id,  decode(kgljsim_namespace, 0,'SQL AREA', 1,'TABLE/PROCEDURE',         2,'BODY', 3,'TRIGGER', 4,'INDEX', 5,'CLUSTER', 6,'OBJECT',         7,'PIPE', 13,'JAVA SOURCE', 14,'JAVA RESOURCE',         32,'JAVA DATA', '?'),  kgljsim_pincnt, kgljsim_pinmem, kgljsim_unpincnt, kgljsim_unpinmem, con_id  from x$kgljmem where kgljsim_namespace<8 or kgljsim_namespace=13 or  kgljsim_namespace=14 or kgljsim_namespace=32  union  select inst_id, 'OTHER/SYSTEM', sum(kgljsim_pincnt) sum_pincnt,  sum(kgljsim_pinmem) sum_pinmem, sum(kgljsim_unpincnt) sum_unpincnt,  sum(kgljsim_unpinmem) sum_unpinmem, con_id from x$kgljmem where not  (kgljsim_namespace<8 or kgljsim_namespace=13 or kgljsim_namespace=14  or kgljsim_namespace=32) group by inst_id, con_id
+++GV$JAVA_POOL_ADVICE+++             select inst_id, java_size, round(java_size / basejava_size, 4),  kgljsim_size, kgljsim_objs, kgljsim_timesave,  decode(kgljsim_basetimesave, 0, to_number(null),         round(kgljsim_timesave / kgljsim_basetimesave, 4)),  kgljsim_parsetime, decode(kgljsim_baseparsetime, 0, to_number(null),         round(kgljsim_parsetime / kgljsim_baseparsetime, 4)),  kgljsim_hits, con_id from x$kgljsim
+++GV$KERNEL_IO_OUTLIER+++            SELECT inst_id,                           TIMESTAMP,                                IO_SIZE,                                  IO_OFFSET,                                DEVICE_NAME,                              PROCESS_NAME,                             TOTAL_LATENCY,                            SETUP_LATENCY,                            QUEUE_TO_HBA_LATENCY,                     TRANSFER_LATENCY,                         CLEANUP_LATENCY,                          PID,                                      CON_ID                                    FROM X$KSFDKLL
+++GV$KEY_VECTOR+++                   select    inst_id, bitand(ekey, 65535), con_id, bitand(id, 65535),    sqlid, execsta, execid, sepid,    decode(bitand(x.flags, 20), 20, 'BYPASSED', 16, 'FINISHED',           4, 'BYPASS', 'RUNNING'),    decode(type, 1, 'SIMPLE', 2, 'INDIRECT', 3, 'HASH', 'INVALID'),    case when (wide < 0) then (0 - wide) else (8 * wide) end,    decode(keytype, 1, 'NUMBER', 2, 'BINARY_FLOAT',           3, 'BINARY', 4, 'PACKED_BINARY',           5, 'PACKED_NUMBER', 6, 'PACKED_DATE', to_char(null)),    nkeys, numjks, mpcnt, minijk, maxijk, maxdgk + 1,     flt, tot, nact, ndis,    alloc, inuse, u1.name, o1.name, u2.name, o2.name   from X$QESXL x, SYS.OBJ$ o1, SYS.OBJ$ o2, SYS.USER$ u1, SYS.USER$ u2  where x.fobj#=o1.obj#(+) and u1.user#(+)=o1.owner#    and x.dobj#=o2.obj#(+) and u2.user#(+)=o2.owner#
+++GV$KSFQP+++                        select  inst_id, con_id, sid, ser, setid,         rman_status_recid, rman_status_stamp,         flags, devtype, type, status, filename,         set_count, set_stamp, block_size, buffer_size, buffer_count,         total_blocks, open_time, close_time, aggregate_count,          blocks, sync_count, sync_tottime, sync_maxtime,          async_short_count, async_short_tottime, async_short_maxtime,         async_long_count, async_long_tottime, async_long_maxtime,          async_fail, async_ready  from X$KSFQP
+++GV$LATCH+++                        select lt.inst_id,lt.kslltaddr,lt.kslltnum,lt.kslltlvl,lt.kslltnam,        lt.ksllthsh,lt.kslltwgt,lt.kslltwff,        lt.kslltwsl,lt.kslltngt,lt.kslltnfa,lt.kslltwkc,        lt.kslltwth,lt.ksllthst0,lt.ksllthst1,lt.ksllthst2,        lt.ksllthst3,lt.ksllthst4,lt.ksllthst5,lt.ksllthst6,lt.ksllthst7,        lt.ksllthst8,lt.ksllthst9,lt.ksllthst10, lt.ksllthst11, lt.kslltwtt,        lt.con_id from x$kslltr lt
+++GV$LATCHHOLDER+++                  select inst_id,ksuprpid,ksuprsid,ksuprlat,ksuprlnm,ksulagts, con_id  from x$ksuprlat
+++GV$LATCHNAME+++                    select inst_id, indx, kslldnam, ksllddsp, kslldhsh, con_id from x$kslld
+++GV$LATCH_CHILDREN+++               select t.inst_id,t.kslltaddr,t.kslltnum,t.kslltcnm,t.kslltlvl,        t.kslltnam,t.ksllthsh,        t.kslltwgt,t.kslltwff,t.kslltwsl,t.kslltngt,t.kslltnfa,        t.kslltwkc,t.kslltwth,t.ksllthst0,t.ksllthst1,        t.ksllthst2,t.ksllthst3,t.ksllthst4,t.ksllthst5,        t.ksllthst6,t.ksllthst7,t.ksllthst8,        t.ksllthst9,t.ksllthst10, t.ksllthst11,        t.kslltwtt, t.con_id  from x$kslltr_children t
+++GV$LATCH_MISSES+++                 select t1.inst_id,t1.ksllasnam, t2.ksllwnam, t1.kslnowtf, t1.kslsleep, t1.kslwscwsl, t1.kslwsclthg, t2.ksllwnam, t1.con_id         from  x$ksllw t2, x$kslwsc t1         where t2.indx = t1.indx
+++GV$LATCH_PARENT+++                 select t.inst_id,t.kslltaddr,t.kslltnum,t.kslltlvl,t.kslltnam,t.ksllthsh,        t.kslltwgt,t.kslltwff,t.kslltwsl,t.kslltngt,t.kslltnfa,        t.kslltwkc,t.kslltwth,t.ksllthst0,t.ksllthst1,        t.ksllthst2,t.ksllthst3,t.ksllthst4,t.ksllthst5,        t.ksllthst6,t.ksllthst7,t.ksllthst8,        t.ksllthst9,t.ksllthst10, t.ksllthst11,        t.kslltwtt, t.con_id  from x$kslltr_parent t
+++GV$LGWRIO_OUTLIER+++               SELECT inst_id, IO_COMPONENT_ID,                                     decode(IO_COMPONENT_ID,                                            0, 'RMAN', 1, 'DBWR', 2, 'LGWR', 3, 'ARCH',                               4, 'XDB',  5, 'Streams AQ',                                               6, 'Data Pump', 7, 'Recovery', 8, 'Buffer Cache Reads',                   9, 'Inmemory Populate', 10, 'Direct Reads',                               11, 'Direct Writes', 13, 'Archive Manager',                               14, 'Others'),                                                          IO_SIZE,                                  WAIT_EVENT,                               FILE_NAME,                                IO_LATENCY,                               DISK1_NAME,                               DISK1_IO_LATENCY,                         DISK2_NAME,                               DISK2_IO_LATENCY,                         DISK3_NAME,                               DISK3_IO_LATENCY,                          CON_ID                          FROM X$KSFDSTLL WHERE IO_COMPONENT_ID = 2
+++GV$LIBCACHE_LOCKS+++               SELECT INST_ID, 'LOCK', KGLLKADR, KGLLKUSE, KGLLKSES,         KGLLKHDL, KGLLKPNC, KGLLKCNT, KGLLKMOD, KGLLKREQ, KGLLKSPN, CON_ID         FROM X$KGLLK         UNION         SELECT INST_ID, 'PIN', KGLPNADR, KGLPNUSE, KGLPNSES, KGLPNHDL,        KGLPNLCK, KGLPNCNT, KGLPNMOD, KGLPNREQ, KGLPNSPN, CON_ID         FROM X$KGLPN
+++GV$LIBRARYCACHE+++                 select inst_id, kglstdsc, kglstget, kglstght, decode(kglstget,0,1,kglstght/kglstget),kglstpin,kglstpht, decode(kglstpin,0,1,kglstpht/kglstpin),kglstrld,kglstinv, kglstlrq, kglstprq, kglstprq, kglstmiv, kglstmiv, con_id from x$kglst where kglsttyp = 'NAMESPACE' and kglstget != 0                      and LENGTH(kglstdsc) <= 15
+++GV$LIBRARY_CACHE_MEMORY+++         select inst_id,  decode(kglsim_namespace, 0,'SQL AREA', 1,'TABLE/PROCEDURE',         2,'BODY', 3,'TRIGGER', 4,'INDEX', 5,'CLUSTER', 6,'OBJECT',         7,'PIPE', 13,'JAVA SOURCE', 14,'JAVA RESOURCE',         32,'JAVA DATA', '?'),  kglsim_pincnt, kglsim_pinmem, kglsim_unpincnt, kglsim_unpinmem, con_id  from x$kglmem where kglsim_namespace<8 or kglsim_namespace=13 or  kglsim_namespace=14 or kglsim_namespace=32  union  select inst_id, 'OTHER/SYSTEM', sum(kglsim_pincnt) sum_pincnt,  sum(kglsim_pinmem) sum_pinmem, sum(kglsim_unpincnt) sum_unpincnt,  sum(kglsim_unpinmem) sum_unpinmem, con_id from x$kglmem where not  (kglsim_namespace<8 or kglsim_namespace=13 or kglsim_namespace=14  or kglsim_namespace=32) group by inst_id, con_id
+++GV$LICENSE+++                      select inst_id,ksullms,ksullws,ksullcs,ksullhs,ksullmu,cpu_count, decode(cpu_core_count,0,to_number(null),cpu_core_count), decode(cpu_socket_count,0,to_number(null),cpu_socket_count), cpu_count_hwm, decode(cpu_core_count_hwm,0,to_number(null),cpu_core_count_hwm), decode(cpu_socket_count_hwm,0,to_number(null),cpu_socket_count_hwm), con_id from x$ksull
+++GV$LISTENER_NETWORK+++             SELECT INST_ID, KMMNVNET, KMMNVTYP, KMMNVVAL, CON_ID          FROM X$KMMNV          ORDER BY KMMNVNET, KMMNVTYP, KMMNVVAL
+++GV$LOADISTAT+++                    select inst_id,klcieon,klcietn,klciein,klcieisn,klciemno,klciemsg, con_id from x$klcie
+++GV$LOADPSTAT+++                    select inst_id,klcpxon,klcpxtn,klcpxpn,klcpxrld, con_id from x$klpt
+++GV$LOBSTAT+++                      select inst_id, LOBTSN, LOBRDBA, LOBOBJID, LOBCURRTIME, LOBEXPMQL, LOBSQLMQL, LOBSPCANALTIME,          LOBUNDORETTIME, CON_ID from x$lobstat
+++GV$LOCK+++                         select s.inst_id,l.laddr,l.kaddr,s.ksusenum,r.ksqrsidt,r.ksqrsid1,         r.ksqrsid2,l.lmode,l.request,l.ctime,decode(l.lmode,0,0,l.block),         r.con_id  from v$_lock l, x$ksuse s, x$ksqrs r  where l.saddr=s.addr and        concat(USERENV('Instance'),l.raddr)=concat(r.inst_id,r.addr)
+++GV$LOCKED_OBJECT+++                select x.inst_id,x.kxidusn, x.kxidslt, x.kxidsqn, l.ktadmtab,        s.indx, s.ksuudlna, s.ksuseunm, s.ksusepid, l.ksqlkmod, x.con_id from x$ktcxb x, x$ktadm l, x$ksuse s where x.ktcxbxba = l.kssobown and x.ktcxbses = s.addr
+++GV$LOCKS_WITH_COLLISIONS+++        select USERENV('Instance'), lock_element_addr, con_id  from v$bh          where (forced_writes + forced_reads) > 10              group by lock_element_addr, con_id          having count(*) >= 2
+++GV$LOCK_ACTIVITY+++                select 0, 'NULL', 'S', 'Lock buffers for read', 0, 0 from dual
+++GV$LOCK_ELEMENT+++                 select inst_id, le_addr, indx, le_id2,          le_id1, le_mode, le_blks, le_rls,               le_acq, 0, le_flags, con_id                             from x$le
+++GV$LOCK_TYPE+++                    select rest.inst_id, rest.resname, rest.name, rest.id1, rest.id2,           decode(bitand(eqt.flags, 1), 1, 'YES', 'NO'),           decode(bitand(eqt.flags, 2), 2, 'YES', 'NO'),           rest.expl, rest.con_id    from X$KSIRESTYP rest, X$KSQEQTYP eqt    where (rest.inst_id = eqt.inst_id) and (rest.indx = eqt.indx) and          (rest.indx > 0)
+++GV$LOG+++                          select le.inst_id, le.lenum, le.lethr, le.leseq, le.lesiz*le.lebsz, le.lebsz, ledup, decode(bitand(le.leflg,1),0,'NO','YES'), decode(bitand(le.leflg,24), 8, 'CURRENT',                            16,'CLEARING',                            24,'CLEARING_CURRENT',        decode(sign(leseq),0,'UNUSED',        decode(sign((to_number(rt.rtckp_scn)-to_number(le.lenxs))*        bitand(rt.rtsta,2)*(64-bitand(rtsta, 64))),        -1,'ACTIVE','INACTIVE'))), to_number(le.lelos), to_date(le.lelot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(le.lenxs), to_date(le.lenxt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), le.con_id  from x$kccle le, x$kccrt rt where le.ledup!=0 and le.lethr=rt.rtnum and  le.inst_id = rt.inst_id
+++GV$LOGFILE+++                      select inst_id,fnfno, decode(fnflg,0,'',   decode(bitand(fnflg,1),1,'INVALID',   decode(bitand(fnflg,2),2,'STALE',   decode(bitand(fnflg,4),4,'DELETED',   decode(bitand(fnflg,8+32),8,'',32,'',40,'','UNKNOWN'))))), decode(bitand(fnflg,8),0,'ONLINE','STANDBY'), fnnam, decode(bitand(fnflg, 32),0,'NO','YES'), con_id from x$kccfn where fnnam is not null and fntyp=3
+++GV$LOGHIST+++                      select inst_id,lhthp,lhseq,to_number(lhlos), to_date(lhlot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(lhnxs), con_id from x$kcclh
+++GV$LOGMNR_CONTENTS+++              select INST_ID, SCN, START_SCN, CSCN,         TIMESTAMP, START_TIMESTAMP, COMMIT_TIMESTAMP,         XIDUSN, XIDSLT, XIDSQN, XID,         PXIDUSN, PXIDSLT, PXIDSQN, PXID,         TX_NAME,         OPERATION, OPERATION_CODE, ROLLBACK,         SEG_OWNER, SEG_NAME, TABLE_NAME, SEG_TYPE, SEG_TYPE_NAME,         TABLE_SPACE, ROW_ID,         USERNAME, OS_USERNAME, MACHINE_NAME, AUDIT_SESSIONID,         SESSION#, SERIAL#, SESSION_INFO,         THREAD#, SEQUENCE#, RBASQN, RBABLK, RBABYTE,         UBAFIL, UBABLK, UBAREC,  UBASQN,         ABS_FILE#,REL_FILE#, DATA_BLK#,         DATA_OBJ#, DATA_OBJV#, DATA_OBJD#,         SQL_REDO,  SQL_UNDO, RS_ID, SSN, CSF, INFO,         STATUS, REDO_VALUE, UNDO_VALUE,         SAFE_RESUME_SCN, CSCN, OBJECT_ID, EDITION_NAME, CLIENT_ID,         SRC_CON_NAME, SRC_CON_ID, SRC_CON_UID, SRC_CON_DBID, SRC_CON_GUID,         CON_ID         from x$logmnr_contents where ROW_TYPE = 0
+++GV$LOGMNR_DBA_OBJECTS+++           select u.inst_id, u.name, o.name, o.subname, o.obj#, o.dataobj#,      decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',                      7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',                     11, 'PACKAGE BODY', 12, 'TRIGGER',                     13, 'TYPE', 14, 'TYPE BODY',                     19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',                     22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',                     28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30, 'JAVA RESOURCE',                     32, 'INDEXTYPE', 33, 'OPERATOR',                     34, 'TABLE SUBPARTITION', 35, 'INDEX SUBPARTITION',                     40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',                     42, 'MATERIALIZED VIEW',                     43, 'DIMENSION',                     44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',                     48, 'CONSUMER GROUP',                     51, 'SUBSCRIPTION', 52, 'LOCATION',                     55, 'XML SCHEMA', 56, 'JAVA DATA',                     57, 'SECURITY PROFILE', 59, 'RULE',                     60, 'CAPTURE', 61, 'APPLY',                     62, 'EVALUATION CONTEXT',                     66, 'JOB', 67, 'PROGRAM', 68, 'JOB CLASS', 69, 'WINDOW',                     72, 'WINDOW GROUP', 74, 'SCHEDULE', 79, 'CHAIN',                     81, 'FILE GROUP',                    'UNDEFINED'),      o.ctime, o.mtime,      to_char(o.stime, 'YYYY-MM-DD:HH24:MI:SS'),        decode(o.status, 0, 'N/A', 1, 'VALID', 'INVALID'),        decode(bitand(o.flags, 2), 0, 'N', 2, 'Y', 'N'),        decode(bitand(o.flags, 4), 0, 'N', 4, 'Y', 'N'),        decode(bitand(o.flags, 16), 0, 'N', 16, 'Y', 'N'), u.con_id from x$logmnr_obj$ o, x$logmnr_user$ u where o.owner# = u.user#   and o.linkname is null   and (o.type# not in (1  /* INDEX - handled below */,                       10 /* NON-EXISTENT */)        or        (o.type# = 1 and 1 = (select 1                               from x$logmnr_ind$ i                              where i.obj# = o.obj#                                and i.type# in (1, 2, 3, 4, 6, 7, 9))))   and o.name != '_NEXT_OBJECT'   and o.name != '_default_auditing_options_'
+++GV$LOGMNR_DICTIONARY+++            select INST_ID, DB_NAME, DB_ID, DB_CREATED, TIMESTAMP, RESET_SCN,                 RESET_SCN_TIME, DB_VERSION_TIME, DB_CHARACTER_SET,                 DB_VERSION, DB_STATUS, DICTIONARY_SCN, ENABLED_THREAD_MAP,                 DB_TXN_SCN, FILENAME, INFO, STATUS, CON_ID       from x$logmnr_dictionary
+++GV$LOGMNR_DICTIONARY_LOAD+++       select inst_id, session_id, logmnr_uid,                          action#, opcode, command, current_state,                  completed_actions, total_actions, loaded,                 percent_done, con_id          from x$logmnr_dictionary_load
+++GV$LOGMNR_EXTENTS+++               select e.inst_id, ds.owner, ds.segment_name, ds.partition_name,        ds.segment_type, ds.tablespace_name,        e.ext#, f.file#, e.block#, e.length * ds.blocksize, e.length,        e.file#, e.con_id from x$logmnr_uet$ e, v$logmnr_sys_dba_segs ds, x$logmnr_file$ f where e.segfile# = ds.relative_fno   and e.segblock# = ds.header_block   and e.ts# = ds.tablespace_id   and ds.tablespace_id = f.ts#   and e.file# = f.relfile#   and bitand(NVL(ds.segment_flags,0), 1) = 0   and bitand(NVL(ds.segment_flags,0), 65536) = 0 union all select e.inst_id, ds.owner, ds.segment_name, ds.partition_name,        ds.segment_type, ds.tablespace_name, e.ktfbueextno, f.file#,        e.ktfbuebno, e.ktfbueblks * ds.blocksize, e.ktfbueblks,        e.ktfbuefno, e.con_id from v$logmnr_sys_dba_segs ds, x$logmnr_ktfbue e, x$logmnr_file$ f where e.ktfbuesegfno = ds.relative_fno   and e.ktfbuesegbno = ds.header_block   and e.ktfbuesegtsn = ds.tablespace_id   and e.ktfbuesegtsn = f.ts#   and e.ktfbuefno = f.relfile#   and bitand(NVL(ds.segment_flags, 0), 1) = 1   and bitand(NVL(ds.segment_flags,0), 65536) = 0
+++GV$LOGMNR_LATCH+++                 select inst_id, session_id, name,                 child_addr, decode(state, 0, 'UNINIT', 1, 'READY') state, con_id          from x$logmnr_latch
+++GV$LOGMNR_LOGFILE+++               select inst_id, log_id, filename, low_time, next_time,                 db_id, db_name, reset_scnwrp, reset_scnbas, reset_scn_time,                thread_id, thread_sqn, low_scnwrp, low_scnbas,                 next_scnwrp, next_scnbas,                 decode(state, 0, 'FILE_NOT_OPEN', 1, 'FILE_OPEN', 2, 'DONE'),          con_id from x$logmnr_logfile
+++GV$LOGMNR_LOGS+++                  select INST_ID, LOG_ID, FILENAME, LOW_TIME, HIGH_TIME, DB_ID,                 DB_NAME, RESET_SCN, RESET_SCN_TIME, COMPATIBLE, THREAD_ID,                 THREAD_SQN, LOW_SCN,  NEXT_SCN, DICTIONARY_BEGIN,                 DICTIONARY_END, TYPE, BLOCKSIZE, FILESIZE, INFO,                 STATUS, CON_ID        from x$logmnr_logs
+++GV$LOGMNR_OBJECT_SEGMENTS+++       select userenv('instance'), s.OWNER, s.SEGMENT_NAME, s.PARTITION_NAME,         s.SEGMENT_TYPE, s.SEGMENT_TYPE_ID, s.TABLESPACE_ID,         s.TABLESPACE_NAME, s.BLOCKSIZE,         s.HEADER_FILE, s.HEADER_BLOCK, s.BYTES, s.BLOCKS, s.EXTENTS,         s.INITIAL_EXTENT, s.NEXT_EXTENT, s.MIN_EXTENTS, s.MAX_EXTENTS,         s.PCT_INCREASE, s.FREELISTS, s.FREELIST_GROUPS, s.RELATIVE_FNO,         s.BUFFER_POOL_ID, s.SEGMENT_FLAGS, s.SEGMENT_OBJD, s.con_id from v$logmnr_sys_dba_segs s, v$logmnr_dba_objects o where s.segment_name = o.object_name       and s.segment_type = o.object_type
+++GV$LOGMNR_PARAMETERS+++            select INST_ID, START_DATE, REQUIRED_START_DATE,          END_DATE, START_SCN, REQUIRED_START_SCN, END_SCN,          OPTIONS, INFO, STATUS, CON_ID       from x$logmnr_parameters
+++GV$LOGMNR_PROCESS+++               select a.inst_id, a.session_id, a.pid, a.role,                 a.work_microsec, a.overhead_microsec,                 b.spid, b.username, b.latchwait, b.latchspin,                 c.sid, c.serial#, a.con_id          from x$logmnr_process a, v$process b, v$session c          where a.pid = b.pid and b.sosid = c.process
+++GV$LOGMNR_SESSION+++               select INST_ID, session_id, session_name,                 decode(state, 1, 'READY', 2, 'STARTED', 3, 'ACTIVE',                               4, 'DISCARDED', 5, 'DETACHED', 'UNKNOWN'),                 db_name, db_id, reset_scn, reset_timestamp, reset_time,                       num_process, chunk_size,                 start_scn, end_scn, spill_scn,                 processed_scn, processed_time, prepared_scn, read_scn,                   low_mark_scn, consumed_scn,                 max_memory_size, used_memory_size,                 builder_work_size, prepared_work_size, available_work_size,                 available_txn, available_committed_txn,                 delivered_txn, delivered_committed_txn,                 pinned_txn, pinned_committed_txn, checkpoint_interval, con_id          from x$logmnr_session
+++GV$LOGMNR_STATS+++                 select inst_id, session_id, name, value, con_id from x$krvxsv where bitand(flags, 1) = 1
+++GV$LOGMNR_SYS_DBA_SEGS+++          select u.inst_id, NVL(u.name, 'SYS'), o.name, o.subname,        so.object_type, s.type#,        ts.ts#, ts.name, ts.blocksize,        f.file#, s.block#,        s.blocks * ts.blocksize, s.blocks, s.extents,        s.iniexts * ts.blocksize,        s.extsize * ts.blocksize,        s.minexts, s.maxexts,        decode(bitand(ts.flags, 3), 1, to_number(NULL), s.extpct),        decode(bitand(ts.flags, 32), 32, to_number(NULL),               decode(s.lists, 0, 1, s.lists)),        decode(bitand(ts.flags, 32), 32, to_number(NULL),               decode(s.groups, 0, 1, s.groups)),        s.file#, s.cachehint, NVL(s.spare1,0), o.dataobj#, u.con_id         from x$logmnr_user$ u, x$logmnr_obj$ o, x$logmnr_ts$ ts,         v$logmnr_sys_objects so, x$logmnr_seg$ s, x$logmnr_file$ f where s.file# = so.header_file   and s.block# = so.header_block   and s.ts# = so.ts_number   and s.ts# = ts.ts#   and o.obj# = so.object_id   and o.owner# = u.user# (+)   and s.type# = so.segment_type_id   and o.type# = so.object_type_id   and s.ts# = f.ts#   and s.file# = f.relfile# union all select u.inst_id, NVL(u.name, 'SYS'), un.name, NULL,        decode(s.type#, 1, 'ROLLBACK', 10, 'TYPE2 UNDO'), s.type#,        ts.ts#, ts.name, ts.blocksize, f.file#, s.block#,        s.blocks * ts.blocksize, s.blocks, s.extents,        s.iniexts * ts.blocksize, s.extsize * ts.blocksize, s.minexts,        s.maxexts, s.extpct,        decode(bitand(ts.flags, 32), 32, to_number(NULL),          decode(s.lists, 0, 1, s.lists)),        decode(bitand(ts.flags, 32), 32, to_number(NULL),          decode(s.groups, 0, 1, s.groups)),        s.file#, s.cachehint, NVL(s.spare1,0), un.us#, u.con_id from x$logmnr_user$ u, x$logmnr_ts$ ts, x$logmnr_undo$ un, x$logmnr_seg$ s,      x$logmnr_file$ f where s.file# = un.file#   and s.block# = un.block#   and s.ts# = un.ts#   and s.ts# = ts.ts#   and s.user# = u.user# (+)   and s.type# in (1, 10)   and un.status$ != 1   and un.ts# = f.ts#   and un.file# = f.relfile# union all select u.inst_id,        NVL(u.name, 'SYS'), to_char(f.file#) || '.' || to_char(s.block#), NULL,       decode(s.type#, 2, 'DEFERRED ROLLBACK', 3, 'TEMPORARY',                       4, 'CACHE', 9, 'SPACE HEADER', 'UNDEFINED'), s.type#,        ts.ts#, ts.name, ts.blocksize,        f.file#, s.block#,        s.blocks * ts.blocksize, s.blocks, s.extents,        s.iniexts * ts.blocksize,        s.extsize * ts.blocksize,        s.minexts, s.maxexts,        decode(bitand(ts.flags, 3), 1, to_number(NULL),                                       s.extpct),        decode(bitand(ts.flags, 32), 32, to_number(NULL),          decode(s.lists, 0, 1, s.lists)),        decode(bitand(ts.flags, 32), 32, to_number(NULL),          decode(s.groups, 0, 1, s.groups)),        s.file#, s.cachehint, NVL(s.spare1,0), s.hwmincr, u.con_id from x$logmnr_user$ u, x$logmnr_ts$ ts, x$logmnr_seg$ s, x$logmnr_file$ f where s.ts# = ts.ts#   and s.user# = u.user# (+)   and s.type# not in (1, 5, 6, 8, 10)   and s.ts# = f.ts#   and s.file# = f.relfile#
+++GV$LOGMNR_SYS_OBJECTS+++           select inst_id,         decode(bitand(t.property, 8192), 8192, 'NESTED TABLE', 'TABLE'), 2, 5,        t.obj#, t.file#, t.block#, t.ts#, t.con_id from x$logmnr_tab$ t where bitand(t.property, 1024) = 0            /* exclude clustered tables */ union all select inst_id, 'TABLE PARTITION', 19, 5,        tp.obj#, tp.file#, tp.block#, tp.ts#, tp.con_id from x$logmnr_tabpart$ tp union all select inst_id, 'CLUSTER', 3, 5,        c.obj#, c.file#, c.block#, c.ts#, c.con_id from x$logmnr_clu$ c union all select inst_id, decode(i.type#, 8, 'LOBINDEX', 'INDEX'), 1, 6,        i.obj#, i.file#, i.block#, i.ts#, i.con_id from x$logmnr_ind$ i where i.type# in (1, 2, 3, 4, 6, 7, 8, 9) union all select inst_id, 'INDEX PARTITION', 20, 6,        ip.obj#, ip.file#, ip.block#, ip.ts#, ip.con_id from x$logmnr_indpart$ ip union all select inst_id, 'LOBSEGMENT', 21, 8,        l.lobj#, l.file#, l.block#, l.ts#, l.con_id from x$logmnr_lob$ l where (bitand(l.property, 64) = 0) or       (bitand(l.property, 128) = 128) union all select inst_id, 'TABLE SUBPARTITION', 34, 5,        tsp.obj#, tsp.file#, tsp.block#, tsp.ts#, tsp.con_id        from x$logmnr_tabsubpart$ tsp union all select inst_id, 'INDEX SUBPARTITION', 35, 6,        isp.obj#, isp.file#, isp.block#, isp.ts#, isp.con_id from x$logmnr_indsubpart$ isp union all select inst_id,        decode(lf.fragtype$, 'P', 'LOB PARTITION', 'LOB SUBPARTITION'),        decode(lf.fragtype$, 'P', 40, 41), 8,        lf.fragobj#, lf.file#, lf.block#, lf.ts#, lf.con_id from x$logmnr_lobfrag$ lf
+++GV$LOGMNR_TRANSACTION+++           select inst_id, session_id, xid, xidusn, xidslt, xidsqn,                 parentxid, parent_xidusn, parent_xidslt, parent_xidsqn,                starttimestamp, startscn, chunk, totalchunks, redothread,                 lowts, lowscn, committimestamp, commitscn, numchangerecord,                 numlcrspilled, dflag, mflag, mflag2, state, type,                 mining_status, queue, src_con_id, con_id          from x$krvxtx
+++GV$LOGSTDBY+++                     select inst_id,serial#,logstdby_id,pid,type,status_code,status, high_scn, con_id from x$krvslv where exists (select 1 from v$session s, x$knstacr x where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$LOGSTDBY_PROCESS+++             select inst_id, sid, serial#,logstdby_id,pid,type,status_code,status,high_scn, con_id from x$krvslv where exists (select 1 from v$session s, x$knstacr x where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$LOGSTDBY_PROGRESS+++            select inst_id,applied_scn,applied_time,restart_scn,restart_time,latest_scn, latest_time,mining_scn,mining_time,resetlogs_id, con_id from x$krvslvpg
+++GV$LOGSTDBY_STATE+++               select inst_id, primary_dbid,primary_con_dbid,session_id, realtime_apply,state, con_id from x$krvslvst
+++GV$LOGSTDBY_STATS+++               select inst_id, name,value, con_id from (select inst_id, name,value, con_id from x$krvslvs union all select inst_id, name,to_char(value), con_id from (select inst_id, session_id, name, value, con_id from x$krvxsv where bitand(flags, 2) = 2)where session_id = (select value from x$krvslvs where name = 'logminer session id')) where exists (select 1 from v$session s, x$knstacr x where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$LOGSTDBY_TRANSACTION+++         select lt.inst_id, lt.xidusn, lt.xidslt, lt.xidsqn, lt.xid,                 lt.startscn, lt.starttimestamp,                 lt.parent_xidusn, lt.parent_xidslt, lt.parent_xidsqn,                 lt.parentxid, lt.type, lt.mining_status, lt.src_con_id,                 case when sas.sid is null then 'NONE' else 'ACTIVE' end,                 sas.sid, sas.serial#, sas.con_id         from  x$krvslvs ls,               x$krvxtx lt,               v$streams_apply_server sas         where (ls.name = 'logminer session id' and                ls.value = lt.session_id) and               (lt.chunk = 0 and                not (lt.xidusn = 0 and lt.xidslt = 0 and lt.xidsqn = 0)) and               (lt.xidusn = sas.xidusn(+) and lt.xidslt = sas.xidslt(+) and                lt.xidsqn = sas.xidsqn(+))
+++GV$LOG_HISTORY+++                  select x$kcclh.inst_id,lhrid,lhstm,lhthp,lhseq,to_number(lhlos),to_date(lhlot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(lhnxs), to_number(lhrls), to_date(lhrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), con_id from x$kcclh
+++GV$MANAGED_STANDBY+++              select inst_id, decode(MSTYP,   1,'RFS',   2,'MRP0',   3,'MR(fg)',   4,'ARCH',   5,'FGRD',   6,'LGWR',   7,'RFS(FAL)',   8,'RFS(NEXP)',   9,'LNS',   10,'ARCH(SO)',   11,'RMI(FO)',   13,'RMI',   14,'DTS',      'UNKNOWN'), MSPID, decode(MSSTS,   0,'UNUSED',   1,'ALLOCATED',   2,'CONNECTED',   3,'ATTACHED',   4,'IDLE',   5,'ERROR',   6,'OPENING',   7,'CLOSING',   8,'WRITING',   9,'RECEIVING',  10,'ANNOUNCING',  11,'REGISTERING',  12,'WAIT_FOR_LOG',  13,'WAIT_FOR_GAP',  14,'APPLYING_LOG',     'UNKNOWN'), decode(MSPAR,   0,'N/A',   4,'ARCH',   5,'Archival',   6,'LGWR',   9,'LNS',     'UNKNOWN'), decode(MSPPID,   0,'N/A',   to_number(MSPPID)), decode(MSDBID,   0,'N/A',   to_number(MSDBID)), decode(MSLNO,   0,'N/A',   to_number(MSLNO)), to_number(MSRLC), to_number(MSTHR), to_number(MSSEQ), to_number(MSBNO), to_number(MSBCT), to_number(MSDLY), to_number(MSRCLT), to_number(MSACLT),  con_id  from x$krssms
+++GV$MAPPED_SQL+++                   select s.inst_id,s.kglnaobj,s.kglfnobj,s.kglobt03,s.kglobt04, t.kglnaobj,t.kglfnobj,t.kglobt03,t.kglobt04,s.kglnao1n, s.con_id from x$kglsqltxl s, x$kglsqltxl t where s.kglhdmar = t.kglhdadr
+++GV$MAP_COMP_LIST+++                select inst_id,elem_idx,num_comp,comp1_name, comp1_val,comp2_name,comp2_val,comp3_name, comp3_val,comp4_name,comp4_val,comp5_name,comp5_val, con_id from x$ksfmcompl
+++GV$MAP_ELEMENT+++                  select inst_id,elem_name,elem_idx,elem_cfgid, decode(elem_type,1,'MIRROR',2,'STRIPE',3,'RAID5', 4,'CONCATENATED',5,'PARTITION',6,'DISK',7,'ASMDISK',8,'NONE'), to_number(decode(elem_size,4294967295,NULL,elem_size)), elem_nsubelem,elem_descr,stripe_size, to_number(decode(lib_idx,4294967295,NULL,lib_idx)), con_id from x$ksfmelem
+++GV$MAP_EXT_ELEMENT+++              select inst_id,elem_idx,num_attrb,attrb1_name, attrb1_val,attrb2_name,attrb2_val,attrb3_name, attrb3_val,attrb4_name,attrb4_val,attrb5_name,attrb5_val, con_id from x$ksfmextelem
+++GV$MAP_FILE+++                     select inst_id,file_idx,file_cfgid,decode(file_status,1, 'VALID',2,'INVALID' ),file_name,decode(file_type,1,'DATAFILE', 2,'SPFILE',3,'TEMPFILE',4,'CONTROLFILE',5,'LOGFILE',6,'ARCHIVEFILE'), decode(file_struct,1,'FILE',2,'RAWVOLUME',3,'RAWDEVICE',4,'ASMFILE',5,'NONE'), file_size,file_nexts,to_number(decode(lib_idx,4294967295,NULL,lib_idx)), con_id from x$ksfmfile
+++GV$MAP_FILE_EXTENT+++              select inst_id,file_idx,ext_num,ext_dev_off, ext_size,ext_file_off,decode(ext_type,1,'DATA', 2,'PARITY',3,'NONE'),elem_idx, con_id from x$ksfmfileext where elem_idx != 4294967295
+++GV$MAP_FILE_IO_STACK+++            select inst_id,file_idx,depth,elem_idx,cu_size,stride,num_cu, dev_offset,to_number(decode(file_offset,4294967295,NULL,file_offset)), decode(data_type,1,'DATA',2,'PARITY',3,'DATA AND PARITY'),parity_pos, parity_perd,row_id,prow_id, con_id from x$ksfmiost
+++GV$MAP_LIBRARY+++                  select inst_id,lib_idx,lib_name,vendor_name,protocol_num, version_num,path_name,decode(bitand(cap_file,1),0,'N',1,'Y'), decode(bitand(cap_file, 6),0,'NONE',6,'PERSISTENT',2,'NONPERSISTENT'), decode(bitand(cap_elem, 1),0,'N',1,'Y'),decode(bitand(cap_elem,6),0,'NONE', 6,'PERSISTENT',4,'NONPERSISTENT'),decode(cap_other,0,'N',1,'Y'), con_id from x$ksfmlib
+++GV$MAP_SUBELEMENT+++               select inst_id,child_idx,parent_idx,sub_num, to_number(decode(sub_size,4294967295,NULL,sub_size)), to_number(decode(elem_offset,4294967295,NULL,elem_offset)),sub_flags, con_id from x$ksfmsubelem where child_idx != 4294967295
+++GV$MAX_ACTIVE_SESS_TARGET_MTH+++   select inst_id, policy_name_kgskasp, con_id from x$kgskasp
+++GV$MEMORY_CURRENT_RESIZE_OPS+++    select sc.inst_id, sc.component,     decode(sc.opcode, 0, 'STATIC', 1, 'INITIALIZING', 2, 'DISABLED',           3, 'GROW', 4, 'SHRINK', 5, 'SHRINK_CANCEL', NULL),     decode(sc.opmode, 1, 'MANUAL', 2, 'DEFERRED', 3, 'IMMEDIATE', NULL),     pn.name, sc.initsize * sc.gransize, sc.targsize * sc.gransize,     sc.cursize * sc.gransize, sc.starttime, sc.lasttime, sc.con_id   from x$kmgsct sc, v$parameter pn   where (sc.parno = pn.num)     and (sc.opcode <> 0)     and (sc.starttime is not null)
+++GV$MEMORY_DYNAMIC_COMPONENTS+++    select st.inst_id, st.component, st.cursize * st.gransize,      st.minsize * st.gransize, st.maxsize * st.gransize,      st.usersize * st.gransize, st.opercnt,      decode(st.lastoper, 0, 'STATIC', 1, 'INITIALIZING', 2, 'DISABLED',            3, 'GROW', 4, 'SHRINK', 5, 'SHRINK_CANCEL', NULL),      decode(st.lastmode, 1, 'MANUAL', 2, 'DEFERRED', 3, 'IMMEDIATE', NULL),      st.lasttime, st.gransize, st.con_id      from x$kmgsct st
+++GV$MEMORY_RESIZE_OPS+++            select op.inst_id, gv.component,     decode(op.opcode, 0, 'STATIC', 1, 'INITIALIZING', 2, 'DISABLED',           3, 'GROW', 4, 'SHRINK', 5, 'SHRINK_CANCEL', NULL),     decode(op.opmode, 1, 'MANUAL', 2, 'DEFERRED', 3, 'IMMEDIATE', NULL),     pn.name, op.initsize * gv.gransize, op.targsize * gv.gransize,      op.realsize * gv.gransize,     decode(op.status, 0, 'INACTIVE', 1, 'PENDING', 2, 'COMPLETE',           3, 'CANCELLED', 4, 'ERROR', 5, 'ERROR', 6, 'ERROR',           7, 'CANCELLED', 8, 'CANCELLED', NULL),     op.starttime, op.endtime, op.con_id   from x$kmgsop op, x$kmgsct gv, v$parameter pn   where (op.grantype = gv.grantype)     and (op.parno = pn.num)     order by op.starttime
+++GV$MEMORY_TARGET_ADVICE+++         select A.inst_id, A.memsz,                                                     round((A.memsz / A.base_memsz), 4),                                           decode(A.base_estd_dbtime,0,to_number(null),                                   round(A.base_dbtime * round((A.dbtime / A.base_estd_dbtime), 4), 0)),        decode(A.base_estd_dbtime,0,to_number(null),                                   round((A.dbtime / A.base_estd_dbtime), 4)),                                   A.version, A.con_id                                                         from x$kmgsbsmemadv A                                                         order by A.inst_id, A.memsz
+++GV$METRIC+++                       SELECT inst_id, begtime, endtime, intsize_csec,          groupid, eid, eidsq, metricid, name, value, unit, con_id          FROM   x$kewmdrmv          WHERE flag1 = 1
+++GV$METRICGROUP+++                  SELECT inst_id, groupid, name, intsize, maxintv, con_id          FROM   x$kewmgsm
+++GV$METRICNAME+++                   SELECT d.inst_id, d.groupid, g.name, d.metricid,            d.name, d.unit, d.con_id          FROM   x$kewmdsm d, x$kewmgsm g          where d.groupid = g.groupid
+++GV$METRIC_HISTORY+++               SELECT inst_id, begtime, endtime, intsize_csec,            groupid, eid, eidsq, metricid, name, value, unit, con_id          FROM   x$kewmdrmv
+++GV$MTTR_TARGET_ADVICE+++           select distinct inst_id, mttr_v,                                         decode(status, 0, 'OFF', 4, 'ON', 'READY'),                              decode(dirty_limit, 0, to_number(NULL), dirty_limit),                    decode(factored_sim_writes, -1, to_number(NULL), factored_sim_writes),   decode(base_real_nondirect_writes, 0, to_number(NULL),                          decode(factored_sim_writes, -1, to_number(NULL),                                round((factored_sim_writes / base_real_nondirect_writes),                      4))),                                                decode(total_writes, -1, to_number(NULL), total_writes),                 decode(base_total_writes, 0, to_number(NULL),                                   decode(total_writes, -1, to_number(NULL),                                       round((total_writes / base_total_writes), 4))),            decode(total_ios, -1, to_number(NULL), total_ios),                       decode(base_total_ios, 0, to_number(NULL),                                      decode(total_ios, -1, to_number(NULL),                                          round((total_ios / base_total_ios), 5))),                  con_id from x$kcbmmav
+++GV$MUTEX_SLEEP+++                  select INST_ID, MUTEX_TYPE, LOCATION, SLEEPS, WAIT_TIME, CON_ID from x$MUTEX_SLEEP
+++GV$MUTEX_SLEEP_HISTORY+++          select INST_ID, MUTEX_IDENTIFIER, SLEEP_TIMESTAMP, MUTEX_TYPE, GETS, SLEEPS, REQUESTING_SESSION, BLOCKING_SESSION, LOCATION, MUTEX_VALUE, P1, P1RAW, P2, P3, P4, P5, CON_ID from x$MUTEX_SLEEP_HISTORY
+++GV$MVREFRESH+++                    select inst_id, sid_knst, serial_knst, currmvowner_knstmvr, currmvname_knstmvr, con_id from x$knstmvr x where type_knst=6 and exists (select 1 from v$session s where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$MYSTAT+++                       select inst_id,ksusenum,ksusestn,ksusestv,con_id from x$ksumysta where bitand(ksspaflg,1)!=0 and bitand(ksuseflg,1)!=0 and ksusestn<(select ksusgstl from x$ksusgif)
+++GV$NFS_CLIENTS+++                  SELECT inst_id, NFSCLIENTID, NFSPRINCIPAL, NFSOPAQUECLIENT,            NFSVERIFIER, NFSLEASEEXPIRY, NFSCLIENTNETID || NFSCLIENTADDR,            decode(bitand(NFSFLAGS,1), 1, 'TRUE', 'FALSE'), CON_ID          FROM X$NFSCLIENTS
+++GV$NFS_LOCKS+++                    SELECT inst_id, NFSOPENSTATEID, NFSOPENSEQNO, NFSLOCKSTATEID,            NFSLOCKSEQNO, NFSLOCKOWNER,            NFSLOCKOFFSET, NFSLOCKLENGTH, NFSLOCKTYPE, CON_ID          FROM X$NFSLOCKS
+++GV$NFS_OPEN_FILES+++               SELECT inst_id, NFSCLIENTID, NFSOPENOWNER, NFSOPENSTATEID,            NFSOPENFILEHANDLE, NFSOPENSEQID,            decode(bitand(NFSOPENFLAGS,1), 0, 'FALSE', 'TRUE'),            decode(bitand(NFSOPENFLAGS,2), 0, 'FALSE', 'TRUE'),            decode(bitand(NFSOPENFLAGS,384), 384, 'SharedReadWrite', 128, 'SharedRead', 256, 'SharedWrite'),            decode(bitand(NFSOPENFLAGS,1536), 1536, 'DenyReadWrite', 512, 'DenyRead', 1024, 'DenyWrite'),            decode(bitand(NFSOPENFLAGS,64), 0, 'FALSE', 'TRUE'), CON_ID          FROM X$NFSOPENS
+++GV$NLS_PARAMETERS+++               select inst_id,parameter, value, con_id from x$nls_parameters where parameter != 'NLS_SPECIAL_CHARS'
+++GV$NLS_VALID_VALUES+++             select inst_id,parameter, value, decode (isdeprecated, 0, 'FALSE', 'TRUE'), con_id from x$ksulv
+++GV$NONLOGGED_BLOCK+++              select cor.inst_id, cor.blkfno, cor.blksblk, cor.blktot, cor.blkscn,  cor.blkbtm, cor.blkescn, cor.blketm,  to_number(ic.icprs),  to_date(ic.icrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  decode(cor.blkobjid, 4294967295, NULL, cor.blkobjid),  'UNKNOWN',  cor.con_id  from x$kccblkcor cor left outer join x$kccic ic on cor.blkicrid = ic.icrid  where bitand(cor.blktype, 255) = 6
+++GV$OBJECT_DEPENDENCY+++            select d.inst_id,d.kglhdpar, d.kglnahsh,         o.kglnaown, o.kglnaobj, o.kglhdadr, o.kglnahsh, o.kglobtyp, d.con_id from x$kglob o, x$kgldp d  where o.kglnahsh = d.kglrfhsh  and  o.kglhdadr = d.kglrfhdl
+++GV$OBJECT_DML_FREQUENCIES+++       SELECT INST_ID, OBJNAME, WORKING, SLOT0, SLOT1, SLOT2, SLOT3, SLOT4, SLOT5, SLOT6, SLOT7, SLOT8, SLOT9, SLOT10, SLOT11, SLOT12, SLOT13, SLOT14, SLOT15, SLOT16, SLOT17, SLOT18, SLOT19, SLOT20, SLOT21, SLOT22, SLOT23, SLOT24, CON_ID FROM X$KSXM_DFT
+++GV$OBSOLETE_PARAMETER+++           select inst_id,kspponm,decode(ksppoval,0,'FALSE','TRUE'), con_id  from x$ksppo
+++GV$OFFLINE_RANGE+++                select x$kccor.inst_id,orrid,orstm,ordfp,to_number(orofs),to_number(orons),  to_date(oront,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  to_number(orrls),  to_date(orrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), con_id  from x$kccor
+++GV$OFSMOUNT+++                     select inst_id, ofs_mntpath, ofs_path, ofs_mntopts,         decode(flags, 1, 'MOUNTED'), con_id from x$ofsmount
+++GV$OFS_STATS+++                    select inst_id, ofs_mntpnt, ofs_lookup, ofs_forget, ofs_getattr,          ofs_setattr, ofs_readlink, ofs_symlink, ofs_mknod, ofs_mkdir,          ofs_unlink, ofs_rmdir, ofs_rename, ofs_link, ofs_open, ofs_read,          ofs_write, ofs_statfs, ofs_release, ofs_fsync, ofs_setxattr,          ofs_getxattr, ofs_listxattr, ofs_removexattr, ofs_flush, ofs_init,          ofs_opendir, ofs_readdir, ofs_releasedir, ofs_fsyncdir, ofs_getlk,          ofs_setlk, ofs_setlkw, ofs_access, ofs_create, ofs_interrupt,          ofs_bmap, ofs_destroy, ofs_bytes_read, ofs_bytes_written, con_id          from x$ofs_stats
+++GV$OPEN_CURSOR+++                  select inst_id,kgllkuse, kgllksnm, user_name, kglhdpar, kglnahsh,                    kgllksqlid, kglnaobj, kgllkest,                                               decode(kgllkexc, 0, to_number(NULL), kgllkexc), kgllkctp,                     kgllkhdl, con_id                                                       from x$kgllk where kglhdnsp = 0 and kglhdpar != kgllkhdl
+++GV$OPTIMIZER_PROCESSING_RATE+++    SELECT INST_ID, ADDR,           STATNAME_KKECSTATS, M_VALUE,          C_VALUE, D_VALUE, CON_ID FROM          (SELECT ADDR, INST_ID, CON_ID, STATID_KKECSTATS,                  STATNAME_KKECSTATS, STATVALUE_KKECSTATS,                  ORIGIN_KKECSTATS FROM X$OPTIM_CALIB_STATS) PIVOT          (min(STATVALUE_KKECSTATS) AS VALUE FOR          (ORIGIN_KKECSTATS) IN          ('ORIGIN_MANUAL' AS M,           'ORIGIN_CALIB' AS C,           'ORIGIN_DEFAULT' as D))
+++GV$OPTION+++                       select inst_id,parameter, value, con_id from x$option
+++GV$OSSTAT+++                       select INST_ID,        KSUCPUSTATNAME,       decode(KSUCPUSTATID,               15, KSUCPUSTATVALUE/1024,               KSUCPUSTATVALUE),        KSUCPUSTATID,        KSUCPUSTATCMT,        decode(bitand(KSUCPUSTATFLAGS,1),1,'YES','NO'),        CON_ID   from X$KSUCPUSTAT union all select INST_ID,        KSUVMSTATNAME,        KSUVMSTATVALUE,        KSUVMSTATID,        KSUVMSTATCMT,        decode(bitand(KSUVMSTATFLAGS,1),1,'YES','NO'),        CON_ID   from X$KSUVMSTAT union all select INST_ID,        KSUNETSTATNAME,        KSUNETSTATVALUE,        KSUNETSTATID,        KSUNETSTATCMT,        decode(bitand(KSUNETSTATFLAGS,1),1,'YES','NO'),        CON_ID   from X$KSUNETSTAT
+++GV$PARALLEL_DEGREE_LIMIT_MTH+++    select inst_id, policy_name_kgskdopp, con_id from x$kgskdopp
+++GV$PARAMETER+++                    select x.inst_id,x.indx+1,ksppinm,ksppity,ksppstvl, ksppstdvl, ksppstdfl,  ksppstdf, decode(bitand(ksppiflg/256,1),1,'TRUE','FALSE'),  decode(bitand(ksppiflg/65536,3),1,'IMMEDIATE',2,'DEFERRED',                                  3,'IMMEDIATE','FALSE'),  decode(bitand(ksppiflg/524288,1),1,'TRUE','FALSE'), decode(bitand(ksppiflg,4),4,'FALSE',                                     decode(bitand(ksppiflg/65536,3), 0, 'FALSE', 'TRUE')),     decode(bitand(ksppstvf,7),1,'MODIFIED',4,'SYSTEM_MOD','FALSE'),  decode(bitand(ksppstvf,2),2,'TRUE','FALSE'),  decode(bitand(ksppilrmflg/64, 1), 1, 'TRUE', 'FALSE'),  decode(bitand(ksppilrmflg/268435456, 1), 1, 'TRUE', 'FALSE'),  ksppdesc, ksppstcmnt, ksppihash, x.con_id  from x$ksppi x, x$ksppcv y where (x.indx = y.indx) and  bitand(ksppiflg,268435456) = 0 and  ((translate(ksppinm,'_','#') not like '##%') and    ((translate(ksppinm,'_','#') not like '#%')      or (ksppstdf = 'FALSE') or      (bitand(ksppstvf,5) > 0)))
+++GV$PARAMETER2+++                   select x.inst_id,kspftctxpn,ksppinm,ksppity,kspftctxvl,  kspftctxdvl, kspftctxdf,  decode(bitand(ksppiflg/256,1),1,'TRUE','FALSE'),  decode(bitand(ksppiflg/65536,3),1,'IMMEDIATE',2,'DEFERRED',                                  3,'IMMEDIATE','FALSE'),  decode(bitand(ksppiflg/524288,1),1,'TRUE','FALSE'),  decode(bitand(ksppiflg,4),4,'FALSE',                                     decode(bitand(ksppiflg/65536,3), 0, 'FALSE', 'TRUE')),     decode(bitand(kspftctxvf,7),1,'MODIFIED',4,'SYSTEM_MOD','FALSE'),  decode(bitand(kspftctxvf,2),2,'TRUE','FALSE'),  decode(bitand(ksppilrmflg/64, 1), 1, 'TRUE', 'FALSE'),  decode(bitand(ksppilrmflg/268435456, 1), 1, 'TRUE', 'FALSE'),  ksppdesc, kspftctxvn, kspftctxct, x.con_id  from x$ksppi x, x$ksppcv2 y  where ((x.indx+1) = kspftctxpn) and  ((translate(ksppinm,'_','#') not like '##%') and    ((translate(ksppinm,'_','#') not like '#%')      or (kspftctxdf = 'FALSE') or      (bitand(kspftctxvf,5) > 0)))
+++GV$PARAMETER_VALID_VALUES+++       SELECT INST_ID, PARNO_KSPVLD_VALUES, NAME_KSPVLD_VALUES, ORDINAL_KSPVLD_VALUES, VALUE_KSPVLD_VALUES, ISDEFAULT_KSPVLD_VALUES, CON_ID FROM X$KSPVLD_VALUES WHERE TRANSLATE(NAME_KSPVLD_VALUES,'_','#') NOT LIKE '#%'
+++GV$PATCHES+++                      select inst_id, patchid_ksirpinfo, con_id from x$ksirpinfo
+++GV$PDBS+++                         select inst_id, con_id, dbid, con_uid, guid, name,         decode(state, 0, 'MOUNTED', 1, 'READ WRITE', 2, 'READ ONLY',                3, 'MIGRATE'),         decode(restricted, 0, 'NO', 1, 'YES'),         stime, create_scn, total_size, block_size,         decode(recovery_status, 0, 'ENABLED', 1, 'DISABLED'),         snapshot_parent_con_id from x$con where con_id > 1
+++GV$PDB_INCARNATION+++              select inst_id, DBINC, PDBINC, decode(bitand(STATUS, 15), 1, 'CURRENT', 2, 'PARENT', 4, 'ORPHAN'), INCSCN, INCTIME, BRSCN, BRTIME, ERSCN, ERTIME,          PR_DBINC, decode(PR_PDBINC_NULL, 1, NULL, PR_PDBINC), decode(FB_ALLOWED, 1, 'YES', 'NO'), con_id from x$kcpdbinc
+++GV$PERSISTENT_PUBLISHERS+++        select p.inst_id, p.queue_id, q.queue_schema, q.queue_name,  p.publisher_name, p.publisher_address, p.protocol,  p.enqueued_msgs, p.elapsed_enqueue_time/10000, p.enqueue_cpu_time/10000,  p.last_enqueue_time, p.enqueue_transactions, p.con_id  from x$persistent_publishers p, x$persistent_queues q  where p.inst_id = q.inst_id and p.queue_id = q.queue_id and  ((p.con_id = q.con_id) or (p.con_id is null and q.con_id is null))
+++GV$PERSISTENT_QMN_CACHE+++         select INST_ID, QUEUE_TABLE, JOB_TYPE, FLAGS, NEXT_SVC_TIME,         WINDOW_END_TIME, TOTAL_RUNS, TOTAL_LATENCY,         TOTAL_ELAPSED_TIME/10000, TOTAL_CPU_TIME/10000,         TMGR_ROWS_PROCESSED, TMGR_ELAPSED_TIME/10000,         TMGR_CPU_TIME/10000, LAST_TMGR_PROCESSING_TIME,         DEQLOG_ROWS_PROCESSED, DEQLOG_PROCESSING_ELAPSED_TIME/10000,         DEQLOG_PROCESSING_CPU_TIME/10000, LAST_DEQLOG_PROCESSING_TIME,         DEQUEUE_INDEX_BLOCKS_FREED, HISTORY_INDEX_BLOCKS_FREED,         TIME_INDEX_BLOCKS_FREED, INDEX_CLEANUP_COUNT,         INDEX_CLEANUP_ELAPSED_TIME/10000, INDEX_CLEANUP_CPU_TIME/10000,         LAST_INDEX_CLEANUP_TIME, CON_ID  from X$KWQMNJIT
+++GV$PERSISTENT_QUEUES+++            select inst_id, queue_id, queue_table_id, queue_schema, queue_name, first_activity_time, enqueued_msgs, dequeued_msgs,  browsed_msgs, elapsed_enqueue_time/10000,  elapsed_dequeue_time/10000, enqueue_cpu_time/10000, dequeue_cpu_time/10000,  avg_msg_age, dequeued_msg_latency,  elapsed_transformation_time/10000,  elapsed_rule_evaluation_time/10000, enqueued_expiry_msgs, enqueued_delay_msgs, msgs_made_expired, msgs_made_ready,  last_enqueue_time, last_dequeue_time, last_tm_expiry_time,  last_tm_ready_time, enqueue_transactions, dequeue_transactions,  execution_count, oldest_msgid, oldest_msg_enqtm, con_id  from x$persistent_queues
+++GV$PERSISTENT_SUBSCRIBERS+++       select s.inst_id, s.queue_id, q.queue_schema, q.queue_name,  s.subscriber_id, s.subscriber_name,  s.subscriber_address, s.protocol, s.subscriber_type,  s.first_activity_time, s.enqueued_msgs, s.dequeued_msgs,  s.avg_msg_age, s.browsed_msgs, s.expired_msgs,  s.dequeued_msg_latency, s.last_enqueue_time, s.last_dequeue_time,  s.elapsed_dequeue_time/10000, s.dequeue_cpu_time/10000,  s.dequeue_transactions, s.execution_count, s.dequeue_memory_locks,  s.dequeue_disk_locks, s.dequeue_disk_deletes,  s.oldest_msgid, s.oldest_msg_enqtm, s.con_id  from x$persistent_subscribers s, x$persistent_queues q  where s.inst_id = q.inst_id and s.queue_id = q.queue_id and  ((s.con_id = q.con_id)or (s.con_id is null and q.con_id is null))
+++GV$PGASTAT+++                      select INST_ID,           QESMMSGANM,           decode( QESMMSGAUN, 3, (QESMMSGAVL*QESMMSGAMU)/100,                   QESMMSGAVL*QESMMSGAMU),            decode( QESMMSGAUN, 0, 'bytes', 1, 'microseconds', 3, 'percent', ''),           CON_ID    from   X$QESMMSGA    where  QESMMSGAVS = 1
+++GV$PGA_TARGET_ADVICE+++            select INST_ID,           PAT_PRED * 1024,           round(PAT_PRED/PAT_CURR, 4),           decode(status, 0, 'OFF', 'ON'),           BYTES_PROCESSED * 1024,                   ESTD_TIME,                                EXTRA_BYTES_RW * 1024,                    round(decode(BYTES_PROCESSED+EXTRA_BYTES_RW, 0, 0,                  (BYTES_PROCESSED*100)/(BYTES_PROCESSED+EXTRA_BYTES_RW))),           OVERALLOC,           CON_ID    from   X$QESMMAPADV
+++GV$PGA_TARGET_ADVICE_HISTOGRAM+++  select INST_ID,           PAT_PRED * 1024,           round(PAT_PRED/PAT_CURR, 4),           decode(status, 0, 'OFF', 'ON'),           LOWBND * 1024,           (HIBND * 1024)-1,           OPTIMAL,           ONEPASS,           MPASS,           MPASS+ONEPASS+OPTIMAL,           IGNORED,           CON_ID    from   X$QESMMAHIST
+++GV$PING+++                         WITH bh AS (SELECT b.inst_id, file#, dbablk block#, class class#,                     decode(state,0,'free',1,'xcur',2,'scur',3,'cr',                            4,'read',5,'mrec',6,'irec',7,'write',8,'pi',                            9,'memory',10,'mwrite',11,'donated',                            12,'protected', 13,'securefile', 14,'siop',                            15,'recckpt', 16, 'flashfree',                            17, 'flashcur', 18, 'flashna') status,                     0 xnc, 0 forced_reads, 0 forced_writes,                     b.le_addr lock_element_addr, le_id1 lock_element_name,                     obj objd, b.con_id              FROM x$bh b, x$le le              WHERE b.le_addr = le.le_addr (+))  SELECT bh.inst_id,         bh.file#,         bh.block#,         bh.class#,         bh.status,         bh.xnc,         bh.forced_reads,         bh.forced_writes,         ob.name,         ob.subname partition_name,         decode (ob.type#,  1, 'INDEX',                            2, 'TABLE',                            3, 'CLUSTER',                            4, 'VIEW',                            5, 'SYNONYM',                            6, 'SEQUENCE',                            7, 'PROCEDURE',                            8,  'FUNCTION',                            9, 'PACKAGE',                           10, 'NON-EXISTENT',                           11, 'PACKAGE BODY',                           12, 'TRIGGER',                           13, 'TYPE',                           14, 'TYPE BODY',                           19, 'TABLE PARTITION',                           20, 'INDEX PARTITION',                           21, 'LOB',                           22, 'LIBRARY',                           28, 'JAVA SOURCE',                           29, 'JAVA CLASS',                           30, 'JAVA RESOURCE',                           56, 'JAVA DATA',                           'UNKNOWN') kind,         ob.owner#,         lock_element_addr,         lock_element_name,         bh.con_id  FROM   bh, obj$ ob  WHERE  (bh.objd = ob.dataobj#) AND         (bh.forced_reads + bh.forced_writes) > 0  UNION ALL  SELECT bh.inst_id,         bh.file#,         bh.block#,         bh.class#,         bh.status,         bh.xnc,         bh.forced_reads,         bh.forced_writes,         un.name,         NULL             partition_name,         'UNDO'           kind,         un.user#         owner#,         lock_element_addr,         lock_element_name,         bh.con_id  FROM   bh, undo$ un  WHERE  (bh.class# >= 11) AND         (un.us# = floor((bh.class# - 11) / 2)) AND         (bh.forced_reads + bh.forced_writes) > 0
+++GV$POLICY_HISTORY+++               select inst_id,          decode(policy_event, 0,'none',1,'glru_on',2,'glru_off',          3,'policy_on',4,'policy_off',5,'initiate_affinity',6,'grab_affinity',          7,'push_affinity',8,'initiate_read_mostly',9,'grab_read_mostly',          10,'dissolve_affinity',11,'dissolve_read_mostly',12,'drop_dissolve',          14,'collision_dissolve',15,'table_dissolve',16,'anti_dissolve',          17,'temp_affinity',18,'persistent_read_mostly',19,'tsn_affinity',          20,'tsn_dissolve'),          database_id, tablespace_id, data_object_id,          target_instance_number, event_date, con_id          from x$policy_history
+++GV$PQ_SESSTAT+++                   select inst_id, kxfpssnam, kxfpssval, kxfpsstot, con_id from x$kxfpsst
+++GV$PQ_SLAVE+++                     select inst_id,kxfpdpnam, decode(bitand(kxfpdpflg, 16), 0, 'BUSY', 'IDLE'),  kxfpdpses, floor(kxfpdpcit / 6000), floor(kxfpdpcbt / 6000),  floor(kxfpdpcct / 100), kxfpdpclsnt + kxfpdpcrsnt,  kxfpdpclrcv + kxfpdpcrrcv,  floor((kxfpdptit + kxfpdpcit) / 6000),  floor((kxfpdptbt + kxfpdpcbt) / 6000),  floor((kxfpdptct + kxfpdpcct) / 100),  kxfpdptlsnt + kxfpdpclsnt + kxfpdptrsnt + kxfpdpcrsnt,  kxfpdptlrcv + kxfpdpclrcv + kxfpdptrrcv + kxfpdpcrrcv, con_id  from x$kxfpdp where bitand(kxfpdpflg, 8) != 0
+++GV$PQ_SYSSTAT+++                   select inst_id, rpad(kxfpysnam,30), kxfpysval, con_id from x$kxfpys
+++GV$PQ_TQSTAT+++                    select inst_id, kxfqsqn, kxfqsid, rpad(kxfqsty,10), kxfqscnt, kxfqslen, kxfqset, kxfqsavl, kxfqsdw, kxfqsdt, rpad(kxfqssid,6), kxfqsiid, con_id from x$kxfqsrow
+++GV$PROCESS+++                      select inst_id, addr, indx, ksuprosid, ksuprpid, ksuprthrid, ksuprext,   ksuprpname, ksuprunm, ksuprser, ksuprtid, ksuprpnm, ksuprtfi, ksuprtfn,  decode(bitand(ksuprflg,2),0,null,1), decode(ksllawat,hextoraw('00'),null,ksllawat), decode(ksllaspn,hextoraw('00'),null,ksllaspn), ksuprpum,ksuprpnam+ksuprpram,ksuprpfm, case when ksuprpnam+ksuprpram > ksuprpmm       then ksuprpnam+ksuprpram       else ksuprpmm end,  con_id  from x$ksupr where bitand(ksspaflg,1)!=0
+++GV$PROCESS_GROUP+++                SELECT indx, inst_id, ksupgpnm, ksupgpid, con_id FROM x$ksupgp
+++GV$PROCESS_MEMORY+++               select inst_id, ksmpgst_pid, ksmpgst_ser, ksmpgst_catname, ksmpgst_alloc,         decode(ksmpgst_used, 0, to_number(null), 1, 0, ksmpgst_used),         decode(ksmpgst_maxal, 0, to_number(null), 1, 0, ksmpgst_maxal), con_id  from x$ksmpgst where bitand(ksmpgst_paflg,1)!=0 and         (ksmpgst_alloc > 0 or ksmpgst_used > 1 or ksmpgst_maxal > 1)         order by inst_id, ksmpgst_pid, ksmpgst_catidx
+++GV$PROCESS_MEMORY_DETAIL+++        select inst_id, ksmpgdst_pid, ksmpgdst_ser, ksmpgdst_catname,  ksmpgdst_comment, ksmpgdst_heapname, ksmpgdst_bytes_alloc,  ksmpgdst_num_alloc, ksmpgdst_ds, ksmpgdst_parent_ds, con_id  from x$ksmpgdst where bitand(ksmpgdst_paflg,1)!=0 and         (ksmpgdst_bytes_alloc > 0)         order by inst_id, ksmpgdst_pid, ksmpgdst_bytes_alloc
+++GV$PROCESS_MEMORY_DETAIL_PROG+++   select inst_id, ksmpgdp_pid, ksmpgdp_ser, ksmpgdp_status, con_id  from x$ksmpgdp where bitand(ksmpgdp_paflg,1)!=0         order by inst_id, ksmpgdp_pid
+++GV$PROPAGATION_RECEIVER+++         select inst_id, kwqpdsqs, kwqpdsqn, kwqpddbn,         decode(bitand(max(kwqpdflg), 1), 1, max(kwqpddqs), null),         decode(bitand(max(kwqpdflg), 1), 1, max(kwqpddqn), null),         min(kwqpdtim),         decode(bitand(max(kwqpdflg), 2), 0, max(kwqpdhwm), 0),         min(kwqpdack), max(kwqpdhwm), max(kwqpdmsg), min(kwqpdupc)/10000,         min(kwqpdrul)/10000, (min(kwqpdenq) - min(kwqpdupc) - min(kwqpdrul))/10000,         kwqpdsid, kwqpdser, kwqpdospid, kwqpdprpn,         decode(bitand(max(kwqpdflg), 4), 4, decode(max(kwqpdstate),           0, 'Initializing',           1, 'Sending unapplied txns',           2, 'Waiting for message from client',           3, 'Receiving LCRs',           4, 'Evaluating rules',           5, 'Enqueueing LCRS',           6, 'Waiting for memory',           7, 'Waiting for apply to read',           8, 'Waiting for message from propagation sender',  null), 'Normal'),       max(kwqpdlrmpos), min(kwqpdackpos), con_id  from x$kwqpd group by inst_id, kwqpdsqs, kwqpdsqn, kwqpddbn, kwqpdsid,       kwqpdser, kwqpdospid, kwqpdprpn, kwqpdstate, con_id
+++GV$PROPAGATION_SENDER+++           select s.inst_id, s.kwqpsqid, q.queue_schema, q.queue_name,         s.kwqpsdqs, s.kwqpsdqn, s.kwqpstim,         s.kwqpsdbn, s.kwqpshwm, s.kwqpsack, s.kwqpsstt,         s.kwqpsmsg, s.kwqpsbyt, s.kwqpsdeq/10000, s.kwqpspic/10000,         (s.kwqpsprp - s.kwqpsdeq - s.kwqpspic)/10000, s.kwqpsrl/10000,         s.kwqpsmmsg, s.kwqpsmbyt, s.kwqpslmsglat , s.kwqpslmsgenqtime,         CAST(s.kwqpslmsgenqtime + s.kwqpslmsglat/86400 AS TIMESTAMP),         s.kwqpsllcrlat, s.kwqpsllcrts,         s.kwqpsllcrts + s.kwqpsllcrlat/86400, s.kwqpsddbnm,         s.kwqpssid, s.kwqpsser, s.kwqpsospid, s.kwqpsprpn,         decode(s.kwqpsstt, 'SCHEDULE OPTIMIZED',           decode(kwqpsstate,             0, 'Initializing',             1, 'Capturing change records',             2, 'Evaluating rules',             3, 'Enqueueing LCRs',             4, 'Shutting down',             5, 'Aborting',             6, 'Creating LCRs',             7, 'Waiting for dictionary dump',             8, 'Waiting for redo log',             9, 'Pausing for flow control',            10, 'Processing dictionary dump',            11, 'Waiting for apply to be enabled',            12, 'Waiting for apply database to start',            13, 'Waiting for propagation to be enabled',            14, 'Waiting for previously connected capture to terminate',            15, 'Waiting for a subscriber to be added',            16, 'Suspended due to a dropped subscriber',            17, 'Suspended for auto split/merge',            18, 'Waiting on empty queue',           100, 'Initializing',           101, 'Initializing propagation receiver',           102, 'Browsing LCRs',           103, 'Evaluating rules',           104, 'Dequeueing LCRs',           105, 'Sending LCRs',           111, 'Waiting for apply to be enabled',           112, 'Waiting for apply database to start',           113, 'Waiting for propagation to be enabled',           114, 'Waiting for capture to terminate',           115, 'Waiting for a subscriber to be added',           116, 'Suspended due to a dropped subscriber',           117, 'Suspended for auto split/merge',           118, 'Waiting on empty queue',           null), s.kwqpsstt),         s.con_id  from x$kwqps s, x$buffered_queues q  where s.inst_id = q.inst_id and s.kwqpsqid = q.queue_id  and bitand(q.flags, 16) = 0  and (s.con_id = q.con_id or (s.con_id is null and q.con_id is null))
+++GV$PROXY_ARCHIVEDLOG+++            select inst_id,pcrid,pcstm,pcdev,pchdl,pccmt,pcmdh,pcmpl,pctag,decode(bitand(pcflg, 1+2+4),0,'A',1,'D',2,'X',4,'U','?'),decode(bitand(pcflg,1),1,'YES','NO'),pathp,paseq,to_number(parls),to_date(parlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(palos),to_date(palot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(panxs),to_date(panxt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),pabct,pabsz,to_date(pctsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_date(pctim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),abs((to_date(pctim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')- to_date(pctsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'))*86400), pcrsi, pcrst, decode(bitand(paflg, 1), 1, 'YES', 'NO'), decode(bitand(paflg, 1792), 0, 'NO',                               'YES'),to_date(pakpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(paflg, 1792), 256,  'LOGS',                            512,  'NOLOGS',                            1024, 'BACKUP_LOGS',                                   NULL),con_id from x$kccpa
+++GV$PROXY_DATAFILE+++               select inst_id,pcrid,pcstm,pcdev,pchdl,pccmt,pcmdh,pcmpl,pctag,decode(bitand(pcflg, 1+2+4),0,'A',1,'D',2,'X',4,'U','?'),decode(bitand(pcflg,1),1,'YES','NO'),pddfp,to_number(pdcrs),to_date(pdcrt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(pdrls),to_date(pdrlc,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(pdcps),to_date(pdcpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_number(pdafs),to_number(pdrfs),to_date(pdrft,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(pdflg, 1),1,0,NULL),decode(bitand(pdflg, 2),0,'NO','YES'),decode(bitand(pdflg, 4),0,'NO','YES'),pdfsz,pdbsz,pdlor,to_date(pctsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),to_date(pctim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),abs((to_date(pctim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')- to_date(pctsm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'))*86400), decode(pddfp, 0, decode(bitand(pcflg,8),8,'S','B'), NULL), decode(bitand(pdflg, 1792), 0, 'NO',                                           'YES'),          to_date(pdkpt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),decode(bitand(pdflg, 1792), 256,  'LOGS',                                   512,  'NOLOGS',                                 1024, 'BACKUP_LOGS',                                    NULL),       pcrsi, pcrst, pcfdi, decode(bitand(pdflg, 16), 0, 'NO', 'YES'), pcplus, pcprls, pcprlt, con_id, decode(bitand(pdflg, 32), 0, 'NO', 'YES') from x$kccpd
+++GV$PWFILE_USERS+++                 select inst_id,username,decode(sysdba,1,'TRUE','FALSE'),  decode(sysoper,1,'TRUE','FALSE'), decode(sysasm,1,'TRUE','FALSE'),  decode(sysbackup,1,'TRUE','FALSE'), decode(sysdg,1,'TRUE','FALSE'),  decode(syskm,1,'TRUE','FALSE'), con_id  from x$kzsrt where valid=1  and username != 'INTERNAL'
+++GV$PX_BUFFER_ADVICE+++             select inst_id, rpad(kxfpnsnam,30), kxfpnsval, con_id from x$kxfpns where indx = 4  or indx >= 14
+++GV$PX_INSTANCE_GROUP+++            select pig.inst_id, kxfppigpig, decode(kxfppigsrc, 1, 'PARALLEL_INSTANCE_GROUP', 2, 'SERVICE', NULL), kxfpiginst, pig.con_id from x$kxfppig pig, x$kxfpig ig  where pig.kxfppigpig = ig.kxfpigig
+++GV$PX_PROCESS+++                   select a.inst_id, a.kxfpdpnam,  decode(bitand(a.kxfpdpflg, 16), 0, 'IN USE', 'AVAILABLE'),  b.pid, a.kxfpdpspid, c.sid, c.serial#,  decode(bitand(a.kxfpdpflg, 512), 0, 'FALSE', 'TRUE'), a.con_id  from x$kxfpdp a, V$PROCESS b, V$SESSION c  where bitand(kxfpdpflg, 8) != 0 and  a.kxfpdpspid = b.SOSID and  a.kxfpdpspid = c.PROCESS(+)
+++GV$PX_PROCESS_SYSSTAT+++           select inst_id, rpad(kxfpnsnam,30), kxfpnsval, con_id from x$kxfpns where indx < 15
+++GV$PX_PROCESS_TRACE+++             select        a.inst_id, a.kxfbbtime, b.pid, a.kxfbbspid, a.kxfbbslv, a.kxfbbpnam,  a.kxfbbses, a.kxfbbqcin, a.kxfbbqcsid, a.kxfbbset, a.kxfbbslv, a.kxfbbcomp,  a.kxfbbfile, a.kxfbbline, a.kxfbbfunc, a.kxfbbtrc, a.con_id  from x$kxfbbox a, v$process b  where a.kxfbbspid = b.sosid
+++GV$PX_SESSION+++                   select  a.inst_id,  a.addr,  a.indx,  a.ksuseser,  decode(b.kxfpdpqcsid,NULL,a.indx,b.kxfpdpqcsid),  b.kxfpdpqcser,  b.kxfpdpcin,  b.kxfpdpsvgrp,  b.kxfpdpsvset,  b.kxfpdpsvnum,  b.kxfpdpadg,  b.kxfpdprdg,  a.con_id from  x$ksuse  a,  x$kxfpdp b where  bitand(a.ksspaflg,1)!=0 and  bitand(a.ksuseflg,1)!=0 and  a.ksuseqcsid > 0 and  a.ksusepro = b.kxfpdppro(+)
+++GV$PX_SESSTAT+++                   select  a.inst_id,  a.addr,  a.indx,  a.ksuseser,  decode(b.kxfpdpqcsid,NULL,a.indx,b.kxfpdpqcsid),  b.kxfpdpqcser,  b.kxfpdpcin,  b.kxfpdpsvgrp,  b.kxfpdpsvset,  b.kxfpdpsvnum,  b.kxfpdpadg,  b.kxfpdprdg,  c.ksusestn,  c.ksusestv,  a.con_id from  x$ksuse    a, x$kxfpdp   b, x$ksusesta c where  bitand(a.ksspaflg,1)!=0 and  bitand(a.ksuseflg,1)!=0 and  a.KSUSEQCSID > 0 and  a.ksusepro = b.kxfpdppro(+) and  a.indx = c.ksusenum and  c.ksusestn < (select  ksusgstl from x$ksusgif)
+++GV$QMON_COORDINATOR_STATS+++       select INST_ID, OPID_KWQMNC,         decode (STATUS_KWQMNC, 0, 'DEAD',                                1, 'INITIALIZING',                                2, 'RUNNING TASK COORDINATOR',                                3, 'WAITING',                                4, 'ADDING SERVER',                                NULL),         NSLAVES_KWQMNC, LASTSLVSTTIM_KWQMNC, LASTSLVOPID_KWQMNC,         NEXTWAKETIM_KWQMNC, RDYTM_KWQMNC, EXPTM_KWQMNC,         LASTWAITTIM_KWQMNC, LASTFAILURE_KWQMNC, LASTFAILTIM_KWQMNC,         decode (NSLAVES_KWQMNC, 0, NULL, MAXLATENCY_KWQMNC),         decode (NSLAVES_KWQMNC, 0, NULL, MINLATENCY_KWQMNC),         TOTALLATENCY_KWQMNC, TOTALTASK_KWQMNC, MAXSLV_KWQMNC, CON_ID  from X$KWQMNC
+++GV$QMON_SERVER_STATS+++            select s.INST_ID, c.OPID_KWQMNC, s.OPID_KWQMNSCTX, s.PNAME_KWQMNSCTX,         decode (s.STATUS_KWQMNSCTX, 0, 'UNUSED',                                     1, 'RUNNING',                                     2, 'IDLE WAIT',                                     3, 'RUNNING',                                     4, 'RUNNING',                                     5, 'RUNNING',                                     6, 'EXITING',                                     7, 'NOT ACTIVE',                                     s.STATUS_KWQMNSCTX),         s.STTIME_KWQMNSCTX,         (case when (s.STATUS_KWQMNSCTX >= 3 and s.STATUS_KWQMNSCTX <= 5)               then (select stat.TASKNAME_KWQMNCTID                       from X$KWQMNTASKSTAT stat                       where stat.TASKID_KWQMNCTID = s.TSKID_KWQMNSCTX and                             stat.INST_ID = s.INST_ID)               else NULL end),         (case when (s.STATUS_KWQMNSCTX >= 3 and s.STATUS_KWQMNSCTX <= 5)               then s.TSKNUM_KWQMNSCTX               else NULL end),         (case when (s.STATUS_KWQMNSCTX >= 3 and s.STATUS_KWQMNSCTX <= 5)               then s.TSKSTTIME_KWQMNSCTX               else NULL end),         s.LSTWTTM_KWQMNSCTX, s.MAXLAT_KWQMNSCTX, s.MINLAT_KWQMNSCTX,         s.TOTALLAT_KWQMNSCTX,         s.NUMTASK_KWQMNSCTX, s.LASTFAILURE_KWQMNSCTX, s.LASTFAILTIM_KWQMNSCTX,        (select stat.TASKNAME_KWQMNCTID            from X$KWQMNTASKSTAT stat            where stat.TASKID_KWQMNCTID = s.LASTFAILTSKID_KWQMNSCTX and                  stat.INST_ID = s.INST_ID),         s.LASTFAILTSKNUM_KWQMNSCTX, s.con_id  from X$KWQMNSCTX s, X$KWQMNC c  where s.STATUS_KWQMNSCTX <> 0 and        s.INST_ID = c.INST_ID
+++GV$QMON_TASKS+++                   select tsk.INST_ID, stat.TASKNAME_KWQMNCTID, tsk.TASK_NUMBER,         decode (stat.TASKTYPE_KWQMNCTID, 0, 'REPEATABLE_MULTIPLE',                                          1, 'REPEATABLE_SINGLE',                                          2, 'NONREPEATABLE_MULTIPLE',                                          3, 'NONREPEATABLE_SINGLE',                                          4, 'UNKNOWN',                                          stat.TASKTYPE_KWQMNCTID),         tsk.TASK_SUBMIT_TIME, tsk.TASK_READY_TIME, tsk.TASK_EXPIRY_TIME,         tsk.TASK_START_TIME, tsk.TASK_STATUS, tsk.SLAVE_NAME,         tsk.TASK_RETRY, tsk.TASK_RUNS, tsk.TASK_FAILURES, tsk.CON_ID  from X$KWQMNTASK tsk, X$KWQMNTASKSTAT stat  where tsk.TASK_ID = stat.TASKID_KWQMNCTID and        tsk.INST_ID = stat.INST_ID
+++GV$QMON_TASK_STATS+++              select INST_ID, TASKNAME_KWQMNCTID,         decode (TASKTYPE_KWQMNCTID, 0, 'REPEATABLE_MULTIPLE',                                     1, 'REPEATABLE_SINGLE',                                     2, 'NONREPEATABLE_MULTIPLE',                                     3, 'NONREPEATABLE_SINGLE',                                     4, 'UNKNOWN',                                     TASKTYPE_KWQMNCTID),         LASTCRTTSKNUM_KWQMNCTID, TOTAL_TASK_KWQMNCTID,         TOTAL_RUNTIME_KWQMNCTID, TOTAL_RUNS_KWQMNCTID,         TOTAL_FAILURES_KWQMNCTID, METRICNAME_KWQMNCTID,         METRICVAL_KWQMNCTID, LASTFAILURE_KWQMNCTID, LASTFAILTIM_KWQMNCTID,         LASTFAILTSKNUM_KWQMNCTID, REMARK_KWQMNCTID, CON_ID  from X$KWQMNTASKSTAT
+++GV$QPX_INVENTORY+++                select  INST_ID,         NODE_NAME,         CON_ID   from X$KQPXINV
+++GV$QUEUE+++                        select inst_id,kmcqspro,decode(bitand(kmcqstyp,1),1,'COMMON','DISPATCHER'), kmcqsncq,kmcqswat,kmcqstnc, con_id from x$kmcqs where bitand(kmcqsflg,1) = 1 and bitand(kmcqstyp,3) != 0 and (bitand(kmcqstyp,8) = 8 or bitand(kmcqstyp,2) = 2 or kmcqstnc > 0)
+++GV$QUEUEING_MTH+++                 select inst_id, policy_name_kgskquep, con_id from x$kgskquep
+++GV$RECOVERY_FILE_STATUS+++         select fn.inst_id, fn.fnfno, fn.fnnam, decode(nvl(mf.cps, 0), 0, 'NOT RECOVERED', 281474976710655, 'CURRENT', 'IN RECOVERY'),fn.con_id  from x$kcrmx mx, x$kccfn fn, x$kccfe fe, x$kcrmf mf where fn.fntyp = 4 and mf.fno(+) = fn.fnfno and ((bitand(mx.flg,2) != 0 and fe.fedup != 0) or mf.fno = fn.fnfno) and fe.fenum = fn.fnfno and fn.fnnam is not null
+++GV$RECOVERY_LOG+++                 select inst_id,lhthp,lhseq, to_date(lhlot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),  nvl(lhnam, alnam), con_id  from x$kcclh,       (select althp, alseq, alrls, alrlc, alnam /* filter out duplicate al */          from (select althp, alseq, alrls, alrlc, alnam, alstm, alrid,                       max(alstm) over /* get latest archivelog */                          (partition by althp, alseq, alrls, alrlc) almstm,                       max(alrid) over  /* filter out duplicate stamp */                          (partition by althp, alseq, alrls, alrlc,                                        alstm) almrid                  from x$kccal                 where bitand(alflg, 8) = 0    /* standby_dest = NO */                   and bitand(alflg, 2) = 2    /* archived = YES */                   and bitand(alflg, 1) = 0)   /* deleted = NO */          where alrid = almrid            and alstm = almstm)  where lhthp = althp (+)    and lhseq = alseq (+)    and lhrls = alrls (+)    and lhrlc = alrlc (+)    and to_number(lhnxs) > (select min(to_number(fhscn)) from x$kcvfhmrr where hxerr = 0) and lhseq not in (select leseq from x$kccle where lethr = lhthp) and to_number(lhlos) < (select max(to_number(hxsts)) from x$kcvfhmrr where hxerr = 0)
+++GV$RECOVERY_PROGRESS+++            select inst_id,   to_date(ksulostm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),   ksulopna, ksulotde, ksulouni, ksulosfr, ksulotot,   to_date(ksuloinft, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),   '', con_id from x$ksulop where ksulopna like '% Recovery'                 and ksulotde != 'Last Applied Redo' union select inst_id,   to_date(ksulostm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),   ksulopna, ksulotde, ksulouni, 0, 0,   to_date(ksuloinft, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),   ksuloif1d||ltrim((ksuloif1 || ksuloif2d || to_char(ksuloif2, 'FM0000000')), '0'),   con_id                                                          from x$ksulop where ksulopna like '% Recovery'                 and ksulotde = 'Last Applied Redo' order by 1, 2 DESC, 5 ASC, 4 ASC
+++GV$RECOVERY_STATUS+++              select fx.inst_id, to_date(mx.ckptim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), mx.thr, mx.seq, mx.los, to_date(mx.tim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), nvl(mx.nam, 'NONE'), decode(bitand(mx.mrs, 256 + 128 + 64 + 8), 8, 'RELEASE', 64, 'WRONG LOG', 128, 'MISSING NAME', 256, 'UNNEEDED NAME', 'NONE'), decode(nvl(fx.err, 3), 1, 'NEED LOG', 3, 'END OF THREAD', 4, 'LOG REUSED', 'UNKNOWN'), mx.con_id  from x$kcrmx mx, x$kcrfx fx where fx.thr(+) = mx.thr
+++GV$RECOVER_FILE+++                 select inst_id,hxfil, decode(hxons, 0, 'OFFLINE', 'ONLINE'),decode(hxons, 0, 'OFFLINE', 'ONLINE'), decode(hxerr, 0,'',1,'FILE MISSING', 2,'OFFLINE NORMAL', 3,'NOT VERIFIED', 4,'FILE NOT FOUND',5,'CANNOT OPEN FILE', 6,'CANNOT READ HEADER', 7,'CORRUPT HEADER',8,'WRONG FILE TYPE', 9,'WRONG DATABASE', 10,'WRONG FILE NUMBER',11,'WRONG FILE CREATE', 12,'WRONG FILE CREATE', 16,'DELAYED OPEN','UNKNOWN ERROR'), to_number(fhscn),  to_date(fhtim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), con_id from x$kcvfhmrr
+++GV$REDO_DEST_RESP_HISTOGRAM+++     select inst_id,  DEST_ID,  TIME,  DURATION,  FREQUENCY,  CON_ID  from x$kcrrnhg
+++GV$REPLAY_CONTEXT+++               select inst_id,kxsreplayctxid,kxsreplaysnum,kxsreplayendian,        kxsreplaypver,kxsreplaysize,kxsreplayhsh,        kxsreplaydbid,kxsreplayehsh,kxsreplaytzint,kxsreplaychksum,        kxsreplayscn,kxsreplayrlscn,kxsreplayrlcnt,kxsreplaynssa,        kxsreplaynseq,kxsreplayiseq,kxsreplayndate,kxsreplayidate,        kxsreplayntime,kxsreplayitime,kxsreplaynguid,kxsreplayiguid,        kxsreplaynlob,kxsreplayilob,con_id  from x$kxsreplay
+++GV$REPLAY_CONTEXT_LOB+++           select inst_id,kxsreplaylobctxid,kxsreplaylobid,kxsreplaylobverbsn,        kxsreplaylobverwrp,decode(kxsreplaylobmatched, 0, 'N','Y'), con_id  from x$kxsreplaylob
+++GV$REPLAY_CONTEXT_SEQUENCE+++      select inst_id,kxsreplayseqctxid,kxsreplayseqhsh,kxsreplayseqnum,        kxsreplayseqidx,kxsreplayseqval, con_id  from x$kxsreplayseq
+++GV$REPLAY_CONTEXT_SYSDATE+++       select inst_id,kxsreplaydatectxid,kxsreplaydateval,        decode(kxsreplaydateused, 0, 'N','Y'), con_id  from x$kxsreplaydate
+++GV$REPLAY_CONTEXT_SYSGUID+++       select inst_id,kxsreplayguidctxid,kxsreplayguidval,        decode(kxsreplayguidused, 0, 'N','Y'), con_id  from x$kxsreplayguid
+++GV$REPLAY_CONTEXT_SYSTIMESTAMP+++  select inst_id,kxsreplaytimectxid,kxsreplaytimeval,        decode(kxsreplaytimeused, 0, 'N','Y'), con_id  from x$kxsreplaytime
+++GV$REPLPROP+++                     select inst_id, sid_knst, serial_knst, decode(type_knst, 3, 'Replication Parallel Prop Slave'|| slavenum_knstrpp, 4, 'Replication Parallel Prop Coordinator'), dblink_knstrpp, decode(state_knstrpp, 0, NULL, 1, 'WAIT', 2, 'SLEEP', 3, 'PUSH', 4, 'PURGE' , 5, 'CREATE ERROR', 6, 'SCHEDULE TXN'), decode(type_knst, 4, NULL, xid_knstrpp), sequence_knstrpp, con_id from x$knstrpp x where type_knst in (3,4) and exists (select 1 from v$session s where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$REPLQUEUE+++                    select inst_id, txns_enqueued_knstrqu, calls_enqueued_knstrqu, txns_purged_knstrqu, last_enqueue_time_knstrqu,last_purge_time_knstrqu, con_id  from x$knstrqu
+++GV$REQDIST+++                      select inst_id,kmmrdbuc,sum(kmmrdcnt), con_id from x$kmmrd where kmmrdpro!=hextoraw('00') group by inst_id,kmmrdbuc,con_id
+++GV$RESERVED_WORDS+++               select inst_id, keyword, length,          decode(mod(trunc(type/2),2),0,'N',1,'Y','?') reserved,          decode(mod(trunc(type/4),2),0,'N',1,'Y','?') res_type,          decode(mod(trunc(type/8),2),0,'N',1,'Y','?') res_attr,          decode(mod(trunc(type/16),2),0,'N',1,'Y','?') res_semi,          decode(mod(trunc(type/32),2),0,'N',1,'Y','?') duplicate,          con_id          from x$kwddef
+++GV$RESOURCE+++                     select inst_id,addr,ksqrsidt,ksqrsid1,ksqrsid2, con_id from x$ksqrs where bitand(ksqrsflg,2)!=0
+++GV$RESOURCE_LIMIT+++               select inst_id, ksurlmnm, ksurlmcv, ksurlmmv,  LPAD(decode(bitand(ksurlmfg, 1), 0, to_char(ksurlmia), 'UNLIMITED'),10),  LPAD(decode(bitand(ksurlmfg, 2), 0, to_char(ksurlmlv), 'UNLIMITED'),10),  con_id from x$ksurlmt
+++GV$RESTORE_POINT+++                select rsp.inst_id,                  to_number(rsp.rspscn), rsp.rspincarn,                  decode(bitand(rsp.rspflags, 1), 1, 'YES', 'NO'),                  to_number(rsp.rsplgsz),                  to_timestamp(rsp.rsptime,                              'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),                  to_timestamp(decode(bitand(rsp.rspflags, 8), 0, NULL,                                      rsp.rsprsptime),                              'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),                  'YES',                  rsp.rspname,                  rsp.con_id           from  x$kccrsp rsp           where bitand(rsp.rspflags, 2) != 0           union all           select rsp.inst_id,                  to_number(rsp.nrsscn), rsp.nrsincarn,                  'NO',                  0,                  to_timestamp(rsp.nrstime,                              'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),                  to_timestamp(decode(bitand(rsp.nrsflags, 8), 0, NULL,                                      rsp.nrsrsptime),                              'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),                  'NO',                  rsp.nrsname,                  rsp.con_id           from  x$kccnrs rsp           where bitand(rsp.nrsflags, 2) != 0
+++GV$RESULT_CACHE_DEPENDENCY+++      select  INST_ID,             QESRCDEP_RID,        QESRCDEP_DID,        QESRCDEP_OBJ,         CON_ID from x$qesrcdep
+++GV$RESULT_CACHE_DR+++              select  INST_ID,             QESRCDR_OBJ,         CON_ID from x$qesrcdr
+++GV$RESULT_CACHE_MEMORY+++          select  INST_ID,             QESRCMEM_LAD,        QESRCMEM_CNK,        QESRCMEM_BLK,        decode(QESRCMEM_STA, 0, 'NO', 1, 'YES'),        decode(QESRCMEM_STA, 0, QESRCMEM_OID, NULL),        decode(QESRCMEM_STA, 0, QESRCMEM_POS, NULL),         CON_ID from x$qesrcmem
+++GV$RESULT_CACHE_OBJECTS+++         select  INST_ID,                 QESRCOBJ_MEM_LAD, decode(QESRCOBJ_CAC_TYP, 1,'Result', 2,'Dependency','Other'), decode(QESRCOBJ_RSE_STA, 1,decode(QESRCOBJ_RSE_BYP,0,'New','Bypass'),2,'Published',3,'Invalid',4,'Expired','Other'),        QESRCOBJ_CAC_BUC,        QESRCOBJ_CAC_HSV,        QESRCOBJ_CAC_NAM, decode(QESRCOBJ_CAC_NSP, 0, 'SQL', 1, 'PLSQL', 2, 'API', 3, 'AUTO', 4, 'TABLE', 5, 'KEY VECTOR', 6, 'CDB'),        QESRCOBJ_CAC_DAT,        QESRCOBJ_CAC_UID,        QESRCOBJ_DEP_DCT,        QESRCOBJ_RSE_BCT,        QESRCOBJ_CAC_SCN,        QESRCOBJ_RSE_CCT,        QESRCOBJ_RSE_PCT,        QESRCOBJ_RSE_SCT,        QESRCOBJ_RSE_RCT,        QESRCOBJ_RSE_RMX,        QESRCOBJ_RSE_RMN,        QESRCOBJ_RSE_RAG,        QESRCOBJ_RSE_ETM,        QESRCOBJ_RSE_POS,        QESRCOBJ_DEP_OBJ,        QESRCOBJ_DEP_INV,        QESRCOBJ_RSE_SPO,        QESRCOBJ_RSE_SPU,        QESRCOBJ_CAC_CID,        QESRCOBJ_CAC_KEY,        QESRCOBJ_RSE_CKS,        QESRCOBJ_RSE_EDT, decode(QESRCOBJ_RSE_REM, 1, 'Yes', 'No'),        CON_ID from x$qesrcobj
+++GV$RESULT_CACHE_RD+++              select  INST_ID,             QESRCRD_KEY,         QESRCRD_BNO,         QESRCRD_BSQ,         QESRCRD_BDT,          CON_ID from x$qesrcrd
+++GV$RESULT_CACHE_RR+++              select  INST_ID,             QESRCRR_HV1,         QESRCRR_HV2,         CON_ID from x$qesrcrr
+++GV$RESULT_CACHE_STATISTICS+++      select  INST_ID,             INDX + 1,        QESRCSTA_NAM,        decode(QESRCSTA_VLO, QESRCSTA_VHI, to_char(QESRCSTA_VLO),               QESRCSTA_VLO||'-'||QESRCSTA_VHI),         CON_ID from x$qesrcsta
+++GV$RESUMABLE+++                    select inst_id, ktrsfaddr, ktrsfsid, decode (bitand(ktrsfflg, 1), 0, 'NO', 'YES'), decode (ktrsfsta, 0, 'NORMAL', 1, 'SUSPENDED', 2, 'TIMEOUT', 3, 'ERROR', 4, 'ABORTED', ''), ktrsftmo, ktrsfspt, ktrsfrst, ktrsfnam, ktrsferr, ktrsfep1, ktrsfep2, ktrsfep3, ktrsfep4, ktrsfep5, ktrsfems, con_id from x$ktrso
+++GV$RFS_THREAD+++                   select INST_ID, THREAD#, RESETLOG_SCN, RESETLOG#, LAST_REDO_SEQ#, LAST_REDO_BLK#, LAST_REDO_TIME, LOW_GAP_SCN, LOW_GAP_TIME, LAST_PING_TIME, CON_ID FROM x$krfsthrd
+++GV$RMAN_COMPRESSION_ALGORITHM+++   SELECT inst_id, id_krbmca, algname_krbmca, decode(lowvsn_krbmca, '', NULL, lowvsn_krbmca), decode(highvsn_krbmca, '', NULL, highvsn_krbmca), algdesc_krbmca, algvsn_krbmca, DECODE(isvalid_krbmca, 0, 'NO', 'YES'), DECODE(bitand(flags_krbmca, 1), 0, 'NO', 'YES'), DECODE(isdefault_krbmca, 0, 'NO', 'YES'), con_id FROM x$krbmca
+++GV$RMAN_CONFIGURATION+++           select INST_ID, RMRNO, RMNAM, RMVAL, CON_ID from X$KCCRM where RMNAM is not null
+++GV$RMAN_ENCRYPTION_ALGORITHMS+++   select inst_id, id, algname, algdesc, decode(isdefault, 0, 'NO', 'YES'), decode(restore_only, 0, 'NO', 'YES'), con_id from x$krbza
+++GV$RMAN_OUTPUT+++                  select userenv('Instance'),SID_KRBMROT, ROWNO_KRBMROT, MTS_KRBMROT, L0ID_KRBMROT,L0TS_KRBMROT,TXT_KRBMROT, ID_KRBMROT, STAMP_KRBMROT,  L0ID_KRBMROT SESSION_KEY, CON_ID from x$krbmrot order by L0ID_KRBMROT, L0TS_KRBMROT,  MTS_KRBMROT,ROWNO_KRBMROT
+++GV$RMAN_STATUS_CURRENT+++          select userenv('Instance'), SID_KRBMRST, ID_KRBMRST, STAMP_KRBMRST,          decode(LEVEL_KRBMRST, 0, to_number(NULL), PID_KRBMRST),         decode(LEVEL_KRBMRST, 0, to_number(NULL), PTS_KRBMRST),        L0ID_KRBMRST,  L0TS_KRBMRST, LEVEL_KRBMRST,         decode(LEVEL_KRBMRST, 0, 'SESSION',                               1, 'COMMAND',                                  'RECURSIVE OPERATION'),         CMDID_KRBMRST, UPPER(OPER_KRBMRST),         decode(STATUS_KRBMRST, 1, 'RUNNING',                              1+8, 'RUNNING WITH WARNINGS',                             1+16, 'RUNNING WITH ERRORS',                           1+8+16, 'RUNNING WITH ERRORS',                                   'NEVER-GET-THIS-VALUE'),         0,  to_date(START_KRBMRST,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_date(END_KRBMRST,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), con_id  from x$krbmrst where status_krbmrst in (1, 1+8, 1+16, 1+8+16)
+++GV$ROLLSTAT+++                     select inst_id,kturdusn,kturdlat,kturdext,kturdsiz,kturdwrt,kturdnax, kturdget,kturdwat,decode(kturdopt, -1,to_number(null),kturdopt), kturdhwm,kturdnsh,kturdnwp,kturdnex,kturdash,kturdaae, decode(bitand(kturdflg,7), 0,'ONLINE', 2,'PENDING OFFLINE', 3,'OFFLINE',         4, 'FULL', 'UNKNOWN'), kturdcex, kturdcbk, con_id from x$kturd where kturdsiz != 0 and               bitand(kturdflg,7) != 3
+++GV$ROWCACHE+++                     select inst_id,kqrstcid,decode(kqrsttyp,1,'PARENT','SUBORDINATE'), decode(kqrsttyp,2,kqrstsno,null),kqrsttxt,kqrstcsz,kqrstusg,kqrstfcs, kqrstgrq,kqrstfastgrq,kqrstgmi,kqrstsrq,kqrstsmi,kqrstsco,kqrstmrq, kqrstmfl,kqrstilr,kqrstifr,kqrstisr, con_id from x$kqrst
+++GV$ROWCACHE_PARENT+++              select inst_id, indx, kqrfphsh, kqrfpadd, kqrfpcid, kqrfpcnm,  decode(bitand(kqrfpflg, 1), 0, 'Y', 'N'),  kqrfpmod, kqrfpreq, kqrfptxn, kqrfpses, kqrfpirq, kqrfpirl,  kqrfpity, kqrfpii1, kqrfpii2, kqrfpkey, con_id from x$kqrfp
+++GV$ROWCACHE_SUBORDINATE+++         select inst_id, indx, kqrfshsh, kqrfsadd, kqrfscid, kqrfssid, kqrfssnm,  decode(bitand(kqrfsflg, 1), 0, 'Y', 'N'), kqrfspar,  kqrfskey, con_id from x$kqrfs
+++GV$RO_USER_ACCOUNT+++              SELECT INST_ID, USERID, PASSW_EXPIRED, PASSW_IN_GRACE, PASSW_LOCKED, PASSW_LOCK_UNLIM, FAILED_LOGINS, EXPIRATION_AFTER_GRACE, PASSW_LOCK_TIME, CON_ID FROM X$RO_USER_ACCOUNT
+++GV$RSRCMGRMETRIC+++                SELECT m.inst_id, m.begtime, m.endtime, m.intsize_csec,                 p.seq_kskplw, c.consumer_group_id_kgskscs,                 c.name_kgskscs,                 m.cpu_consumed_time, m.cpu_wait_time,                 p.num_cpus_kskplw,                 c.util_limit_kgskscs * p.num_cpus_kskplw / 100,                 m.cpu_consumed_time / 60000, m.cpu_wait_time / 60000,                 decode(p.tot_cpus_kskplw, 0, 100,                        (p.num_cpus_kskplw * c.util_limit_kgskscs /                         p.tot_cpus_kskplw)),                 decode(p.tot_cpus_kskplw, 0, 0,                        (m.cpu_consumed_time / 600 / p.tot_cpus_kskplw)),                 0, 0, 0,                 m.io_requests, m.io_megabytes,                 m.pq_active_time / 60000, m.pq_queued_time / 60000,                 m.ps_active_time / 60000, m.ps_queued_time / 60000,                 c.max_pq_srvs_kgskscs, p.name_kskplw, c.con_id          FROM x$kewmrmgmv m, x$kskplw p, x$kgskscs c          WHERE flag1 = 1            AND (bitand(m.rmid, 4294901760) / 65536) =                 decode(p.con_id, null, 0, p.con_id)            AND (bitand(m.rmid, 65280) / 256) = (bitand(p.seq_kskplw, 255))            AND (bitand(m.rmid, 4294901760) / 65536) =                 decode(c.con_id, null, 0, c.con_id)            AND (bitand(m.rmid, 65280) / 256) = (bitand(c.seq_kgskscs, 255))            AND (bitand(m.rmid, 255)) = c.num_kgskscs
+++GV$RSRCMGRMETRIC_HISTORY+++        SELECT m.inst_id, m.begtime, m.endtime, m.intsize_csec,                 p.seq_kskplw, c.consumer_group_id_kgskscs,                 c.name_kgskscs,                 m.cpu_consumed_time, m.cpu_wait_time,                 p.num_cpus_kskplw,                 c.util_limit_kgskscs * p.num_cpus_kskplw / 100,                 m.cpu_consumed_time / 60000, m.cpu_wait_time / 60000,                 decode(p.tot_cpus_kskplw, 0, 100,                        (p.num_cpus_kskplw * c.util_limit_kgskscs /                         p.tot_cpus_kskplw)),                 decode(p.tot_cpus_kskplw, 0, 0,                        (m.cpu_consumed_time / 600 / p.tot_cpus_kskplw)),                 0, 0, 0,                 m.io_requests, m.io_megabytes,                 m.pq_active_time / 60000, m.pq_queued_time / 60000,                 m.ps_active_time / 60000, m.ps_queued_time / 60000,                 c.max_pq_srvs_kgskscs, p.name_kskplw, c.con_id          FROM x$kewmrmgmv m, x$kskplw p, x$kgskscs c          WHERE (bitand(m.rmid, 4294901760) / 65536) =                 decode(p.con_id, null, 0, p.con_id)            AND (bitand(m.rmid, 65280) / 256) = (bitand(p.seq_kskplw, 255))            AND (bitand(m.rmid, 4294901760) / 65536) =                 decode(c.con_id, null, 0, c.con_id)            AND (bitand(m.rmid, 65280) / 256) = (bitand(c.seq_kgskscs, 255))            AND (bitand(m.rmid, 255)) = c.num_kgskscs
+++GV$RSRC_CONSUMER_GROUP+++          SELECT A.inst_id, A.name_kgskcft, A.class_id_kgskcft,                     A.current_count_kgskcft, A.runnable_count_kgskcft,                        A.total_count_kgskcft, A.cpu_wait_kgskcft, A.cpu_waits_kgskcft,           A.total_used_kgskcft, A.yields_kgskcft,                                   0,                                                                        0,                                                                        0,                                                                        A.num_queued_kgskcft,                                                     A.undo_consump_kgskcft, A.active_limit_hit_kgskcft,                       A.undo_limit_hit_kgskcft,                                                 A.swch_in_time_kgskcft, A.swch_out_time_kgskcft,                          A.swch_in_mb_kgskcft, A.swch_out_mb_kgskcft,                              A.swch_in_reqs_kgskcft, A.swch_out_reqs_kgskcft,                          A.swch_in_iolog_kgskcft, A.swch_out_iolog_kgskcft,                        A.swch_in_elap_kgskcft, A.swch_out_elap_kgskcft,                          A.call_aborted_kgskcft, A.actv_sess_killed_kgskcft,                       A.idle_sess_killed_kgskcft, A.idlblkr_sess_kld_kgskcft,                   A.queued_time_kgskcft, A.queue_timeouts_kgskcft,                          wtime, wreq, sbrdata, sbwdata, mbrdata, mbwdata,                          sbrreqs, sbwreqs, mbrreqs, mbwreqs,                                       A.current_pq_count_kgskcft, A.current_pq_dop_kgskcft,                     A.parallel_limit_hit_kgskcft, A.tot_pq_qry_kgskcft,                       A.tot_pq_dop_kgskcft, A.pq_active_time_kgskcft,                           A.current_pqs_queued_kgskcft, A.pq_queued_time_kgskcft,                   A.pq_queue_timeouts_kgskcft, A.con_id                                     FROM x$kgskcft A                                                          INNER JOIN                                                                   (SELECT B.inst_id, B.consumer_group_id_ksfdstcg, B.con_id,                   sum(WTIME_KSFDSTCG + A_WTIME_KSFDSTCG/1000) as wtime,                        sum(WREQS_KSFDSTCG + A_WREQS_KSFDSTCG) as wreq,                              sum(round((SBRDATA_KSFDSTCG + A_SBRDATA_KSFDSTCG)/2048)) as sbrdata,         sum(round((SBWDATA_KSFDSTCG + A_SBWDATA_KSFDSTCG)/2048)) as sbwdata,         sum(round((MBRDATA_KSFDSTCG + A_MBRDATA_KSFDSTCG)/2048)) as mbrdata,         sum(round((MBWDATA_KSFDSTCG + A_MBWDATA_KSFDSTCG)/2048)) as mbwdata,         sum(SBRREQS_KSFDSTCG + A_SBRREQS_KSFDSTCG) as sbrreqs,                       sum(SBWREQS_KSFDSTCG + A_SBWREQS_KSFDSTCG) as sbwreqs,                       sum(MBRREQS_KSFDSTCG + A_MBRREQS_KSFDSTCG) as mbrreqs,                       sum(MBWREQS_KSFDSTCG + A_MBWREQS_KSFDSTCG) as mbwreqs                        FROM x$ksfdstcg B                                                            GROUP BY B.inst_id, B.consumer_group_id_ksfdstcg, B.con_id) C                ON A.class_id_kgskcft = C.consumer_group_id_ksfdstcg                      and (A.con_id is null or A.con_id = C.con_id)
+++GV$RSRC_CONSUMER_GROUP_CPU_MTH+++  select inst_id, policy_name_kgskcp, con_id from x$kgskcp
+++GV$RSRC_CONS_GROUP_HISTORY+++      select inst_id,          seq_kgskscs,          consumer_group_id_kgskscs,          name_kgskscs,          requests_kgskscs,          cpu_wait_time_kgskscs,          cpu_waits_kgskscs,          consumed_cpu_time_kgskscs,          yields_kgskscs,          0,          0,          0,          active_sess_limit_hit_kgskscs,          undo_limit_hit_kgskscs,          swch_in_time_kgskscs, swch_out_time_kgskscs,          swch_in_mb_kgskscs, swch_out_mb_kgskscs,          swch_in_reqs_kgskscs, swch_out_reqs_kgskscs,          swch_in_iolog_kgskscs, swch_out_iolog_kgskscs,          swch_in_elap_kgskscs, swch_out_elap_kgskscs,          sql_canceled_kgskscs,          active_sess_killed_kgskscs,          idle_sess_killed_kgskscs,          idle_blkr_sess_killed_kgskscs,          queued_time_kgskscs,          queue_time_outs_kgskscs,          wtime_kgskscs, wreqs_kgskscs,          round(sbrdata_kgskscs / 2048), round(sbwdata_kgskscs / 2048),          round(mbrdata_kgskscs / 2048), round(mbwdata_kgskscs / 2048),          sbrreqs_kgskscs, sbwreqs_kgskscs,          mbrreqs_kgskscs, mbwreqs_kgskscs,          tot_pq_qry_kgskscs, tot_pq_dop_kgskscs,          parallel_limit_hit_kgskscs, pq_active_time_kgskscs,          pq_queued_time_kgskscs, pq_queue_time_outs_kgskscs,          con_id          from x$kgskscs
+++GV$RSRC_PLAN+++                    select inst_id, plan_id_kgskpft, name_kgskpft,          decode(is_top_plan_kgskpft, 0, 'FALSE', 'TRUE'),          decode(cpu_rm_kgskpft, 0, 'OFF', 'ON'),          decode(instance_caging_kgskpft, 0, 'OFF', 'ON'),          act_dop_kgskpft, tot_dop_kgskpft,          pqq_status_kgskpft, con_id,          dir_type_kgskpft, shares_kgskpft, util_lim_kgskpft,          pq_lim_kgskpft, (memory_min_kgskpft / 100),          (memory_lim_kgskpft / 100), profile_kgskpft          from x$kgskpft
+++GV$RSRC_PLAN_CPU_MTH+++            select inst_id, policy_name_kgskpp, con_id from x$kgskpp
+++GV$RSRC_PLAN_HISTORY+++            select inst_id,          plw.seq_kskplw,          decode(plw.id_kskplw, 0, to_number(null), plw.id_kskplw),          plw.name_kskplw,          plw.start_tm_kskplw,          plw.end_tm_kskplw,          decode(plw.window_id_kskplw, 0, 'FALSE', 'TRUE'),          o.name,          decode(plw.auto_switch_kskplw, 0, 'FALSE', 'TRUE'),          decode(plw.cpu_rm_kskplw, 0, 'OFF', 'ON'),          decode(plw.instance_caging_kskplw, 0, 'OFF', 'ON'),          plw.pqq_status_kskplw, plw.con_id          from x$kskplw plw, obj$ o          where plw.window_id_kskplw = o.obj#(+)
+++GV$RSRC_SESSION_INFO+++            select v.inst_id, sid_kgskvft,         class_id_kgskvft, cg_name_kgskvft,         orig_class_id_kgskvft,         orig_class_map_kgskvft, mapped_cg_name_kgskvft,         state_kgskvft,         decode(active_kgskvft, 1, 'TRUE', 0, 'FALSE', ''),         idle_time_kgskvft,         cur_cpu_wait_time_kgskvft, tot_cpu_wait_time_kgskvft,         cur_cpu_waits_kgskvft, tot_cpu_waits_kgskvft,         cur_cpu_time_kgskvft, tot_cpu_time_kgskvft,        cur_active_time_kgskvft, tot_active_time_kgskvft,         cur_queued_time_kgskvft, tot_queued_time_kgskvft,         cur_yields_kgskvft, tot_yields_kgskvft,         cur_undo_kgskvft, max_undo_kgskvft,         call_aborted_kgskvft, queue_timeouts_kgskvft,         est_exec_lmt_hit_kgskvft,         cur_io_service_time_kgskvft, tot_io_service_time_kgskvft,         cur_io_service_waits_kgskvft, tot_io_service_waits_kgskvft,         round(cur_sbrdata_kgskvft / 2048), round(tot_sbrdata_kgskvft / 2048),         round(cur_mbrdata_kgskvft / 2048), round(tot_mbrdata_kgskvft / 2048),         round(cur_sbwdata_kgskvft / 2048), round(tot_sbwdata_kgskvft / 2048),         round(cur_mbwdata_kgskvft / 2048), round(tot_mbwdata_kgskvft / 2048),         cur_sbrreqs_kgskvft, tot_sbrreqs_kgskvft,         cur_sbwreqs_kgskvft, tot_sbwreqs_kgskvft,         cur_mbrreqs_kgskvft, tot_mbrreqs_kgskvft,         cur_mbwreqs_kgskvft, tot_mbwreqs_kgskvft,         cur_pq_active_time_kgskvft, tot_pq_active_time_kgskvft,         dopreq_kgskvft, pq_servers_kgskvft, est_exec_time_kgskvft,         cur_pq_queued_time_kgskvft, tot_pq_queued_time_kgskvft,         pq_limit_hit_kgskvft, pq_queue_timeouts_kgskvft,         decode(pq_active_kgskvft, 1, 'TRUE', 0, 'FALSE', ''),         decode(status_kskqvft,                0, 'Queued', 1, 'Queue head - waiting on CG limit',                2, 'Queue head - waiting on PDB limit',                3, 'Queue head - waiting on service availability',                4, 'Queue head',                null, decode(pq_active_kgskvft, 1, 'Active',                             decode(pq_servers_kgskvft, 0, null, 'Queued'))),         v.cur_logical_ios_kgskvft, v.tot_logical_ios_kgskvft,         v.cur_elapsed_time_kgskvft, v.tot_elapsed_time_kgskvft,         v.last_action_kgskvft,         v.last_action_reason_kgskvft,         v.last_action_time_kgskvft,         v.con_id         from x$kgskvft v left join x$kskqvft q         on v.inst_id = q.qcinst_id_kskqvft and            v.sid_kgskvft = q.qcsid_kskqvft
+++GV$RT_ADDM_CONTROL+++              SELECT INST_ID,         ID, IMPACT ,CANDIDATE, LASTTIME,         CON_ID FROM X$KEHETSX WHERE IMPACT > 0 OR CANDIDATE > 0
+++GV$RULE+++                         select INST_ID, RULE_SET_OBJECT_ID, EVALUATION_CONTEXT_OBJECT_ID,  RULE_OWNER, RULE_NAME, RULE_CONDITION, TRUE_HITS, MAYBE_HITS,  SQL_EVALUATIONS, CON_ID from x$rule
+++GV$RULE_SET+++                     select INST_ID, OWNER, NAME, CPU_TIME, ELAPSED_TIME, FIRST_LOAD_TIME,  LAST_LOAD_TIME, LAST_LOADING_TIME, SHARABLE_MEM, RELOADS, INVALIDATIONS,  EVALUATIONS, FIRST_HIT_EVALUATIONS, SIMPLE_RULES_ONLY_EVALUATIONS,  SQL_FREE_EVALUATIONS, SQL_EXECUTIONS, CONDITIONS_PROCESSED, TRUE_RULES,  MAYBE_RULES, VARIABLE_VALUE_FUNCTION_CALLS, VARIABLE_METHOD_FUNCTION_CALLS,  EVALUATION_FUNCTION_CALLS, RESULT_CACHE_HITS,  decode(IS_RESULT_CACHE, 0, 'NO', 1, 'YES', 'NO'),  RESULT_CACHE_ELEMENTS, CON_ID from x$rule_set
+++GV$RULE_SET_AGGREGATE_STATS+++     select inst_id, name, value, con_id from x$kwrsnv
+++GV$SCHEDULER_INMEM_MDINFO+++       SELECT INST_ID, OBJID, PRGOID,         DECODE(BITAND(NULLIND, 4), 0, LAST_ENABLED_TIME, NULL),         CLSOID,         DECODE(BITAND(NULLIND, 16), 0, INSTANCE_ID, NULL),         FLAGS,         DECODE(BITAND(NULLIND, 64), 0, CREATOR, NULL),         DECODE(BITAND(NULLIND, 128), 0, CLIENT_ID, NULL),         DECODE(BITAND(NULLIND, 256), 0, GUID, NULL), CON_ID         FROM X$JSKMIMMD
+++GV$SCHEDULER_INMEM_RTINFO+++       SELECT INST_ID, USERID, OBJID, ID_TYPE, NAME,         DECODE(BITAND(NULLIND, 8), 0, NEXT_RUN_DATE, NULL),         DECODE(BITAND(NULLIND, 4096), 0, LAST_START_DATE, NULL),           DECODE(BITAND(NULLIND, 8192), 0, LAST_END_DATE, NULL),         RUN_COUNT, FAILURE_COUNT, RUNNING_INSTANCE, RUNNING_SLAVE,         JOB_STATUS, CON_ID FROM X$JSKMIMRT
+++GV$SCHEDULER_RUNNING_JOBS+++       select inst_id, session_id, session_serial_num, job_id,          paddr, os_process_id, CAST (numtodsinterval(session_stat_cpu/100,                  'second') AS INTERVAL DAY(3) TO SECOND(2)) session_stat_cpu, con_id          from x$jskslv
+++GV$SECUREFILE_TIMER+++             SELECT INST_ID, KDLU_STATNAME, KDLU_STATLAYERID, KDLU_STATMYTIME, KDLU_STATMAXTIME, KDLU_STATMINTIME, KDLU_STATINVOCATIONS, KDLU_STATLAYERNAME, CON_ID FROM X$KDLU_STAT
+++GV$SEGMENT_STATISTICS+++           select       s.inst_id,   u.name,      o.name,      o.subname,   ts.tsnam,    s.fts_tsn,   o.obj#,      o.dataobj#,  decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX',   2, 'TABLE', 3, 'CLUSTER',                     4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',       7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',  11, 'PACKAGE BODY', 12, 'TRIGGER',            13, 'TYPE', 14, 'TYPE BODY',                  19, 'TABLE PARTITION',                        20, 'INDEX PARTITION', 21, 'LOB',             22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',  28, 'JAVA SOURCE', 29, 'JAVA CLASS',          30, 'JAVA RESOURCE', 32, 'INDEXTYPE',         33, 'OPERATOR', 34, 'TABLE SUBPARTITION',     35, 'INDEX SUBPARTITION',                     40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',  42, 'MATERIALIZED VIEW',  43, 'DIMENSION',    44, 'CONTEXT', 47, 'RESOURCE PLAN',   48, 'CONSUMER GROUP',                 51, 'SUBSCRIPTION', 52, 'LOCATION',   55, 'XML SCHEMA', 56, 'JAVA DATA',    57, 'SECURITY PROFILE',     'UNDEFINED'),     s.fts_statnam,     s.fts_statid,      s.fts_staval,      s.con_id           from obj$ o, user$ u,           x$ksolsfts s, x$kccts ts  where o.owner# = u.user#   and s.fts_inte = 0        and s.fts_objn = o.obj#   and s.fts_tsn = ts.tstsn    and s.fts_objd = o.dataobj#     and o.linkname is null          and (o.type# not in (1  /* INDEX - handled below */,                        10 /* NON-EXISTENT */)        or                              (o.type# = 1                     and 1 = (select 1                        from ind$  i                    where i.obj# = o.obj#                         and i.type# in                              (1, 2, 3, 4, 6, 7, 8, 9))))   and o.name != '_NEXT_OBJECT'                and o.name != '_default_auditing_options_' union all    select       s.inst_id,   u.name,      o.name,      o.subname,   ts.tsnam,     s.fts_tsn,   t.ktssoobjn, t.ktssoobjd, decode(o.type#, 0, 'NEXT OBJECT', 1, 'INDEX',   2, 'TABLE', 3, 'CLUSTER',                     4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',       7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',  11, 'PACKAGE BODY', 12, 'TRIGGER',            13, 'TYPE', 14, 'TYPE BODY',                  19, 'TABLE PARTITION',                        20, 'INDEX PARTITION', 21, 'LOB',             22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',  28, 'JAVA SOURCE', 29, 'JAVA CLASS',          30, 'JAVA RESOURCE', 32, 'INDEXTYPE',         33, 'OPERATOR', 34, 'TABLE SUBPARTITION',     35, 'INDEX SUBPARTITION',                     40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',  42, 'MATERIALIZED VIEW', 43, 'DIMENSION',     44, 'CONTEXT', 47, 'RESOURCE PLAN',   48, 'CONSUMER GROUP',                 51, 'SUBSCRIPTION', 52, 'LOCATION',   55, 'XML SCHEMA', 56, 'JAVA DATA',    57, 'SECURITY PROFILE',     'UNDEFINED'),       s.fts_statnam,      s.fts_statid,       s.fts_staval,       s.con_id           from obj$ o, user$ u,        x$ksolsfts s, x$ktsso t,        x$kccts ts                where o.owner#   = u.user# and            s.fts_inte = 0 and                  s.fts_objn = o.obj# and             s.fts_tsn  = t.ktssotsnum and       s.fts_objn = t.ktssoobjn and        s.fts_objd = t.ktssoobjd and        s.fts_tsn  = ts.tstsn and             o.linkname is null and           (o.type# not in (1 /* INDEX - handled below */, 10 /* NON-EXISTENT */) or     (o.type# = 1 and 1 = (select 1 from ind$ i where i.obj# = o.obj# and       i.type# in (1, 2, 3, 4, 6, 7, 8, 9))))    and o.name != '_NEXT_OBJECT'    and o.name != '_default_auditing_options_'
+++GV$SEGSPACE_USAGE+++               SELECT inst_id,           TBS_ID, RFNO, bno, objd, USED_SPACE, uspscnbase, uspscnwrap, usptime,          ctime, total_alloc, total_dealloc,          delta_alloc, delta_dealloc, deltascn_base, deltascn_wrap,          deltaupd_time, delta_count, df_count, flag, con_id          FROM   X$KTSSPU
+++GV$SEGSTAT+++                      select inst_id,                                              fts_tsn,                                              fts_objn,                                             fts_objd,                                             fts_statnam,                                          fts_statid,                                           fts_staval,                                           con_id                                         from x$ksolsfts                                       where fts_inte = 0
+++GV$SEGSTAT_NAME+++                 select inst_id,                                              st_statid,                                            st_name,                                              decode(bitand(st_flag, 1), 0, 'NO', 1, 'YES'), con_id  from x$ksolsstat where bitand(st_flag, 2) <> 2
+++GV$SERVICEMETRIC+++                SELECT sm.inst_id, begtime, endtime, intsize_csec,            groupid, sv.kswsastabnmh, sv.kswsastabnm, ctmhash,            elapsedpercall, cpupercall, dbtimepercall, callspersec,            dbtimepersec,  goodness, delta, flags, sv.con_id          FROM   x$kewmsvcmv sm, x$kswsastab sv          WHERE flag1 = 1            AND sm.con_id = sv.con_id            AND sm.svcid = sv.kswsastabsi
+++GV$SERVICEMETRIC_HISTORY+++        SELECT sm.inst_id, begtime, endtime, intsize_csec,            groupid, sv.kswsastabnmh, sv.kswsastabnm,            ctmhash, elapsedpercall, cpupercall, dbtimepercall,            callspersec, dbtimepersec, sv.con_id          FROM   x$kewmsvcmv sm, x$kswsastab sv          WHERE sm.con_id = sv.con_id            AND sm.svcid = sv.kswsastabsi
+++GV$SERVICES+++                     select inst_id, kswsastabsi, kswsastabnm, kswsastabnmh, kswsastabnn, kswsastabcd, kswsastabcdh,  decode(kswsastabgoal, -1, NULL, 0, 'NONE', 1, 'SERVICE_TIME', 2, 'THROUGHPUT', NULL) kswsastabgoal,  decode(bitand(kswsastabpflg, 2), 2, 'Y', 'N') kswsastabpflg,  decode(bitand(kswsastabpflg, 4), 4, 'YES', 'NO'),  decode(bitand(kswsastabpflg, 8), 8, 'LONG', 'SHORT'),  decode(bitand(kswsastabpflg, 32), 32, 'YES', 'NO'),  kswsastabrettm, kswsastabreplayto,  decode(bitand(kswsastabpflg, 64), 64, 'YES', 'NO'),  kswsastabsessstate,  kswsastabpdb, kswsastabsqltrans, kswsastabmaxlagtime,  con_id  from x$kswsastab
+++GV$SERVICE_EVENT+++                select s.inst_id, s.kswsevtabnm, s.kswsevtabnmh, d.kslednam, d.ksledhash, s.kswsevtabwts, s.kswsevtabtmo, round(s.kswsevtabtim / 10000), round(s.kswsevtabtim / (10000 * s.kswsevtabwts)),  round(s.kswsevtabmxt / 10000),s.kswsevtabtim, s.con_id  from x$kswsevtab s, x$ksled d  where s.kswsevtabwts != 0 and s.kswsevtabnum = d.indx
+++GV$SERVICE_STATS+++                select s.inst_id, s.svchsh, s.svcnam, m.extid, m.sname, s.kewsval, s.con_id  from x$kewssvcv s, x$kewssmap m  where s.kewsoff = m.offst and m.aggid = 4
+++GV$SERVICE_WAIT_CLASS+++           select s.inst_id, s.kswsclstabnm, s.kswsclstabnmh, s.kswsclsid,  s.kswsclsnum, s.kswsclsname, s.kswsclswts, round(s.kswsclstim / 10000), s.con_id from x$kswsclstab s  where s.kswsclswts != 0
+++GV$SERV_MOD_ACT_STATS+++           select sma.inst_id, 'SERVICE_MODULE_ACTION', sma.srvnam, sma.modnam,    sma.actnam, m.extid, m.sname, sma.statval, sma.con_id  from x$kewesmas sma, x$kewssmap m  where sma.statpos = m.offst and m.aggid = 5       union all  select sm.inst_id, 'SERVICE_MODULE', sm.srvnam, sm.modnam, NULL, m.extid,    m.sname, sm.statval, sm.con_id  from x$kewesms sm, x$kewssmap m  where sm.statpos = m.offst and m.aggid = 7
+++GV$SESSION+++                      select s.inst_id,s.addr,s.indx,s.ksuseser,s.ksuudses,s.ksusepro,s.ksuudlui,s.ksuudlna,s.ksuudoct,s.ksusesow, decode(s.ksusetrn,hextoraw('00'),null,s.ksusetrn),decode(s.ksqpswat,hextoraw('00'),null,s.ksqpswat),decode(bitand(s.ksuseidl,11),1,'ACTIVE',0,decode(bitand(s.ksuseflg,4096),0,'INACTIVE','CACHED'),2,'SNIPED',3,'SNIPED', 'KILLED'),decode(s.ksspatyp,1,'DEDICATED',2,'SHARED',3,'PSEUDO',4,'POOLED','NONE'),  s.ksuudsid,s.ksuudsna,s.ksuseunm,s.ksusepid, s.ksusemnm,s.ksusemnp,s.ksusetid,s.ksusepnm, decode(bitand(s.ksuseflg,19),17,'BACKGROUND',1,'USER',2,'RECURSIVE','?'), s.ksusesql, s.ksusesqh, s.ksusesqi, decode(s.ksusesch, 65535, to_number(null), s.ksusesch),  s.ksusesesta,  decode(s.ksuseseid, 0, to_number(null), s.ksuseseid),  s.ksusepsq, s.ksusepha, s.ksusepsi,  decode(s.ksusepch, 65535, to_number(null), s.ksusepch),  s.ksusepesta,  decode(s.ksusepeid, 0, to_number(null), s.ksusepeid),  decode(s.ksusepeo,0,to_number(null),s.ksusepeo),  decode(s.ksusepeo,0,to_number(null),s.ksusepes),  decode(s.ksusepco,0,to_number(null),         decode(bitand(s.ksusstmbv, power(2,11)), power(2,11), s.ksusepco,                to_number(null))),  decode(s.ksusepcs,0,to_number(null),         decode(bitand(s.ksusstmbv, power(2,11)), power(2,11), s.ksusepcs,                to_number(null))),  s.ksuseapp, s.ksuseaph, s.ksuseact, s.ksuseach, s.ksusecli, s.ksusefix, s.ksuseobj, s.ksusefil, s.ksuseblk, s.ksuseslt,  s.ksuseorafn, s.ksuseltm, s.ksusectm,decode(bitand(s.ksusepxopt, 12),0,'NO','YES'),decode(s.ksuseft, 2,'SESSION', 4,'SELECT',8,'TRANSACTIONAL','NONE'),decode(s.ksusefm,1,'BASIC',2,'PRECONNECT',4,'PREPARSE','NONE'),decode(s.ksusefs, 1, 'YES', 'NO'),s.ksusegrp,decode(bitand(s.ksusepxopt,4),4,'ENABLED',decode(bitand(s.ksusepxopt,8),8,'FORCED','DISABLED')),decode(bitand(s.ksusepxopt,2),2,'FORCED',decode(bitand(s.ksusepxopt,1),1,'DISABLED','ENABLED')),decode(bitand(s.ksusepxopt,32),32,'FORCED',decode(bitand(s.ksusepxopt,16),16,'DISABLED','ENABLED')),  s.ksusecqd, s.ksuseclid,  decode(s.ksuseblocker,4294967295,'UNKNOWN',  4294967294, 'UNKNOWN',4294967293,'UNKNOWN',4294967292,'NO HOLDER',  4294967291,'NOT IN WAIT','VALID'),decode(s.ksuseblocker, 4294967295,to_number(null),4294967294,to_number(null), 4294967293,to_number(null), 4294967292,to_number(null),4294967291,  to_number(null),bitand(s.ksuseblocker, 2147418112)/65536),decode(s.ksuseblocker, 4294967295,to_number(null),4294967294,to_number(null), 4294967293,to_number(null), 4294967292,to_number(null),4294967291,  to_number(null),bitand(s.ksuseblocker, 65535)),  decode(s.ksusefblocker,4294967295,'UNKNOWN',  4294967294, 'UNKNOWN',4294967293,'UNKNOWN',4294967292,'NO HOLDER',  4294967291,'NOT IN WAIT','VALID'),decode(s.ksusefblocker,4294967295,to_number(null),4294967294,to_number(null), 4294967293,to_number(null), 4294967292,to_number(null),4294967291,  to_number(null),bitand(s.ksusefblocker, 2147418112)/65536),decode(s.ksusefblocker,4294967295,to_number(null),4294967294,to_number(null), 4294967293,to_number(null), 4294967292,to_number(null),4294967291,  to_number(null),bitand(s.ksusefblocker, 65535)),  w.kslwtseq,w.kslwtevt,e.kslednam,e.ksledp1,w.kslwtp1,w.kslwtp1r, e.ksledp2,w.kslwtp2,w.kslwtp2r,e.ksledp3,w.kslwtp3,w.kslwtp3r, e.ksledclassid,e.ksledclass#,e.ksledclass, decode(w.kslwtinwait,        0,decode(bitand(w.kslwtflags,256),                 0,-2,                 decode(round(w.kslwtstime/10000),                        0,-1,                        round(w.kslwtstime/10000))),        0), decode(w.kslwtinwait,0,round((w.kslwtstime+w.kslwtltime)/1000000),  round(w.kslwtstime/1000000)), decode(w.kslwtinwait,1,'WAITING',  decode(bitand(w.kslwtflags,256),0,'WAITED UNKNOWN TIME',   decode(round(w.kslwtstime/10000),0,'WAITED SHORT TIME',    'WAITED KNOWN TIME'))),w.kslwtstime, decode(w.kslwtinwait,0,to_number(null),  decode(bitand(w.kslwtflags,64),64,0,w.kslwttrem)), w.kslwtltime,s.ksusesvc, decode(bitand(s.ksuseflg2,32),32,'ENABLED','DISABLED'),decode(bitand(s.ksuseflg2,64),64,'TRUE','FALSE'),d
+++GV$SESSIONS_COUNT+++               select            INST_ID, CON_ID, KSUPDBSESCNT          from X$KSUPDBSES
+++GV$SESSION_BLOCKERS+++             select  inst_id,  sid,  sess_serial#,  wait_id,  wait_event,  wait_event_text,  blocker_instance_id,  blocker_sid,  blocker_sess_serial#,  con_id  from X$KSDHNG_SESSION_BLOCKERS
+++GV$SESSION_CLIENT_RESULT_CACHE+++  select inst_id, 0, 0 , kmpcsoaddr, kmpcsocqcregid, con_id from x$kmpcso    where kmpcsostate != 0  union (select a.inst_id, a.ksusenum , a.ksuseser ,         hextoraw('0'), a.ksuseclregid, a.con_id         from x$ksusecon a , x$ksuse b where         a.ksusenum = b.ksusenum and a.ksuseser = b.ksuseser          and b.ksspatyp != 4)
+++GV$SESSION_CONNECT_INFO+++         select inst_id, ksusenum, ksuseser, decode(ksuseaty, 0, 'DATABASE', 1,  'OS', 2, 'NETWORK', 3, 'PROXY', 4, 'SERVER', 5, 'PASSWORD',  6, 'EXTERNAL ADAPTERS', 7, 'INTERNAL', 8, 'GLOBAL',  9, 'EXTERNAL', 10, 'PASSWORD BASED GLOBAL USER', 11, 'XS', '?'),  ksuseunm, ksuseban,  decode(ksusecsid,0,'Unknown',nls_charset_name(ksusecsid)),  decode(bitand(ksuseflags,1), 0, 'Heterogeneous', 'Homogeneous'), decode(ksusecllib,1,'Home-based',2,'Full Instant Client',                   3,'XE Instant Client',4,'Light Weight Instant Client',                    5,'OCI','Unknown'),  nvl(SYS_OP_VERSION(ksuseclvsn), 'Unknown'), ksusecldrv,  decode(bitand(ksusecllbf,1), 1, 'Client Temp Lob Rfc On',                                  'Client Temp Lob Rfc Off'),   ksuseclregid, con_id  from x$ksusecon                                                 where bitand(ksuseflg,1)!=0 and bitand(ksuseflg,16)=0
+++GV$SESSION_CURSOR_CACHE+++         select inst_id,kgscugmax,kgscugcnt,kgscugopn,kgscughit, decode(kgscugopn,0,1,kgscughit/kgscugopn), con_id from x$kgscc
+++GV$SESSION_EVENT+++                select s.inst_id, s.kslessid, d.kslednam, s.ksleswts, s.kslestmo, round(s.kslestim / 10000), round(s.kslestim / (10000 * s.ksleswts), 2), round(s.kslesmxt / 10000),  s.kslestim, d.ksledhash, d.ksledclassid, d.ksledclass#, d.ksledclass,  s.con_id  from x$ksles s, x$ksled d  where s.ksleswts != 0 and s.kslesenm = d.indx
+++GV$SESSION_FIX_CONTROL+++          select  INST_ID,        SID_QKSBGSEROW,        BUGNO_QKSBGSEROW,        VALUE_QKSBGSEROW,        FID_QKSBGSEROW,        DESC_QKSBGSEROW,        OFE_QKSBGSEROW,        EVENT_QKSBGSEROW,        ISDEFAULT_QKSBGSEROW,         CON_ID from x$qksbgses
+++GV$SESSION_LONGOPS+++              select inst_id, ksulosno, ksulosrn, ksulopna,        ksulotna, ksulotde, ksulosfr, ksulotot, ksulouni,        to_date(ksulostm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),        to_date(ksulolut,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),        to_date(ksuloinft, 'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),        decode(ksulopna, 'Advisor', ksuloif2,               decode(sign(ksulotot-ksulosfr),-1,to_number(NULL),                     decode(ksulosfr, 0, to_number(NULL),                      round(ksuloetm*((ksulotot-ksulosfr)/ksulosfr))))),       ksuloetm, ksuloctx, ksulomsg, ksulounm,        ksulosql, ksulosqh, ksulosqi, ksulosqph, ksulosqesta,        decode(ksulosqeid, 0, to_number(NULL), ksulosqeid),        decode(ksulosqplid, 0, to_number(NULL), ksulosqplid),        ksulosqplop, ksulosqplnm, ksuloqid, con_id      from x$ksulop
+++GV$SESSION_OBJECT_CACHE+++         select inst_id,kocstpin,kocsthit,kocsttht,decode(kocstpin,0,1,kocsthit/kocstpin),decode(kocstpin,0,1,kocsttht/kocstpin),kocstorf,kocstrfs,kocstofs,kocstfls,kocstshr,kocstcnt,kocstpnd,kocstsiz,kocstopt,kocstmax, con_id from x$kocst
+++GV$SESSION_WAIT+++                 select s.inst_id,s.kslwtsid,s.kslwtseq,e.kslednam, e.ksledp1,s.kslwtp1,s.kslwtp1r,e.ksledp2, s.kslwtp2,s.kslwtp2r,e.ksledp3,s.kslwtp3,s.kslwtp3r, e.ksledclassid, e.ksledclass#, e.ksledclass, decode(s.kslwtinwait,        0,decode(bitand(s.kslwtflags,256),                 0,-2,                 decode(round(s.kslwtstime/10000),                        0,-1,                        round(s.kslwtstime/10000))),        0), decode(s.kslwtinwait,0,round((s.kslwtstime+s.kslwtltime)/1000000),  round(s.kslwtstime/1000000)), decode(s.kslwtinwait,1,'WAITING',  decode(bitand(s.kslwtflags,256),0,'WAITED UNKNOWN TIME',   decode(round(s.kslwtstime/10000),0,'WAITED SHORT TIME',    'WAITED KNOWN TIME'))), s.kslwtstime, decode(s.kslwtinwait,0,to_number(null),  decode(bitand(s.kslwtflags,64),64,0,s.kslwttrem)), s.kslwtltime, s.con_id  from x$kslwt s, x$ksled e where s.kslwtevt=e.indx
+++GV$SESSION_WAIT_CLASS+++           select s.inst_id, s.kslcssid, s.kslcsser, s.kslcsclsid, s.kslcscls,  s.kslcsclsname, s.kslcswts, round(s.kslcstim / 10000), s.con_id from x$kslcs s  where s.kslcswts != 0
+++GV$SESSION_WAIT_HISTORY+++         select s.inst_id,s.kslwhsid,s.kslwhridx,s.kslwhevt, s.kslwhetext,s.kslwhp1text,s.kslwhp1,s.kslwhp2text,s.kslwhp2, s.kslwhp3text,s.kslwhp3, round(s.kslwhstime/10000),s.kslwhstime,s.kslwhltime, con_id from x$kslwh s
+++GV$SESSMETRIC+++                   SELECT inst_id, begtime, endtime, intsize_csec,            sessid, sernum, cpu, phyrds, logrds, pga_memory,            hard_parses, soft_parses, phyrds_pct, logrds_pct, con_id          FROM   x$kewmsemv          WHERE flag1 = 1
+++GV$SESSTAT+++                      select inst_id,ksusenum,ksusestn,ksusestv,con_id from x$ksusesta where bitand(ksspaflg,1)!=0 and bitand(ksuseflg,1)!=0 and ksusestn<(select ksusgstl from x$ksusgif)
+++GV$SESS_IO+++                      select inst_id,indx, ksusesbg, ksusescg, ksusespr, ksusesbc, ksusescc,  ksusesor, con_id  from x$ksusio where bitand(ksspaflg,1)!=0 and bitand(ksuseflg,1)!=0
+++GV$SESS_TIME_MODEL+++              select map.inst_id, sesv.ksusenum, map.extid, map.sname,  sesv.kewsval, map.con_id  from x$kewssmap map, x$kewssesv sesv  where map.soffst = sesv.kewsnum and map.aggid = 1 and  bitand(sesv.ksspaflg,1)!=0 and bitand(sesv.ksuseflg,1)!=0 and  (map.stype = 2 or map.stype = 3)
+++GV$SES_OPTIMIZER_ENV+++            select INST_ID,                    SID_QKSCESEROW,             PNUM_QKSCESEROW,            PNAME_QKSCESEROW,           FID_QKSCESEROW,             decode(bitand(FLAGS_QKSCESEROW, 2), 0, 'NO', 'YES'),           PVALUE_QKSCESEROW,                                             CON_ID                                                  from   X$QKSCESES                                              where  bitand(FLAGS_QKSCESEROW, 8) = 0                           and  (bitand(FLAGS_QKSCESEROW, 4) = 0                                or bitand(FLAGS_QKSCESEROW, 2) = 0)
+++GV$SGA+++                          select inst_id,ksmsdnam,ksmsdval, con_id from x$ksmsd
+++GV$SGAINFO+++                      select b, c, d, e, 0 from (  select ksmsgmemidx a, inst_id b, ksmsgmemnam c, ksmsgmemval d,        decode(ksmsgmemrez, 0, 'No', 1, 'Yes', NULL) e from x$ksmsgmem    union  select 32 a, USERENV('Instance') b, 'Free SGA Memory Available' c,    current_size d, NULL e from v$sga_dynamic_free_memory)
+++GV$SGASTAT+++                      select inst_id,'',ksmssnam,ksmsslen, con_id from x$ksmfs where ksmsslen>1  union all  select inst_id,'shared pool',ksmssnam, sum(ksmsslen), con_id from x$ksmss    where ksmsslen>1 group by inst_id, 'shared pool', ksmssnam, con_id  union all  select inst_id,'large pool',ksmssnam, sum(ksmsslen), con_id from x$ksmls    where ksmsslen>1 group by inst_id, 'large pool', ksmssnam, con_id  union all  select inst_id,'java pool',ksmssnam, sum(ksmsslen), con_id from x$ksmjs    where ksmsslen>1 group by inst_id, 'java pool', ksmssnam, con_id  union all  select inst_id,'numa pool',ksmnsnam, sum(ksmnslen), con_id from x$ksmns    where ksmnslen>1 group by inst_id, 'numa pool', ksmnsnam, con_id  union all  select inst_id,'streams pool',ksmssnam, sum(ksmsslen), con_id from x$ksmstrs    where ksmsslen>1 group by inst_id, 'streams pool', ksmssnam, con_id
+++GV$SGA_CURRENT_RESIZE_OPS+++       select sc.inst_id, sc.component,     decode(sc.opcode, 0, 'STATIC', 1, 'INITIALIZING', 2, 'DISABLED',           3, 'GROW', 4, 'SHRINK', 5, 'SHRINK_CANCEL', NULL),     decode(sc.opmode, 1, 'MANUAL', 2, 'DEFERRED', 3, 'IMMEDIATE', NULL),     pn.name, sc.initsize * sc.gransize, sc.targsize * sc.gransize,     sc.cursize * sc.gransize, sc.starttime, sc.lasttime, sc.con_id   from x$kmgsct sc, v$parameter pn   where (sc.parno = pn.num)     and (sc.opcode <> 0)     and (sc.starttime is not null)     and (sc.component != 'SGA Target')     and (sc.component != 'PGA Target')
+++GV$SGA_DYNAMIC_COMPONENTS+++       select st.inst_id, st.component, st.cursize * st.gransize,      st.minsize * st.gransize, st.maxsize * st.gransize,      st.usersize * st.gransize, st.opercnt,      decode(st.lastoper, 0, 'STATIC', 1, 'INITIALIZING', 2, 'DISABLED',            3, 'GROW', 4, 'SHRINK', 5, 'SHRINK_CANCEL', NULL),      decode(st.lastmode, 1, 'MANUAL', 2, 'DEFERRED', 3, 'IMMEDIATE', NULL),      st.lasttime, st.gransize, st.con_id      from x$kmgsct st where      (st.component != 'SGA Target') and      (st.component != 'PGA Target')
+++GV$SGA_DYNAMIC_FREE_MEMORY+++      select inst_id, gv.gransize * gx.num_grans, gv.con_id from   (select count(*) num_grans from x$ksmge where granstate = 'FREE'   or granstate = 'INVALID' ) gx, x$kmgsct gv where rownum=1
+++GV$SGA_RESIZE_OPS+++               select op.inst_id, gv.component,     decode(op.opcode, 0, 'STATIC', 1, 'INITIALIZING', 2, 'DISABLED',           3, 'GROW', 4, 'SHRINK', 5, 'SHRINK_CANCEL', NULL),     decode(op.opmode, 1, 'MANUAL', 2, 'DEFERRED', 3, 'IMMEDIATE', NULL),     pn.name, op.initsize * gv.gransize, op.targsize * gv.gransize,      op.realsize * gv.gransize,     decode(op.status, 0, 'INACTIVE', 1, 'PENDING', 2, 'COMPLETE',           3, 'CANCELLED', 4, 'ERROR', 5, 'ERROR', 6, 'ERROR',           7, 'CANCELLED', 8, 'CANCELLED', NULL),     op.starttime, op.endtime, op.con_id   from x$kmgsop op, x$kmgsct gv, v$parameter pn   where (op.grantype = gv.grantype)     and (op.parno = pn.num)     and (gv.component != 'SGA Target')     and (gv.component != 'PGA Target')     order by op.starttime
+++GV$SGA_TARGET_ADVICE+++            select A.inst_id, A.sgasz,                                                     round((A.sgasz / A.base_sgasz), 4),                                           decode(A.base_estd_dbtime,0,to_number(null),                                   round(A.base_dbtime * round((A.dbtime / A.base_estd_dbtime), 4), 0)),        decode(A.base_estd_dbtime,0,to_number(null),                                   round((A.dbtime / A.base_estd_dbtime), 4)),                                  decode(A.base_estd_phy_reads,0,to_number(null),                                round(A.base_phy_reads *                                                          round((A.estd_physical_reads / A.base_estd_phy_reads), 4), 0)),          A.csz, A.spsz,                                                                A.con_id                                                                     from x$kmgsbsadv A                                                            order by A.inst_id, A.sgasz
+++GV$SHARED_POOL_ADVICE+++           select inst_id, sp_size, round(sp_size / basesp_size, 4),  kglsim_size, kglsim_objs, kglsim_timesave,  decode(kglsim_basetimesave, 0, to_number(null),         round(kglsim_timesave / kglsim_basetimesave, 4)),  kglsim_parsetime, decode(kglsim_baseparsetime, 0, to_number(null),         round(kglsim_parsetime / kglsim_baseparsetime, 4)),  kglsim_hits, con_id from x$kglsim
+++GV$SHARED_POOL_RESERVED+++         select p.inst_id, p.free_space, p.avg_free_size, p.free_count, p.max_free_size, p.used_size, p.avg_used_size, p.used_count, p.max_used_size, s.requests, s.request_misses, s.last_miss_size, s.max_miss_size, s.request_failures, s.last_failure_size, s.aborted_request_threshold, s.aborted_requests, s.last_aborted_size, p.con_id from (select avg(x$ksmspr.inst_id) inst_id, sum(decode(ksmchcls,'R-free',ksmchsiz,0)) free_space, avg(decode(ksmchcls,'R-free',ksmchsiz,0)) avg_free_size, sum(decode(ksmchcls,'R-free',1,0)) free_count, max(decode(ksmchcls,'R-free',ksmchsiz,0)) max_free_size, sum(decode(ksmchcls,'R-free',0,ksmchsiz)) used_size, avg(decode(ksmchcls,'R-free',0,ksmchsiz)) avg_used_size, sum(decode(ksmchcls,'R-free',0,1)) used_count, max(decode(ksmchcls,'R-free',0,ksmchsiz)) max_used_size, avg(x$ksmspr.con_id) con_id from x$ksmspr where ksmchcom not like '%reserved sto%') p, (select sum(kghlurcn) requests, sum(kghlurmi) request_misses,  max(kghlurmz) last_miss_size, max(kghlurmx) max_miss_size,  sum(kghlunfu) request_failures, max(kghlunfs) last_failure_size,  max(kghlumxa) aborted_request_threshold, sum(kghlumer) aborted_requests,  max(kghlumes) last_aborted_size from x$kghlu) s
+++GV$SHARED_SERVER+++                select inst_id,kmmsinam,kmmsiprp,kmmsista,kmmsinmg, kmmsinmb,kmmsibrk,kmmsivcp,kmmsiidl,kmmsibsy,kmmsineti,kmmsineto,kmmsitnc, con_id from x$kmmsi where bitand(kmmsiflg,1)!=0
+++GV$SHARED_SERVER_MONITOR+++        select inst_id,kmmsgcmx,kmmsgmmx,kmmsgsta,kmmsgtrm,kmmsgsmx, con_id from x$kmmsg
+++GV$SORT_SEGMENT+++                 select sd.inst_id, ts.tsnam, segment_file, segment_block, extent_size, current_users, total_extents, total_blocks, used_extents, used_blocks, free_extents, free_blocks, added_extents, extent_hits, freed_extents, free_requests, max_size, max_blocks, max_used_size, max_used_blocks, max_sort_size, max_sort_blocks, relative_fno, sd.ts#, sd.con_id  from x$ktstssd sd, x$kccts ts where (sd.con_id is null or sd.con_id = ts.con_id) and sd.ts# = ts.tstsn
+++GV$SORT_USAGE+++                   select so.inst_id, username, username, ktssoses, ktssosno, prev_sql_addr, prev_hash_value, prev_sql_id, ts.name, decode(ts.contents$, 0, 'PERMANENT', 1, 'TEMPORARY'), decode(ktssosegt, 1, 'SORT', 2, 'HASH', 3, 'DATA', 4, 'INDEX', 5, 'LOB_DATA', 6, 'LOB_INDEX' , 'UNDEFINED'), ktssofno, ktssobno, ktssoexts, ktssoblks, ktssorfno, ktssotsnum, so.con_id, ktssosqlid from x$ktsso so, v$session, ts$ ts where  so.ktssotsnum = ts.ts# and  ktssoses = v$session.saddr and  ktssosno = v$session.serial#
+++GV$SPPARAMETER+++                  select INST_ID, KSPSPFFTCTXSPFAM, KSPSPFFTCTXSPSID, KSPSPFFTCTXSPNAME,         decode(KSPSPFFTCTXPARTYP,1,'boolean',2,'string', 3,'integer',                4,'file',5,'number', 6,'big integer', 'unknown'),         KSPSPFFTCTXSPVALUE,         KSPSPFFTCTXSPDVALUE,         KSPSPFFTCTXISSPECIFIED, KSPSPFFTCTXORDINAL,         KSPSPFFTCTXCOMMENT, CON_ID from x$kspspfile         WHERE ((translate(KSPSPFFTCTXSPNAME,'_','#') not like '##%') and                ((translate(KSPSPFFTCTXSPNAME, '_', '#') not like '#%')                  OR KSPSPFFTCTXISSPECIFIED = 'TRUE'))
+++GV$SQL+++                          select inst_id,kglnaobj,kglfnobj,kglobt03, kglobhs0+kglobhs1+kglobhs2+kglobhs3+kglobhs4+kglobhs5+kglobhs6+kglobt16, kglobt08+kglobt11, kglobt10, kglobt01, decode(kglobhs6,0,0,1), decode(kglhdlmd,0,0,1), kglhdlkc, kglobt04, kglobt05, kglobt48, kglobt35, kglobpc6, kglhdldc, substr(to_char(kglnatim,'YYYY-MM-DD/HH24:MI:SS'),1,19), kglhdivc, kglobt12, kglobt13, kglobwdw, kglobt14, kglobwap, kglobwcc, kglobwcl, kglobwui, kglobt42, kglobt43, kglobt15, kglobt02, decode(kglobt32,        0, 'NONE',        1, 'ALL_ROWS',        2, 'FIRST_ROWS',        3, 'RULE',        4, 'CHOOSE',           'UNKNOWN'), kglobtn0, kglobcce, kglobcceh, kglobt17, kglobt18, kglobts4, kglhdkmk, kglhdpar, kglobtp0, kglnahsh, kglobt46, kglobt30, kglobt61, kglobt09, kglobts5, kglobt48, kglobts0, kglobt19, kglobts1, kglobt20, kglobt21, kglobts2, kglobt06, kglobt07, decode(kglobt28, 0, to_number(NULL), kglobt28), kglhdadr, kglobt29, decode(bitand(kglobt00,64),64, 'Y', 'N'), decode(kglobsta,        1, 'VALID',        2, 'VALID_AUTH_ERROR',        3, 'VALID_COMPILE_ERROR',        4, 'VALID_UNAUTH',        5, 'INVALID_UNAUTH',        6, 'INVALID'), kglobt31, substr(to_char(kglobtt0,'YYYY-MM-DD/HH24:MI:SS'),1,19), decode(kglobt33, 1, 'Y', 'N'),  decode(bitand(kglobacs, 1), 1, 'Y', 'N'),  decode(bitand(kglobacs, 2), 2, 'Y', 'N'),  decode(bitand(kglobacs, 4), 4, 'Y', 'N'),  kglhdclt, kglobts3, kglobts7, kglobts6, kglobt44, kglobt45,  kglobt47, kglobt49, kglobcla,  kglobcbca, kglobt22, kglobt52, kglobt53, kglobt54, kglobt55,  kglobt56, kglobt57, kglobt58, kglobt23, kglobt24, kglobt59,  kglobt53 - ((kglobt55+kglobt57) - kglobt52),  con_id,  decode(bitand(kglobaqp,1), 1, decode(bitand(kglobaqp,2), 2, 'R', 'Y'), 'N'),  decode(bitand(kglobaqp,4), 4, decode(bitand(kglobaqp,8), 8, 'Y', 'N'), ''),  kglimscans, kglimbytesuncomp, kglimbytesinmem  from x$kglcursor_child
+++GV$SQLAREA+++                      select inst_id,kglnaobj,kglfnobj,kglobt03,kglobhs0+kglobhs1+kglobhs2+kglobhs3+kglobhs4+kglobhs5+kglobhs6,kglobt08+kglobt11,kglobt10,kglobt01,kglobccc,kglobclc,kglhdlmd,kglhdlkc,kglobt04,kglobt05,kglobt48,kglobt35,kglobpc6,kglhdldc,substr(to_char(kglnatim,'YYYY-MM-DD/HH24:MI:SS'),1,19),kglhdivc,kglobt12,kglobt13,kglobwdw,kglobt14,kglobwap,kglobwcc,kglobwcl,kglobwui,kglobt42,kglobt43,kglobt15,kglobt02,decode(kglobt32, 0, 'NONE',                 1, 'ALL_ROWS',                 2, 'FIRST_ROWS',                 3, 'RULE',                 4, 'CHOOSE', 'UNKNOWN'),kglobtn0,kglobcce,kglobcceh,kglobt17,kglobt18,kglobts4,kglhdkmk,kglhdpar,kglnahsh,kglobt46,kglobt30,kglobt61,kglobts0,kglobt19,kglobts1,kglobt20,kglobt21,kglobts2,kglobt06,kglobt07,decode(kglobt28, 0, NULL, kglobt28),kglhdadr,decode(bitand(kglobt00,64),64, 'Y', 'N'),decode(kglobsta,       1, 'VALID',       2, 'VALID_AUTH_ERROR',       3, 'VALID_COMPILE_ERROR',       4, 'VALID_UNAUTH',       5, 'INVALID_UNAUTH',       6, 'INVALID'),kglobt31,kglobtt0,decode(kglobt33, 1, 'Y', 'N'), decode(bitand(kglobacs, 1), 1, 'Y', 'N'), decode(bitand(kglobacs, 2), 2, 'Y', 'N'), kglhdclt,kglobts3,kglobts7,kglobts6,kglobt44,kglobt45,kglobt47,kglobt49,kglobcla,kglobcbca,kglobt22,kglobt52,kglobt53,kglobt54,kglobt55,kglobt56,kglobt57,kglobt58,kglobt23,kglobt24,kglobt59,kglobt53 - ((kglobt55+kglobt57) - kglobt52),con_id, decode(bitand(kglobaqp,1), 1, decode(bitand(kglobaqp,2), 2, 'R', 'Y'), 'N'), decode(bitand(kglobaqp,4), 4, decode(bitand(kglobaqp,8), 8, 'Y', 'N'), '')from  x$kglcursor_child_sqlid where kglobt02 != 0
+++GV$SQLAREA_PLAN_HASH+++            select inst_id, kglnaobj, kglfnobj, kglhdpar, kglnahsh, kglobt03, kglobt30, kglobccc, kglhdadr, kglobhs0+kglobhs1+kglobhs2+kglobhs3+kglobhs4+kglobhs5+kglobhs6, kglobt08+kglobt11, kglobt10, kglobt01, kglobclc, kglhdlmd, kglhdlkc, kglobpc6, kglobt04, kglobt05, kglobt48, kglobt35, kglhdldc, kglnatim, kglobtt0, kglobcla, kglhdivc, kglobt12, kglobt13, kglobwdw, kglobt14, kglobt06, kglobt07, kglobwap, kglobwcc, kglobwcl, kglobwui, kglobt42, kglobt43, kglobt15, kglobt02, decode(kglobt32, 0, 'NONE',                  1, 'ALL_ROWS',                  2, 'FIRST_ROWS',                  3, 'RULE',                  4, 'CHOOSE', 'UNKNOWN'), kglobtn0, kglobcce, kglobcceh, kglobt17, kglobt18, kglobts4, kglhdkmk, kglobts0, kglobt19, kglobts1, kglobt20, kglobt21, kglobts2, decode(kglobt28, 0, NULL, kglobt28), decode(bitand(kglobt00,64),64, 'Y', 'N'), decode(kglobsta,        1, 'VALID',        2, 'VALID_AUTH_ERROR',        3, 'VALID_COMPILE_ERROR',        4, 'VALID_UNAUTH',        5, 'INVALID_UNAUTH',        6, 'INVALID'), kglobt31, kglobts3, kglobt44, kglobt45, kglobt47, kglobt49, kglobcbca, kglobt22,  kglobt52,  kglobt53,  kglobt54,  kglobt55,  kglobt56,  kglobt57,  kglobt58,  kglobt59,  kglobt53 - ((kglobt55+kglobt57) - kglobt52),  con_id,  kglobt60  from  x$kglcursor_child_sqlidph
+++GV$SQLCOMMAND+++                   select inst_id, indx, oct_name, con_id  from x$oct where indx=oct_type
+++GV$SQLFN_ARG_METADATA+++           select inst_id,        id,        argnum,        case when dtype = 0 then 'UNKNOWN'         when dtype = 1 then 'NUMERIC'         when dtype = 2 then 'STRING'         when dtype = 3 then 'DATETYPE'         when dtype = 4 then 'BINARY'         when dtype = 5 then 'EXPR'         when dtype = 6 then 'ARG 1'         when dtype = 7 then 'ARG 2'         when dtype = 8 then 'ARG 3'        else 'INVALID'        end,        descr,        con_id        from  x$oparg
+++GV$SQLFN_METADATA+++               select o.inst_id,        o.id,        o.name,        o.operands,        o.maxoperands,        case when d.ret_type = 0 then 'UNKNOWN'         when d.ret_type = 1 then 'NUMERIC'         when d.ret_type = 2 then 'STRING'         when d.ret_type = 3 then 'DATETYPE'         when d.ret_type = 4 then 'BINARY'         when d.ret_type = 5 then 'EXPR'         when d.ret_type = 6 then 'ARG 1'         when d.ret_type = 7 then 'ARG 2'         when d.ret_type = 8 then 'ARG 3'        else 'INVALID'        end,        case when v.version = 1 then 'V6 Oracle'         when v.version = 2 then 'SQL/DS'         when v.version = 10 then 'V71 Oracle'         when v.version = 11 then 'V73 Oracle'         when v.version = 12 then 'V80 Oracle'         when v.version = 13 then 'V81 Oracle'         when v.version = 14 then 'V816 Oracle'         when v.version = 16 then 'V82 Oracle'         when v.version = 18 then 'V92 Oracle'         when v.version = 19 then 'V10 Oracle'         when v.version = 20 then 'V10R2 Oracle'         when v.version = 21 then 'V11R1 Oracle'        else 'INVALID'        end,        case when bitand(o.flags, 4096) = 4096 then 'YES'         when bitand(o.flags, 32768) = 32768 then 'YES'        else 'NO'        end,        case when bitand(o.flags, 8) = 8 then 'YES'        else 'NO'        end,        decode(bitand(o.flags,16777216), 16777216, 'YES', 'NO'),        case when d.disp_type = 0 then 'UNKNOWN'         when d.disp_type = 1 then 'NORMAL'         when d.disp_type = 2 then 'ARITHMATIC'         when d.disp_type = 3 then 'PARENTHESIS'         when d.disp_type = 4 then 'REL-OP'         when d.disp_type = 5 then 'CASELIKE'         when d.disp_type = 6 then 'NOPARENTHESIS'        else 'INVALID'        end,        d.usg,        d.descr,        o.con_id        from  x$operators o, x$opversion v, x$opdesc d        where o.indx = v.indx        and   v.indx = d.indx        and   o.inst_id = v.inst_id        and   v.inst_id = d.inst_id
+++GV$SQLPA_METRIC+++                 select INST_ID, NM_KESSPAMETRIC, CON_ID          from X$KESSPAMET
+++GV$SQLSTATS+++                     select INST_ID, SQL_TEXT, SQL_FULLTEXT, SQL_ID, LAST_ACTIVE_TIME,        LAST_ACTIVE_CHILD_ADDRESS, PLAN_HASH_VALUE,        PARSE_CALLS, DISK_READS,        DIRECT_WRITES, BUFFER_GETS, ROWS_PROCESSED, SERIALIZABLE_ABORTS,        FETCHES, EXECUTIONS, END_OF_FETCH_COUNT, LOADS, VERSION_COUNT,        INVALIDATIONS, PX_SERVERS_EXECUTIONS, CPU_TIME,        ELAPSED_TIME, AVG_HARD_PARSE_TIME, APPLICATION_WAIT_TIME,        CONCURRENCY_WAIT_TIME, CLUSTER_WAIT_TIME, USER_IO_WAIT_TIME,        PLSQL_EXEC_TIME, JAVA_EXEC_TIME, SORTS, SHARABLE_MEM,        TOTAL_SHARABLE_MEM, TYPECHECK_MEM,        IO_CELL_OFFLOAD_ELIGIBLE_BYTES,        IO_INTERCONNECT_BYTES,        PHYSICAL_READ_REQUESTS, PHYSICAL_READ_BYTES,        PHYSICAL_WRITE_REQUESTS, PHYSICAL_WRITE_BYTES,        EXACT_MATCHING_SIGNATURE, FORCE_MATCHING_SIGNATURE,        IO_CELL_UNCOMPRESSED_BYTES,        IO_INTERCONNECT_BYTES - ((PHYSICAL_READ_BYTES+PHYSICAL_WRITE_BYTES)        - IO_CELL_OFFLOAD_ELIGIBLE_BYTES),        DELTA_PARSE_CALLS,  DELTA_DISK_READS, DELTA_DIRECT_WRITES,        DELTA_BUFFER_GETS, DELTA_ROWS_PROCESSED, DELTA_FETCH_COUNT,        DELTA_EXECUTION_COUNT,  DELTA_PX_SERVERS_EXECUTIONS,        DELTA_END_OF_FETCH_COUNT, DELTA_CPU_TIME, DELTA_ELAPSED_TIME,        DELTA_APPLICATION_WAIT_TIME, DELTA_CONCURRENCY_TIME,        DELTA_CLUSTER_WAIT_TIME,  DELTA_USER_IO_WAIT_TIME,        DELTA_PLSQL_EXEC_TIME, DELTA_JAVA_EXEC_TIME,        DELTA_SORTS, DELTA_LOADS, DELTA_INVALIDATIONS,        DELTA_PHYSICAL_READ_REQUESTS, DELTA_PHYSICAL_READ_BYTES,        DELTA_PHYSICAL_WRITE_REQUESTS, DELTA_PHYSICAL_WRITE_BYTES,        DELTA_IO_INTERCONNECT_BYTES,        DELTA_CELL_OFFLOAD_ELIG_BYTES, DELTA_CELL_UNCOMPRESSED_BYTES,        CON_ID, CON_DBID, OBSOLETE_COUNT FROM   x$kkssqlstat
+++GV$SQLSTATS_PLAN_HASH+++           select INST_ID, SQL_TEXT, SQL_FULLTEXT, SQL_ID, LAST_ACTIVE_TIME,        LAST_ACTIVE_CHILD_ADDRESS, PLAN_HASH_VALUE,        PARSE_CALLS, DISK_READS,        DIRECT_WRITES, BUFFER_GETS, ROWS_PROCESSED, SERIALIZABLE_ABORTS,        FETCHES, EXECUTIONS, END_OF_FETCH_COUNT, LOADS, VERSION_COUNT,        INVALIDATIONS, PX_SERVERS_EXECUTIONS, CPU_TIME,        ELAPSED_TIME, AVG_HARD_PARSE_TIME, APPLICATION_WAIT_TIME,        CONCURRENCY_WAIT_TIME, CLUSTER_WAIT_TIME, USER_IO_WAIT_TIME,        PLSQL_EXEC_TIME, JAVA_EXEC_TIME, SORTS, SHARABLE_MEM,        TOTAL_SHARABLE_MEM, TYPECHECK_MEM,        IO_CELL_OFFLOAD_ELIGIBLE_BYTES,        IO_INTERCONNECT_BYTES,        PHYSICAL_READ_REQUESTS, PHYSICAL_READ_BYTES,        PHYSICAL_WRITE_REQUESTS, PHYSICAL_WRITE_BYTES,        EXACT_MATCHING_SIGNATURE, FORCE_MATCHING_SIGNATURE,        IO_CELL_UNCOMPRESSED_BYTES,        IO_INTERCONNECT_BYTES - ((PHYSICAL_READ_BYTES+PHYSICAL_WRITE_BYTES)          - IO_CELL_OFFLOAD_ELIGIBLE_BYTES),        DELTA_PARSE_CALLS,  DELTA_DISK_READS, DELTA_DIRECT_WRITES,        DELTA_BUFFER_GETS, DELTA_ROWS_PROCESSED, DELTA_FETCH_COUNT,        DELTA_EXECUTION_COUNT,  DELTA_PX_SERVERS_EXECUTIONS,        DELTA_END_OF_FETCH_COUNT, DELTA_CPU_TIME, DELTA_ELAPSED_TIME,        DELTA_APPLICATION_WAIT_TIME, DELTA_CONCURRENCY_TIME,        DELTA_CLUSTER_WAIT_TIME,  DELTA_USER_IO_WAIT_TIME,        DELTA_PLSQL_EXEC_TIME, DELTA_JAVA_EXEC_TIME,        DELTA_SORTS, DELTA_LOADS, DELTA_INVALIDATIONS,        DELTA_PHYSICAL_READ_REQUESTS, DELTA_PHYSICAL_READ_BYTES,        DELTA_PHYSICAL_WRITE_REQUESTS, DELTA_PHYSICAL_WRITE_BYTES,        DELTA_IO_INTERCONNECT_BYTES,        DELTA_CELL_OFFLOAD_ELIG_BYTES, DELTA_CELL_UNCOMPRESSED_BYTES,       CON_ID FROM   x$kkssqlstat_plan_hash
+++GV$SQLTEXT+++                      select inst_id,kglhdadr, kglnahsh, kglnasqlid, kgloboct, piece, name, con_id  from x$kglna where kgloboct != 0
+++GV$SQLTEXT_WITH_NEWLINES+++        select inst_id,kglhdadr, kglnahsh, kglnasqlid, kgloboct, piece, name, con_id  from x$kglna1 where kgloboct != 0
+++GV$SQL_BIND_DATA+++                select inst_id,kxsbdcur, kxsbdbnd, kxsbddty, kxsbdmxl, kxsbdpmx, kxsbdmal, kxsbdpre, kxsbdscl, kxsbdofl, kxsbdof2, kxsbdbfp, kxsbdbln, kxsbdavl, kxsbdbfl, kxsbdind, kxsbdval, con_id from x$kxsbd
+++GV$SQL_BIND_METADATA+++            select inst_id,kglhdadr, position, kkscbndt, kkscbndl, kkscbnda, kksbvnnam, con_id from x$kksbv
+++GV$SQL_CS_HISTOGRAM+++             select  inst_id, phadd_kkocs,         hashv_kkocs, sqlid_kkocs,         childno_kkocs, bucketid_kkocs,         count_kkocs, con_id  from X$KKOCS_HISTOGRAM
+++GV$SQL_CS_SELECTIVITY+++           select  inst_id, phadd_kkocs,         hashv_kkocs, sqlid_kkocs,         childno_kkocs, pred_kkocs, rangeid_kkocs,         lowsel_kkocs, highsel_kkocs, con_id from X$KKOCS_SELECTIVITY
+++GV$SQL_CS_STATISTICS+++            select  inst_id,         phadd_kkocs, hashv_kkocs,         sqlid_kkocs, childno_kkocs,         bsethv_kkocs, peeked_kkocs,         execount_kkocs, rowsproc_kkocs,         buffgets_kkocs, cputime_kkocs, con_id from X$KKOCS_STATISTICS
+++GV$SQL_CURSOR+++                   select inst_id,kxscccur, kxscccfl, decode(kxsccsta, 0, 'CURNULL', 1, 'CURSYNTAX', 2, 'CURPARSE', 3, 'CURBOUND', 4, 'CURFETCH', 5, 'CURROW', 'ERROR'), kxsccphd, kxsccplk, kxsccclk, kxscccpn, kxscctbm, kxscctwm, kxscctbv, kxscctdv, kxsccbdf, kxsccflg, kxsccfl2, kxsccchd, con_id from x$kxscc
+++GV$SQL_DIAG_REPOSITORY+++          select  inst_id, con_id, phadd_qkscrrow,         hashv_qkscrrow, sqlid_qkscrrow,         childno_qkscrrow, crid_qkscrrow,         type_qkscrrow, plid_qkscrrow,          fdesc_qkscrrow, state_qkscrrow  from X$QKSCR
+++GV$SQL_DIAG_REPOSITORY_REASON+++   select  inst_id, con_id, phadd_qkscrrsnrow,         hashv_qkscrrsnrow, sqlid_qkscrrsnrow,         childno_qkscrrsnrow, crid_qkscrrsnrow,         fdesc_qkscrrsnrow, reason_qkscrrsnrow,          comp_orig_qkscrrsnrow, exec_orig_qkscrrsnrow,          slv_orig_qkscrrsnrow from X$QKSCR_RSN
+++GV$SQL_FEATURE+++                  select  INST_ID,        ID_QKSFMSYROW,        DESC_QKSFMSYROW,        PROPS_QKSFMSYROW,         CON_ID from x$qksfm
+++GV$SQL_FEATURE_DEPENDENCY+++       select  INST_ID,        ID_QKSFMDEPSYROW,        DID_QKSFMDEPSYROW,         CON_ID  from x$qksfmdep
+++GV$SQL_FEATURE_HIERARCHY+++        select  INST_ID,        ID_QKSFMPRTSYROW,        PID_QKSFMPRTSYROW,         CON_ID from x$qksfmprt
+++GV$SQL_HINT+++                     select  INST_ID,        TOKEN_QKSHTSYROW,        FID_QKSHTSYROW,        CLASS_QKSHTSYROW,        INVERSE_QKSHTSYROW,        LEVEL_QKSHTSYROW,        PROPS_QKSHTSYROW,        VERSION_QKSHTSYROW,        VERSION_OL_QKSHTSYROW,         CON_ID from x$qksht
+++GV$SQL_JOIN_FILTER+++              SELECT  INST_ID, QCSID, QCINSTID, SQLHASHV,                  BFID, LEN, NSET, FLT, TOT, ACTIVE, CON_ID          FROM X$QESBLSTAT WHERE QCINSTID != 0
+++GV$SQL_MONITOR+++                  select  inst_id,         key_keomnmon,         reportid_keomnmon,         case status_keomnmon when 1 then 'EXECUTING'                              when 2 then 'DONE (ERROR)'                              when 3 then 'DONE (FIRST N ROWS)'                              when 4 then 'DONE (ALL ROWS)'                              when 5 then 'DONE'                              when 6 then 'FREED'                              when 7 then 'QUEUED'                              else 'UNKNOWN' end,         decode(pxsrvnum_keomnmon, 4294967295, userid_keomnmon ,                to_number(NULL)),         decode(pxsrvnum_keomnmon, 4294967295, username_keomnmon,                NULL),         decode(pxsrvnum_keomnmon, 4294967295, modulename_keomnmon,                NULL),         decode(pxsrvnum_keomnmon, 4294967295, actionname_keomnmon,                NULL),         decode(pxsrvnum_keomnmon, 4294967295, svcname_keomnmon,                NULL),         decode(pxsrvnum_keomnmon, 4294967295, clientid_keomnmon,                NULL),         decode(pxsrvnum_keomnmon, 4294967295, clientinfo_keomnmon,                NULL),         decode(pxsrvnum_keomnmon, 4294967295, program_keomnmon,                NULL),         decode(pxsrvnum_keomnmon, 4294967295,                decode(plsql_entry_oid_keomnmon, 0, to_number(null),                       plsql_entry_oid_keomnmon),                NULL),         decode(pxsrvnum_keomnmon, 4294967295,                decode(plsql_entry_oid_keomnmon, 0, to_number(null),                       plsql_entry_subid_keomnmon),                NULL),         decode(pxsrvnum_keomnmon, 4294967295,                decode(plsql_cur_oid_keomnmon, 0, to_number(null),                       plsql_cur_oid_keomnmon),                NULL),         decode(pxsrvnum_keomnmon, 4294967295,                decode(plsql_cur_oid_keomnmon, 0, to_number(null),                       plsql_cur_subid_keomnmon),                NULL),         startmon_keomnmon,         lastpub_keomnmon,         pubcount_keomnmon,         dbop_execid_keomnmon,         dbopname_keomnmon,         sid_keomnmon,         procname_keomnmon,         sqlid_keomnmon,         decode(pxsrvnum_keomnmon, 4294967295, sqltext_keomnmon,                                        NULL),         decode(pxsrvnum_keomnmon, 4294967295,                decode(bitand(flags_keomnmon, 1), 0, 'N', 'Y'),                NULL),         execstart_keomnmon,         execid_keomnmon,         planhash_keomnmon,         planhashfull_keomnmon,         exact_match_sig,         force_match_sig,         childaddr_keomnmon,         serial_keomnmon,         decode(pxsrvnum_keomnmon, 4294967295,           decode(bitand(flags_keomnmon, 2), 0, 'N', 'Y'),           NULL),         decode(pxmaxdop, 0, to_number(NULL), pxmaxdop),         decode(pxmaxdop_inst, 0, to_number(NULL), pxmaxdop_inst),         decode(pxtot_requested, 0, to_number(NULL), pxtot_requested),        decode(pxtot_requested, 0, to_number(NULL), pxtot_allocated),        decode(pxsrvnum_keomnmon, 4294967295, to_number(NULL),                pxsrvnum_keomnmon),         decode(pxsrvnum_keomnmon, 4294967295, to_number(NULL),                 pxsrvgrp_keomnmon),         decode(pxsrvnum_keomnmon, 4294967295, to_number(NULL),                 pxsrvset_keomnmon),         decode(pxsrvnum_keomnmon, 4294967295, to_number(NULL),                pxqcinstid_keomnmon),         decode(pxsrvnum_keomnmon, 4294967295, to_number(NULL),                pxqcsessid_keomnmon),         decode(error_code, 0, NULL, error_code),         error_fac,         error_msg,         binds_xml,         other_xml,         elapsed_time,         queuing_time_keomnmon,         cpu_time,         fetches,         buffer_gets,         pread_reqs,         pwrite_reqs,         io_inter_bytes,         pread_reqs,         pread_bytes,         pwrite_reqs,         pwrite_bytes,         application_wait_time,         concurrency_wait_time,         cluster_wait_time,         user_io_wait_time,         plsql_exec_t
+++GV$SQL_MONITOR_SESSTAT+++          select inst_id, con_id, key, statistic#, value from X$KEOMNMON_SESSTAT
+++GV$SQL_MONITOR_STATNAME+++         select inst_id, con_id, id, group_id, name, description, type, flags from X$KESWXMON_STATNAME
+++GV$SQL_OPTIMIZER_ENV+++            select INST_ID,                    KQLFSQCE_PHAD,              KQLFSQCE_HASH,              KQLFSQCE_SQLID,             KQLFSQCE_HADD,              KQLFSQCE_CHNO,              KQLFSQCE_PNUM,              KQLFSQCE_PNAME,             decode(bitand(KQLFSQCE_FLAGS, 2), 0, 'NO', 'YES'),             KQLFSQCE_PVALUE,                                               CON_ID                                                  from   X$KQLFSQCE                                              where  bitand(KQLFSQCE_FLAGS, 8) = 0                             and  (bitand(KQLFSQCE_FLAGS, 4) = 0                                  or bitand(KQLFSQCE_FLAGS, 2) = 0)
+++GV$SQL_PLAN+++                     select inst_id,          kqlfxpl_phad,          kqlfxpl_hash,          kqlfxpl_sqlid,          kqlfxpl_plhash,          kqlfxpl_fplhash,          kqlfxpl_hadd,          kqlfxpl_chno,          kqlfxpl_timestamp,          substr(kqlfxpl_oper, 1, 30),          substr(kqlfxpl_oopt, 1, 30),          substr(kqlfxpl_tqid, 1, 40),          to_number(decode(kqlfxpl_objn, 0, NULL, kqlfxpl_objn)),          kqlfxpl_objowner,                        kqlfxpl_objname,                         kqlfxpl_alias,                           substr(kqlfxpl_objtype, 1, 20),          substr(kqlfxpl_opti, 1, 20),          kqlfxpl_opid,          to_number(decode(kqlfxpl_opid, 0, NULL, kqlfxpl_paid)),          kqlfxpl_depth,          to_number(decode(kqlfxpl_pos, 0,                           decode(kqlfxpl_cost, 4294967295, NULL,                                   kqlfxpl_cost),                           kqlfxpl_pos)),          kqlfxpl_scols,          to_number(decode(kqlfxpl_cost, 4294967295, NULL,                           kqlfxpl_cost)),                                    to_number(decode(kqlfxpl_card, 0, NULL, kqlfxpl_card)),         to_number(decode(kqlfxpl_size, 0, NULL, kqlfxpl_size)),          substr(kqlfxpl_otag, 1, 35),          substr(kqlfxpl_psta, 1, 64),          substr(kqlfxpl_psto, 1, 64),          to_number(decode(kqlfxpl_pnid, 0, NULL, kqlfxpl_pnid)),          kqlfxpl_other,         substr(kqlfxpl_dist, 1, 20),           to_number(decode(kqlfxpl_cpuc, 4294967295, NULL,                           kqlfxpl_cpuc)),                                    to_number(decode(kqlfxpl_ioct, 4294967295, NULL,                           kqlfxpl_ioct)),          to_number(decode(kqlfxpl_temp, 0, NULL, kqlfxpl_temp)),          kqlfxpl_keys,            kqlfxpl_filter,          kqlfxpl_proj,            to_number(decode(kqlfxpl_time, 0, NULL, kqlfxpl_time)),          kqlfxpl_qblock,          kqlfxpl_remark, kqlfxpl_other_xml, con_id           from x$kqlfxpl p
+++GV$SQL_PLAN_MONITOR+++             select  inst_id,         con_id,         key_keomnmonp,         case status_keomnmonp when 1 then 'EXECUTING'                               when 2 then 'DONE (ERROR)'                               when 3 then 'DONE (FIRST N ROWS)'                               when 4 then 'DONE (ALL ROWS)'                               when 5 then 'DONE'                               when 6 then 'FREED'                               when 7 then 'QUEUED'                               else 'UNKNOWN' end,         startmon_keomnmonp,         lastpub_keomnmonp,         firstchg_keomnmonp,         lastchg_keomnmonp,         pubcount_keomnmonp,         sid_keomnmonp,         procname_keomnmonp,         sqlid_keomnmonp,         execstart_keomnmonp,         execid_keomnmonp,         planhash_keomnmonp,         childaddr_keomnmonp,         to_number(decode(opid_keomnmonp, 0, NULL,                   parentid_keomnmonp)),         lineid_keomnmonp,         lineopnam_keomnmonp,         lineopopt_keomnmonp,         objowner_keomnmonp,         objname_keomnmonp,         substr(objtype_keomnmonp, 1, 20),         decode(depth_keomnmonp, 65535, to_number(NULL),                depth_keomnmonp),         to_number(decode(pos_keomnmonp, 0,                          decode(cost_keomnmonp, 4294967295, NULL,                                 cost_keomnmonp), pos_keomnmonp)),         decode(cost_keomnmonp, 0, to_number(NULL),                4294967295, to_number(NULL), cost_keomnmonp),         cardinality_keomnmonp,         size_keomnmonp,         time_keomnmonp,         substr(psta_keomnmonp, 1, 64),         substr(psto_keomnmonp, 1, 64),         to_number(decode(cpucost_keomnmonp, 4294967295, NULL,                   cpucost_keomnmonp)),         to_number(decode(iocost_keomnmonp, 4294967295, NULL,                   iocost_keomnmonp)),         tempspc_keomnmonp,         nsta_keomnmonp,         nrows_keomnmonp,         io_inter_bytes,         pread_reqs,         pread_bytes,         pwrite_reqs,         pwrite_bytes,         case wasta_keomnmonp when 1 then mem_keomnmonp * 1024                              else null end,         case wasta_keomnmonp when 0 then null                              else maxmem_keomnmonp * 1024 end,         case when wasta_keomnmonp = 1 and tmp_keomnmonp != 0              then tmp_keomnmonp * 1024 else null end,         case when wasta_keomnmonp != 0 and maxtmp_keomnmonp != 0              then maxtmp_keomnmonp * 1024 else null end,         otherstat_group_id,         otherstat_1_id,         otherstat_1_type,         otherstat_1_value,         otherstat_2_id,         otherstat_2_type,         otherstat_2_value,         otherstat_3_id,         otherstat_3_type,         otherstat_3_value,         otherstat_4_id,         otherstat_4_type,         otherstat_4_value,         otherstat_5_id,         otherstat_5_type,         otherstat_5_value,         otherstat_6_id,         otherstat_6_type,         otherstat_6_value,         otherstat_7_id,         otherstat_7_type,         otherstat_7_value,         otherstat_8_id,         otherstat_8_type,         otherstat_8_value,         otherstat_9_id,         otherstat_9_type,         otherstat_9_value,         otherstat_10_id,         otherstat_10_type,         otherstat_10_value,         other_xml,         operation_inactive from X$KESWXMON_PLAN
+++GV$SQL_PLAN_STATISTICS+++          select inst_id,           PHADD_QESRS,              HASHV_QESRS,              SQLID_QESRS,              PLHASH_QESRS,             FPLHASH_QESRS,            HADDR_QESRS,              CHILDNO_QESRS,            OPERID_QESRS,             EXECS_QESRS,              LSTARTS_QESRS,            STARTS_QESRS,             LOUTROWS_QESRS,           OUTROWS_QESRS,            LCRGETS_QESRS,            CRGETS_QESRS,             LCUGETS_QESRS,            CUGETS_QESRS,             LDREADS_QESRS,            DREADS_QESRS,             LDWRITES_QESRS,           DWRITES_QESRS,            LELAPTIME_QESRS,          ELAPTIME_QESRS,           CON_ID                    from X$QESRSTAT
+++GV$SQL_PLAN_STATISTICS_ALL+++      select inst_id,  PHADD_QESRS,   HASHV_QESRS,   SQLID_QESRS,   PLHASH_QESRS,  FPLHASH_QESRS,  HADDR_QESRS,  CHILDNO_QESRS, TIMESTAMP_QESRS, substr(oper_qesrs, 1, 30),  substr(oopt_qesrs, 1, 30),  substr(tqid_qesrs, 1, 40),  to_number(decode(objn_qesrs, 0, NULL, objn_qesrs)),  objowner_qesrs,  objname_qesrs,  alias_qesrs,  substr(objtype_qesrs, 1, 20),  substr(opti_qesrs, 1, 20),  opid_qesrs,  to_number(decode(opid_qesrs, 0, NULL, paid_qesrs)),  depth_qesrs,  to_number(decode(pos_qesrs, 0, decode(cost_qesrs, 4294967295, NULL,      cost_qesrs), pos_qesrs)),  scols_qesrs, to_number(decode(cost_qesrs, 4294967295, NULL, cost_qesrs)),  to_number(decode(card_qesrs, 0, NULL, card_qesrs)),  to_number(decode(size_qesrs, 0, NULL, size_qesrs)),  substr(otag_qesrs, 1, 35), substr(psta_qesrs, 1, 64),  substr(psto_qesrs, 1, 64),  to_number(decode(pnid_qesrs, 0, NULL, pnid_qesrs)),  other_qesrs,  substr(dist_qesrs, 1, 20),    to_number(decode(cpuc_qesrs, 4294967295, NULL, cpuc_qesrs)),  to_number(decode(ioct_qesrs, 4294967295, NULL, ioct_qesrs)),  to_number(decode(temp_qesrs, 0, NULL, temp_qesrs)),  KEYS_QESRS,  FILTER_QESRS,  PROJ_QESRS,  to_number(decode(time_qesrs, 0, NULL, time_qesrs)), QBLOCK_QESRS,   REMARK_QESRS,   OTHER_XML_QESRS,   EXECS_QESRS,    to_number(decode(LSTARTS_QESRS, 4294967295, NULL, LSTARTS_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, STARTS_QESRS)),   to_number(decode(LSTARTS_QESRS, 4294967295, NULL, LOUTROWS_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, OUTROWS_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, LCRGETS_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, CRGETS_QESRS)),   to_number(decode(LSTARTS_QESRS, 4294967295, NULL, LCUGETS_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, CUGETS_QESRS)),   to_number(decode(LSTARTS_QESRS, 4294967295, NULL, LDREADS_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, DREADS_QESRS)),   to_number(decode(LSTARTS_QESRS, 4294967295, NULL, LDWRITES_QESRS)), to_number(decode(LSTARTS_QESRS, 4294967295, NULL, DWRITES_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, LELAPTIME_QESRS)),  to_number(decode(LSTARTS_QESRS, 4294967295, NULL, ELAPTIME_QESRS)),   substr(SIZEPOLICY_QESRS, 1, 10),  to_number(decode(OPTIMAL_QESRS, 0, NULL, OPTIMAL_QESRS * 1024)),  to_number(decode(OPTIMAL_QESRS, 0, NULL, ONEPASS_QESRS * 1024)),  to_number(decode(OPTIMAL_QESRS, 0, NULL, LASTMEM_QESRS * 1024)),  decode(OPTIMAL_QESRS, 0, NULL,    substr(decode(LASTPASS_QESRS, 0, 'OPTIMAL',       to_char(LASTPASS_QESRS) || ' PASS' ||      decode(LASTPASS_QESRS, 1, '', 'ES')),     1, 10)),  to_number(decode(LASTDOP_QESRS, 0, NULL, LASTDOP_QESRS)),  to_number(decode(OPTIMAL_QESRS, 0, NULL, (OPTACTS_QESRS +            SPAACTS_QESRS + MPAACTS_QESRS))),  to_number(decode(OPTIMAL_QESRS, 0, NULL, OPTACTS_QESRS)),  to_number(decode(OPTIMAL_QESRS, 0, NULL, SPAACTS_QESRS)),  to_number(decode(OPTIMAL_QESRS, 0, NULL, MPAACTS_QESRS)),  to_number(decode(OPTIMAL_QESRS, 0, NULL, ATIME_QESRS)),    to_number(decode(MAXTSEG_QESRS, 0, NULL, MAXTSEG_QESRS)),   to_number(decode(LASTTSEG_QESRS, 0, NULL, LASTTSEG_QESRS)),  con_id, con_dbid  from X$QESRSTATALL p                                        where p.haddr_qesrs != p.phadd_qesrs
+++GV$SQL_REDIRECTION+++              select c.inst_id,c.kglhdadr,c.kglhdpar,c.kglnahsh,c.kglobt03,        c.kglobt09, c.kglobt17,c.kglobt18, c.kglobt02,  decode(r.reason,1,'INVALID OBJECT', 2,'ROWID',3,'QUERY REWRITE','READ ONLY'), r.error_code, r.position, r.sql_text_piece, r.error_msg, c.con_id  from x$kglcursor_child c, x$kkssrd r  where c.kglhdpar = r.parAddr and c.kglhdadr = r.kglhdadr
+++GV$SQL_REOPTIMIZATION_HINTS+++     select  inst_id, phadd_kkoar,         hashv_kkoar, sqlid_kkoar,         childno_kkoar, hintid_kkoar,         hinttext_kkoar, clientid_kkoar,         reparse_kkoar, con_id  from X$KKOAR_HINT
+++GV$SQL_SHARED_CURSOR+++            select inst_id, sql_id, kglhdpar, kglhdadr, childno, decode(bitand(bitvector, POWER(2,0)), POWER(2,  0), 'Y','N'),decode(bitand(bitvector, POWER(2,1)), POWER(2,  1), 'Y','N'),decode(bitand(bitvector, POWER(2,2)), POWER(2,  2), 'Y','N'),decode(bitand(bitvector, POWER(2,3)), POWER(2,  3), 'Y','N'),decode(bitand(bitvector, POWER(2,4)), POWER(2,  4), 'Y','N'),decode(bitand(bitvector, POWER(2,5)), POWER(2,  5), 'Y','N'),decode(bitand(bitvector, POWER(2,6)), POWER(2,  6), 'Y','N'),decode(bitand(bitvector, POWER(2,7)), POWER(2,  7), 'Y','N'),decode(bitand(bitvector, POWER(2,8)), POWER(2,  8), 'Y','N'),decode(bitand(bitvector, POWER(2,9)), POWER(2,  9), 'Y','N'),decode(bitand(bitvector, POWER(2,10)), POWER(2, 10), 'Y','N'),decode(bitand(bitvector, POWER(2,11)), POWER(2, 11), 'Y','N'),decode(bitand(bitvector, POWER(2,12)), POWER(2, 12), 'Y','N'),decode(bitand(bitvector, POWER(2,13)), POWER(2, 13), 'Y','N'),decode(bitand(bitvector, POWER(2,14)), POWER(2, 14), 'Y','N'),decode(bitand(bitvector, POWER(2,15)), POWER(2, 15), 'Y','N'),decode(bitand(bitvector, POWER(2,16)), POWER(2, 16), 'Y','N'),decode(bitand(bitvector, POWER(2,17)), POWER(2, 17), 'Y','N'),decode(bitand(bitvector, POWER(2,18)), POWER(2, 18), 'Y','N'),decode(bitand(bitvector, POWER(2,19)), POWER(2, 19), 'Y','N'), decode(bitand(bitvector, POWER(2,20)), POWER(2, 20), 'Y','N'),decode(bitand(bitvector, POWER(2,21)), POWER(2, 21), 'Y','N'),decode(bitand(bitvector, POWER(2,22)), POWER(2, 22), 'Y','N'),decode(bitand(bitvector, POWER(2,23)), POWER(2, 23), 'Y','N'),decode(bitand(bitvector, POWER(2,24)), POWER(2, 24), 'Y','N'),decode(bitand(bitvector, POWER(2,25)), POWER(2, 25), 'Y','N'),decode(bitand(bitvector, POWER(2,26)), POWER(2, 26), 'Y','N'),decode(bitand(bitvector, POWER(2,27)), POWER(2, 27), 'Y','N'),decode(bitand(bitvector, POWER(2,28)), POWER(2, 28), 'Y','N'),decode(bitand(bitvector, POWER(2,29)), POWER(2, 29), 'Y','N'),decode(bitand(bitvector, POWER(2,30)), POWER(2, 30), 'Y','N'),decode(bitand(bitvector, POWER(2,31)), POWER(2, 31), 'Y','N'),decode(bitand(bitvector, POWER(2,32)), POWER(2, 32), 'Y','N'),decode(bitand(bitvector, POWER(2,33)), POWER(2, 33), 'Y','N'),decode(bitand(bitvector, POWER(2,34)), POWER(2, 34), 'Y','N'),decode(bitand(bitvector, POWER(2,35)), POWER(2, 35), 'Y','N'),decode(bitand(bitvector, POWER(2,36)), POWER(2, 36), 'Y','N'),decode(bitand(bitvector, POWER(2,37)), POWER(2, 37), 'Y','N'),decode(bitand(bitvector, POWER(2,38)), POWER(2, 38), 'Y','N'),decode(bitand(bitvector, POWER(2,39)), POWER(2, 39), 'Y','N'),decode(bitand(bitvector, POWER(2,40)), POWER(2, 40), 'Y','N'),decode(bitand(bitvector, POWER(2,41)), POWER(2, 41), 'Y','N'),decode(bitand(bitvector, POWER(2,42)), POWER(2, 42), 'Y','N'),decode(bitand(bitvector, POWER(2,43)), POWER(2, 43), 'Y','N'),decode(bitand(bitvector, POWER(2,44)), POWER(2, 44), 'Y','N'),decode(bitand(bitvector, POWER(2,45)), POWER(2, 45), 'Y','N'),decode(bitand(bitvector, POWER(2,46)), POWER(2, 46), 'Y','N'),decode(bitand(bitvector, POWER(2,47)), POWER(2, 47), 'Y','N'),decode(bitand(bitvector, POWER(2,48)), POWER(2, 48), 'Y','N'),decode(bitand(bitvector, POWER(2,49)), POWER(2, 49), 'Y','N'),decode(bitand(bitvector, POWER(2,50)), POWER(2, 50), 'Y','N'),decode(bitand(bitvector, POWER(2,51)), POWER(2, 51), 'Y','N'),decode(bitand(bitvector, POWER(2,52)), POWER(2, 52), 'Y','N'),decode(bitand(bitvector, POWER(2,53)), POWER(2, 53), 'Y','N'),decode(bitand(bitvector, POWER(2,54)), POWER(2, 54), 'Y','N'),decode(bitand(bitvector, POWER(2,55)), POWER(2, 55), 'Y','N'),decode(bitand(bitvector, POWER(2,56)), POWER(2, 56), 'Y','N'),decode(bitand(bitvector, POWER(2,57)), POWER(2, 57), 'Y','N'),decode(bitand(bitvector, POWER(2,58)), POWER(2, 58), 'Y','N'),decode(bitand(bitvector, POWER(2,59)), POWER(2, 59), 'Y','N'),decode(bitand(bitvector, POWER(2,60)), POWER(2, 60), 'Y','N'),decode(bitand(bitvector, POWER(2,61)), POWER(2, 61), 'Y','N'),decode(bitand(bitvector, POWER(2,62)), POWER(2, 62), 'Y','N'),decode(bitand(bitvector, POWER(2,63)), POWER(2, 63
+++GV$SQL_SHARED_MEMORY+++            select /*+use_nl(h,c)*/ c.inst_id,kglnaobj,kglfnobj, kglnahsh, kglobt03, kglobhd6, rtrim(substr(ksmchcom, 1, instr(ksmchcom, ':', 1, 1) - 1)), ltrim(substr(ksmchcom,              -(length(ksmchcom) - (instr(ksmchcom, ':', 1, 1))),               (length(ksmchcom) - (instr(ksmchcom, ':', 1, 1)) + 1))), ksmchcom, ksmchptr, ksmchsiz, ksmchcls, ksmchtyp, ksmchpar, c.con_id  from x$kglcursor c, x$ksmhp h where ksmchds = kglobhd6 and kglhdadr != kglhdpar
+++GV$SQL_WORKAREA+++                 SELECT INST_ID,          PHADD_QKSMM,             HASHV_QKSMM,             SQLID_QKSMM,             CHILDNO_QKSMM,           WADDR_QKSMM,             substr(OPERTYPE_QKSMM, 1, 40),            to_number(decode(OPERTID_QKSMM, 65535, NULL, OPERTID_QKSMM)),           substr(SIZEPOLICY_QKSMM, 1, 10),          OPTIMAL_QKSMM * 1024,           ONEPASS_QKSMM * 1024,           LASTMEM_QKSMM * 1024,           substr(decode(LASTPASS_QKSMM, 0, 'OPTIMAL',                                        to_char(LASTPASS_QKSMM) || ' PASS' ||                                        decode(LASTPASS_QKSMM, 1, '', 'ES')),                 1, 10),                                                       LASTDOP_QKSMM,           (OPTACTS_QKSMM + SPAACTS_QKSMM + MPAACTS_QKSMM),          OPTACTS_QKSMM,           SPAACTS_QKSMM,           MPAACTS_QKSMM,           ATIME_QKSMM,           to_number(decode(MAXTSEG_QKSMM, 0, NULL, MAXTSEG_QKSMM*1024)),          to_number(decode(LASTTSEG_QKSMM, 0, NULL, LASTTSEG_QKSMM*1024)),          CON_ID          FROM X$QKSMMWDS
+++GV$SQL_WORKAREA_ACTIVE+++          select INST_ID,           SQLHASHV,           SQLID,           EXECSTA,           decode(execid, 0, to_number(NULL), execid),           WADDR,           substr(OPER_TYPE, 1, 40),           to_number(decode(OPID, 65535, NULL, OPID)),            substr(decode(bitand(MEM_FLAGS,1), 0, 'MANUAL', 'AUTO'), 1, 6),           SID,              to_number(decode(QCINSTID, 65535, NULL, QCINSTID)),           to_number(decode(QCSID, 65535, NULL, QCSID)),           ATIME,           WA_SIZE * 1024,           to_number(decode(bitand(MEM_FLAGS,1), 0, NULL, EXP_SIZE*1024)),           ACTUAL_MEM * 1024,           MAX_MEM * 1024,             PASSES,            to_number(decode(KTSSOTSN, '', NULL, KTSSOSIZE*1024)),           decode(KTSSOTSN, '', NULL, KTSSOTSN),           to_number(decode(KTSSOTSN, '', NULL, KTSSORFNO)),           to_number(decode(KTSSOTSN, '', NULL, KTSSOBNO)),           CON_ID    from   x$qesmmiwt
+++GV$SQL_WORKAREA_HISTOGRAM+++       select INST_ID,           LOWBND * 1024,           (HIBND * 1024)-1,           OPTIMAL,           ONEPASS,           MPASS,           MPASS+ONEPASS+OPTIMAL,           CON_ID    from   X$QESMMIWH
+++GV$SSCR_SESSIONS+++                SELECT inst_id, indx, ksusmser, decode(ksusmcrsta, 0, 'NONE', 1, 'MARKED', 2, 'SUSPENDED', 3, 'CAPINIT', 4, 'CAPTURED',5, 'RESINIT', 6, 'RESTORED',7, 'FAILED'),  decode(ksusmcrmod, 0, 'SESSION', 1, 'GLOBAL'),  decode(ksusmcrcsp, 0, 'NONE', 1, 'MINIMAL', 2, 'TYPICAL', 3, 'FULL'),  decode(ksusmcrncc, -1,'UNKNOWN', 0, 'NONE', ksusmcrncc),  ksusmcrncr, ksusmcropt,  ksusmcrsto,  con_id FROM x$ksusm WHERE (bitand(ksspaflg, 1) != 0)
+++GV$STANDBY_LOG+++                  select inst_id, slnum, decode(slpdb,0,'UNASSIGNED',to_number(slpdb)), slthr, slseq, slsiz*slbsz, slbsz, decode(slnab, 0, 0, (slnab-1)*slbsz), decode(bitand(slflg,1),0,'NO','YES'), decode(sign(slseq),0,'UNASSIGNED','ACTIVE'), to_number(sllos), to_date(sllot,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(slnxs), to_date(slnxt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(sllastscn), to_date(sllasttim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), con_id  from x$kccsl
+++GV$STATISTICS_LEVEL+++             select inst_id, name, description,          decode(session_status, 0, 'DISABLED', 1, 'ENABLED', 'UNKNOWN'),          decode(system_status, 0, 'DISABLED', 1, 'ENABLED', 'UNKNOWN'),          decode(activation_level, 0, 'BASIC', 1, 'TYPICAL', 'ALL'),          view_name,          decode(session_changeable, 0, 'NO', 'YES'), con_id          from x$prmsltyx
+++GV$STATNAME+++                     select inst_id,indx,ksusdnam,ksusdcls,ksusdhsh,ksusddsp,con_id from x$ksusd
+++GV$STREAMS_APPLY_COORDINATOR+++    select x.inst_id,x.sid_knst,x.serial_knst,x.applynum_knstacr,  x.applyname_knstacr,decode(x.state_knstacr,0,'INITIALIZING',        1,'APPLYING',2,'SHUTTING DOWN CLEANLY',3,'ABORTING',4,'IDLE'),x.total_applied_knstacr,decode(bitand(x.flag_knstacr,1),       0, x.total_waitdeps_knstacr,       1, (select sum(total_waitdeps_knstasl) from x$knstasl           where x.applynum_knstacr = applynum_knstasl)      ),x.total_waitcommits_knstacr,x.total_admin_knstacr,x.total_assigned_knstacr,x.total_received_knstacr, x.total_ignored_knstacr,x.total_rollbacks_knstacr, x.total_errors_knstacr, x.unassigned_complete_knstacr,x.auto_txnbufsize_knstacr, x.lwm_time_knstacr, x.lwm_msg_num_knstacr,x.lwm_msg_time_knstacr,x.hwm_time_knstacr, x.hwm_msg_num_knstacr, x.hwm_msg_time_knstacr,x.startup_time_knstacr, x.elapsed_schedule_time_knstacr, x.elapsed_idle_time_knstacr, x.lwm_position_knstacr, x.hwm_position_knstacr, x.processed_msg_num_knstacr, x.con_id, x.active_server_cnt_knstacr  from x$knstacr x  where x.type_knst=1        and bitand(x.purpose_flag_knstacr, 12) = 0        and exists (select 1 from v$session s                    where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$STREAMS_APPLY_READER+++         select inst_id,sid_knst,serial_knst,applynum_knstasl, applyname_knstasl,decode(state_knstasl,0,'IDLE',8,'DEQUEUE MESSAGES',10,'SCHEDULE MESSAGES',15,'INITIALIZING',16,'SPILLING',17,'PAUSED - WAITING FOR DDL TO COMPLETE'),total_msg_knstasl, total_spill_msg_knstasl, last_rcv_time_knstasl,last_rcv_msg_num_knstasl, last_rcv_msg_time_knstasl, sga_used_knstasl, elapsed_dequeue_time_knstasl, elapsed_schedule_time_knstasl,elapsed_spill_time_knstasl,last_browse_num_knstasl, oldest_scn_num_knstasl, last_browse_seq_knstasl,last_deq_seq_knstasl,oldest_xid_usn_knstasl,oldest_xid_slt_knstasl,oldest_xid_sqn_knstasl,spill_lwm_scn_knstasl,proxy_sid_knstasl, proxy_serial_knstasl, proxy_spid_knstasl,(SELECT sesstat.ksusestv         FROM   x$ksusd stat, x$ksusesta sesstat, x$ksuse sess WHERE  x.proxy_sid_knstasl=sesstat.ksusenum    AND  x.proxy_sid_knstasl=sess.indx    AND  x.proxy_serial_knstasl=sess.ksuseser    AND  bitand(sess.ksspaflg,1)!=0    AND  bitand(sess.ksuseflg,1)!=0    AND  sesstat.ksusestn = stat.indx    AND  bitand(sesstat.ksspaflg,1)!=0    AND  bitand(sesstat.ksuseflg,1)!=0    AND  sesstat.ksusestn<(select ksusgstl from x$ksusgif)   AND  stat.ksusdnam = 'bytes received via SQL*Net from client'),last_rcv_pos_knstasl, last_browse_pos_knstasl, oldest_pos_knstasl,spill_lwm_pos_knstasl, oldest_xidtxt_knstasl,num_dep_lcrs_knstasl, num_wmdeps_knstasl, num_in_memory_lcrs_knstasl,sga_allocated_knstasl, con_id from x$knstasl x where type_knst=7   and bitand(flag_knstasl, 12) = 0   and exists (select 1 from v$session s  where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$STREAMS_APPLY_SERVER+++         select inst_id,sid_knst,serial_knst,applynum_knstasl, applyname_knstasl,slavid_knstasl,decode(state_knstasl,0,'IDLE',1,'POLL SHUTDOWN',2,'RECORD LOW-WATERMARK',3,'ADD PARTITION',4,'DROP PARTITION',5,'EXECUTE TRANSACTION',6,'WAIT COMMIT',7,'WAIT DEPENDENCY',8,'GET TRANSACTIONS',9,'WAIT FOR NEXT CHUNK',12,'ROLLBACK TRANSACTION',13,'TRANSACTION CLEANUP',14,'REQUEST UA SESSION',15,'INITIALIZING',16,'SPILL',18,'WAIT FOR CLIENT',19,'INACTIVE'), xid_usn_knstasl,xid_slt_knstasl,xid_sqn_knstasl,cscn_knstasl,depxid_usn_knstasl,depxid_slt_knstasl,depxid_sqn_knstasl,depcscn_knstasl,msg_num_knstasl,total_assigned_knstasl,total_admin_knstasl,total_rollbacks_knstasl,total_msg_knstasl, last_apply_time_knstasl, last_apply_msg_num_knstasl,last_apply_msg_time_knstasl,elapsed_dequeue_time_knstasl, elapsed_apply_time_knstasl,commit_position_knstasl, dep_commit_position_knstasl,last_apply_pos_knstasl, nosxid_knstasl, depnosxid_knstasl, con_id, total_lcrs_retried_knstasl, lcr_retry_iter_knstasl, total_txns_retried_knstasl, txn_retry_iter_knstasl, total_txns_discarded_knstasl  from x$knstasl x where type_knst=2 and bitand(flag_knstasl, 12) = 0  and (x.sid_knst = 0 or exists (select 1 from v$session s where s.sid=x.sid_knst and s.serial#=x.serial_knst))
+++GV$STREAMS_CAPTURE+++              SELECT x.inst_id, x.sid_knst, x.serial_knst, x.capnum_knstcap,         x.capname_knstcap, x.logminer_id_knstcap, x.startup_time_knstcap,        case when (x.state_knstcap = 10 and                    d.loaded = 'ACTIVE')             then d.current_state || ' ' || d.progress              when (x.state_knstcap = 18)              then 'WAIT FOR ' || x.subscriber_num                               || ' SUBSCRIBER(S) INITIALIZING'              else DECODE(x.state_knstcap,                     0,  'INITIALIZING',    1,'CAPTURING CHANGES',                    2,  'EVALUATING RULE', 3,'ENQUEUING MESSAGE',                     4,  'SHUTTING DOWN',   5,'ABORTING',                     6,  'CREATING LCR',                     7,  DECODE(x.missing_logfile_info_knstcap,                                NULL, 'WAITING FOR DICTIONARY REDO',                                'WAITING FOR DICTIONARY REDO: ' ||                                x.missing_logfile_info_knstcap),                    8,  DECODE(x.missing_logfile_info_knstcap,                                NULL, 'WAITING FOR REDO',                                'WAITING FOR REDO: ' ||                                x.missing_logfile_info_knstcap),                    9,'PAUSED FOR FLOW CONTROL',                     10, 'DICTIONARY INITIALIZATION',                    11, 'WAITING FOR APPLY TO BE ENABLED',                     12, 'CONNECTING TO APPLY DATABASE',                     13, 'WAITING FOR PROPAGATION TO BE ENABLED',                     15, 'WAITING FOR A SUBSCRIBER TO BE ADDED',                     16, 'WAITING FOR BUFFERED QUEUE TO SHRINK',                     17, 'SUSPENDED FOR AUTO SPLIT/MERGE',                     19, 'WAITING FOR INACTIVE DEQUEUERS',                     20, 'WAITING FOR TRANSACTION')         end,         m.msgs_filtered, m.msgs_kept, m.msgs_total, x.total_captured_knstcap,        x.recent_time_knstcap, x.recent_msg_num_knstcap,        x.recent_msg_time_knstcap, x.total_messages_created_knstcap,        x.total_full_evaluations_knstcap, x.total_msg_enq_knstcap,        x.enqueue_time_knstcap, x.enqueue_msg_num_knstcap,        x.enqueue_msg_time_knstcap,        DECODE(bitand(x.flags_knstcap, 1),               0, upstream.next_scn,               1, DECODE(bitand(x.flags_knstcap, 8),                         0, downstream.next_scn,                            downstream_real.next_scn)),         DECODE(bitand(x.flags_knstcap, 1),               0, upstream.next_time,               1, DECODE(bitand(x.flags_knstcap, 8),                         0, downstream.next_time,                            downstream_real.next_time)),                    x.elapsed_capture_time_knstcap, x.elapsed_rule_time_knstcap,        x.elapsed_enqueue_time_knstcap, x.elapsed_lcr_time_knstcap, x.elapsed_wait_time_knstcap, x.elapsed_pause_time_knstcap,         x.state_changed_time_knstcap, x.appname_knstcap,         x.apply_dblink_knstcap, x.apply_messages_sent_knstcap,         (SELECT sesstat.ksusestv         FROM   x$ksusd stat, x$ksusesta sesstat, x$ksuse sess         WHERE x.sid_knst=sesstat.ksusenum            AND x.sid_knst=sess.indx            AND x.serial_knst=sess.ksuseser            AND bitand(sess.ksspaflg,1)!=0            AND bitand(sess.ksuseflg,1)!=0            AND sesstat.ksusestn = stat.indx            AND bitand(sesstat.ksspaflg,1)!=0            AND bitand(sesstat.ksuseflg,1)!=0            AND sesstat.ksusestn<(select ksusgstl from x$ksusgif)         AND stat.ksusdnam = 'bytes sent via SQL*Net to dblink'),         DECODE(BITAND(x.flags_knstcap, 6), 2, 1, 4, 2, 0),               'Streams',         x.sga_used_knstcap, x.sga_allocated_knstcap,        brm.value, srs.value, x.con_id  FROM   x$knstcap x,        (SELECT session_id,                sum(skipped_filter_calls) msgs_filtered,                sum(kept_filter_calls) msgs_kept,                sum(total_filter_calls) msgs_total         FROM x$logmnr_process         GROUP BY session_id) m,        (SELECT last_write_scn next_scn,
+++GV$STREAMS_MESSAGE_TRACKING+++     SELECT inst_id, tracking_label_knstmt, tag_knstmt, component_name_knstmt,         component_type_knstmt, action_knstmt, action_details_knstmt,         timestamp_knstmt, message_create_time_knstmt, message_number_knstmt,         tracking_id_knstmt, source_database_name_knstmt, object_owner_knstmt,         object_name_knstmt, xid_knstmt, command_type_knstmt,         message_position_knstmt, 'Streams', con_id                    FROM   x$knstmt    WHERE  procusectxid_knstmt = 0
+++GV$STREAMS_POOL_ADVICE+++          select inst_id, size_knlarow, round(size_knlarow / basesize_knlarow, 4), spillcnt_knlarow, spilltime_knlarow, unspillcnt_knlarow, unspilltime_knlarow, con_id from x$knlarow
+++GV$STREAMS_POOL_STATISTICS+++      SELECT inst_id, memory_allocated_knlasg, strmpool_size_knlasg,         sga_target_knlasg, shrink_phase_knlasg,         advice_disabled_knlasg, con_id  FROM x$knlasg
+++GV$STREAMS_TRANSACTION+++          SELECT inst_id, strmname_knsttxn, type_knsttxn,        xidusn_knsttxn, xidslt_knsttxn, xidsqn_knsttxn,         msg_count_knsttxn, actual_msg_count_knsttxn,         first_msg_time_knsttxn, first_msg_num_knsttxn,         last_msg_time_knsttxn,  last_msg_num_knsttxn,         first_msg_pos_knsttxn,  last_msg_pos_knsttxn, nosxid_knsttxn,         'Streams', con_id                                  FROM   x$knsttxn   WHERE procusectxid_knsttxn = 0
+++GV$SUBCACHE+++                     select inst_id,kglnaown, kglnaobj, kglobtyp, kqlfshpn, kqlfscid,  kqlfsscc, kqlfsesp, kqlfsasp, kqlfsusp, con_id  from x$kqlset
+++GV$SUBSCR_REGISTRATION_STATS+++    select inst_id, reg_id, num_ntfns, num_grouping_ntfns,         num_ntfns_current_group, last_ntfn_start_time,         last_ntfn_sent_time, total_emon_latency, emon_server_id,         all_emon_servers, total_payload_bytes_sent,         num_retries, total_plsql_exec_time/1000000, last_err, last_err_time,         last_update_time, num_pending_ntfns, total_pending_ntfn_bytes, 0,         con_id  from x$kkcnrstat    union all  select inst_id, reg_id, num_ntfns, num_grouping_ntfns,         num_ntfns_current_group, last_ntfn_start_time,         last_ntfn_sent_time, total_emon_latency, emon_server_id,         NULL, total_payload_bytes_sent,         num_retries, 0, last_err, last_err_time,         last_update_time, 0, 0, total_exec_time/1000000, con_id   from x$kkcneregstat
+++GV$SYSAUX_OCCUPANTS+++             SELECT inst_id, occ_name_kewxocf, occ_desc_kewxocf,                 sch_name_kewxocf, move_proc_kewxocf,                 move_desc_kewxocf, space_usage_kewxocf, con_id          FROM   x$kewxocf
+++GV$SYSMETRIC+++                    SELECT inst_id, begtime, endtime, intsize_csec,          groupid, metricid, name, value, unit, con_id          FROM   x$kewmdrmv          WHERE flag1 = 1 AND groupid in (2,3)
+++GV$SYSMETRIC_HISTORY+++            SELECT inst_id, begtime, endtime, intsize_csec,            groupid, metricid, name, value, unit, con_id          FROM   x$kewmdrmv          WHERE groupid in (2,3)
+++GV$SYSMETRIC_SUMMARY+++            SELECT inst_id, begtime, endtime, intsize_csec,            groupid, metricid, name, numintv, max, min,            avg, std, unit, con_id          FROM   x$kewmsmdv          WHERE groupid = 2
+++GV$SYSSTAT+++                      select inst_id,ksusgstn,ksusdnam,ksusdcls,ksusgstv,ksusdhsh, con_id from x$ksusgsta
+++GV$SYSTEM_CURSOR_CACHE+++          select inst_id,kgicsopn,kgicshit,decode(kgicsopn,0,1,kgicshit/kgicsopn), con_id from x$kgics
+++GV$SYSTEM_EVENT+++                 select d.inst_id, d.kslednam, (s.ksleswts_un + s.ksleswts_fg + s.ksleswts_bg), (s.kslestmo_un + s.kslestmo_fg + s.kslestmo_bg), round((s.kslestim_un + s.kslestim_fg + s.kslestim_bg)/10000),  round((s.kslestim_un + s.kslestim_fg + s.kslestim_bg)/ (10000 * (s.ksleswts_un + s.ksleswts_fg + s.ksleswts_bg)), 2), (s.kslestim_un + s.kslestim_fg + s.kslestim_bg), s.ksleswts_fg, s.kslestmo_fg, round(s.kslestim_fg/10000), round(s.kslestim_fg/decode(s.ksleswts_fg, 0, 1, 10000 * s.ksleswts_fg), 2), s.kslestim_fg, d.ksledhash, d.ksledclassid, d.ksledclass#, d.ksledclass, s.con_id  from x$kslei s, x$ksled d  where (s.ksleswts_un > 0 or s.ksleswts_fg > 0 or s.ksleswts_bg > 0) and s.kslesevt = d.indx
+++GV$SYSTEM_FIX_CONTROL+++           select  INST_ID,        BUGNO_QKSBGSYROW,        VALUE_QKSBGSYROW,        FID_QKSBGSYROW,        DESC_QKSBGSYROW,        OFE_QKSBGSYROW,        EVENT_QKSBGSYROW,        ISDEFAULT_QKSBGSYROW,         CON_ID from x$qksbgsys
+++GV$SYSTEM_PARAMETER+++             select x.inst_id,x.indx+1,ksppinm,ksppity,ksppstvl, ksppstdvl, ksppstdfl,  ksppstdf, decode(bitand(ksppiflg/256,1),1,'TRUE','FALSE'),  decode(bitand(ksppiflg/65536,3),1,'IMMEDIATE',2,'DEFERRED',                                  3,'IMMEDIATE','FALSE'),  decode(bitand(ksppiflg/524288,1),1,'TRUE','FALSE'),  decode(bitand(ksppiflg,4),4,'FALSE',                                     decode(bitand(ksppiflg/65536,3), 0, 'FALSE', 'TRUE')),     decode(bitand(ksppstvf,7),1,'MODIFIED','FALSE'),  decode(bitand(ksppstvf,2),2,'TRUE','FALSE'),  decode(bitand(ksppilrmflg/64, 1), 1, 'TRUE', 'FALSE'),  decode(bitand(ksppilrmflg/268435456, 1), 1, 'TRUE', 'FALSE'),  ksppdesc, ksppstcmnt, ksppihash, y.con_id from x$ksppi x, x$ksppsv y  where (x.indx = y.indx) and  bitand(ksppiflg,268435456) = 0 and  ((translate(ksppinm,'_','#') not like '##%') and    ((translate(ksppinm,'_','#') not like '#%')      or (ksppstdf = 'FALSE') or      (bitand(ksppstvf,5) > 0)))
+++GV$SYSTEM_PARAMETER2+++            select x.inst_id,kspftctxpn,ksppinm,ksppity,kspftctxvl,  kspftctxdvl, kspftctxdf,  decode(bitand(ksppiflg/256,1),1,'TRUE','FALSE'),  decode(bitand(ksppiflg/65536,3),1,'IMMEDIATE',2,'DEFERRED',                                  3,'IMMEDIATE','FALSE'),  decode(bitand(ksppiflg/524288,1),1,'TRUE','FALSE'),  decode(bitand(ksppiflg,4),4,'FALSE',                                     decode(bitand(ksppiflg/65536,3), 0, 'FALSE', 'TRUE')),     decode(bitand(kspftctxvf,7),1,'MODIFIED','FALSE'),  decode(bitand(kspftctxvf,2),2,'TRUE','FALSE'),  decode(bitand(ksppilrmflg/64, 1), 1, 'TRUE', 'FALSE'),  decode(bitand(ksppilrmflg/268435456, 1), 1, 'TRUE', 'FALSE'),  ksppdesc, kspftctxvn,  kspftctxct, y.con_id from x$ksppi x, x$ksppsv2 y  where ((x.indx+1) = kspftctxpn) and  ((translate(ksppinm,'_','#') not like '##%') and    (translate(ksppinm,'_','#') not like '#%'     or (kspftctxdf = 'FALSE') or     (bitand(kspftctxvf,5) > 0)))
+++GV$SYSTEM_PARAMETER3+++            select x.inst_id,x.indx+1,ksppinm,ksppstdvl, ksppstdfl, y.con_id  from x$ksppi x, x$ksppsv y  where (x.indx = y.indx)
+++GV$SYSTEM_PARAMETER4+++            select x.inst_id,kspftctxsid,kspftctxpn,ksppinm,ksppity,kspftctxdvl,  kspftctxvn,kspftctxct, ksppilrmflg, y.con_id  from x$ksppi x, x$ksppsv2 y  where ((x.indx+1) = kspftctxpn) and  ((kspftctxdf = 'FALSE') or (bitand(kspftctxvf,8) = 8))
+++GV$SYSTEM_WAIT_CLASS+++            select s.inst_id, s.kslscsclsid, s.kslscscls, s.kslscsclsname, (s.kslscswts_un + s.kslscswts_fg + s.kslscswts_bg), round((s.kslscstim_un + s.kslscstim_fg + s.kslscstim_bg)/10000), s.kslscswts_fg, round(s.kslscstim_fg/10000), s.con_id  from x$kslscs s where s.kslscswts_un > 0 or s.kslscswts_fg > 0 or s.kslscswts_un > 0
+++GV$SYS_OPTIMIZER_ENV+++            select INST_ID,                        PNUM_QKSCESYROW,                PNAME_QKSCESYROW,               FID_QKSCESYROW,                 decode(bitand(FLAGS_QKSCESYROW, 2), 0, 'NO', 'YES'),           PVALUE_QKSCESYROW,                                             DEFPVALUE_QKSCESYROW,                                          CON_ID                                                  from   X$QKSCESYS                                              where  bitand(FLAGS_QKSCESYROW, 8) = 0                           and  (bitand(FLAGS_QKSCESYROW, 4) = 0                                or bitand(FLAGS_QKSCESYROW, 2) = 0)
+++GV$SYS_REPORT_REQUESTS+++          select inst_id, con_id, classname_kerpirepreq, reportref_kerpirepreq,         refLen_kerpirepreq, priority_kerpirepreq, gentime_kerpirepreq    from x$kerpirepreq
+++GV$SYS_REPORT_STATS+++             select inst_id, con_id,         decode(execmode_kerpistats,0,'REGULAR',2,'FULL_CAPTURE'),         numqueued_kerpistats,         numfailed_kerpistats, numfailed_cycles_kerpistats,         lastFailedCycleTime_kerpistats, cycles_since_reset_kerpistats,         lastcycletime_kerpistats, laststatresettime_kerpistats,         lastpurgetime_kerpistats, available_dbtime_kerpistats,         aggdbtime_kerpistats, aggcputime_kerpistats,         agguseriotime_kerpistats,         dbtime_kerpistats, cputime_kerpistats,         useriotime_kerpistats    from x$kerpistats
+++GV$SYS_TIME_MODEL+++               select map.inst_id, map.extid, map.sname, sysv.kewsval, sysv.con_id  from x$kewssmap map, x$kewssysv sysv  where map.offst = sysv.kewsidx and map.aggid = 1 and  (map.stype = 2 or map.stype = 3)
+++GV$TABLESPACE+++                   select inst_id,tstsn,tsnam,       decode(bitand(tsflg, 1+2), 1, 'NO', 2,'NO','YES'),  decode(bitand(tsflg, 4), 4,'YES','NO'),  decode(bitand(tsflg, 8), 8,'NO','YES'),  decode(bitand(tsflg, 16+32), 16, 'ON', 32, 'OFF', to_char(null)), con_id from x$kccts where tstsn != -1
+++GV$TEMPFILE+++                     select tf.inst_id, tf.tfnum, to_number(tf.tfcrc_scn), to_date(tf.tfcrc_tim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), tf.tftsn, tf.tfrfn, decode(bitand(tf.tfsta, 128),        128,'ONLINE',        decode(bitand(tf.tfsta, 2),0,'OFFLINE',2,'ONLINE','UNKNOWN')), decode(bitand(tf.tfsta, 12), 0,'DISABLED',4, 'READ ONLY', 12, 'READ WRITE',                                                                  'UNKNOWN'), fh.fhtmpfsz*tf.tfbsz, fh.fhtmpfsz,  tf.tfcsz*tf.tfbsz,tf.tfbsz, fn.fnnam, tf.con_id  from x$kcctf tf, x$kccfn fn, x$kcvfhtmp fh  where fn.fnfno=tf.tfnum and fn.fnfno=fh.htmpxfil and tf.tffnh=fn.fnnum  and tf.tfdup!=0 and bitand(tf.tfsta, 32) <> 32  and fn.fntyp=7 and fn.fnnam is not null
+++GV$TEMPORARY_LOBS+++               select abs.inst_id, abs.sid,                       SUM(NVL(kdlt.kdltctmp, 0)) kdltctmp,               SUM(NVL(kdlt.kdltnctmp, 0)) kdltnctmp,             abs.count, abs.con_id                              from x$abstract_lob abs left outer join x$kdlt kdlt          on abs.inst_id = kdlt.inst_id and          abs.sid = kdlt.kdltsno          where abs.sid = (SELECT SYS_CONTEXT('USERENV', 'SID') FROM DUAL) OR          (abs.count > 0 OR kdltctmp > 0 OR kdltnctmp > 0)                          group by abs.inst_id, abs.sid, abs.count, abs.con_id                         order by abs.sid
+++GV$TEMPSTAT+++                     select k.inst_id,k.kcftiofno,k.kcftiopyr,k.kcftiopyw,k.kcftiopbr,k.kcftiopbw, k.kcftiosbr,round(k.kcftioprt / 10000),round(k.kcftiopwt / 10000), round(k.kcftiosbt / 10000),round(k.kcftioavg / 10000), round(k.kcftiolst / 10000),round(k.kcftiomin / 10000), round(k.kcftiormx / 10000),round(k.kcftiowmx / 10000), k.con_id from x$kcftio k,x$kcctf f where f.tfdup <> 0 and f.tfnum=k.kcftiofno
+++GV$TEMPUNDOSTAT+++                 select inst_id,      to_date(KTUTSTRBEGTIME,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),      to_date(KTUTSTRENDTIME,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),      KTUTSTTSN, KTUTSTTCT, KTUTSTMTC, KTUTSTMQL, KTUTSTRMQI,      KTUTSTUSU, KTUTSTECT, KTUTSTUCT, KTUTSTSOC, KTUTSTOOS,      CON_ID    from X$KTUTST
+++GV$TEMP_CACHE_TRANSFER+++          select x.inst_id, kcftiofno,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, x.con_id  from x$kcftio x, x$kcctf tf         where x.kcftiofno = tf.tfnum
+++GV$TEMP_EXTENT_MAP+++              select /*+ ordered use_nl(me) */ me.inst_id, ts.name, me.ktftmetfno, me.ktftmebno, me.ktftmeblks*ts.blocksize, me.ktftmeblks, me.ktftmeinst, me.ktftmefno, me.con_id from ts$ ts, x$ktftme me where ts.contents$ = 1 and ts.bitmapped <> 0 and ts.online$ = 1 and ts.ts# = me.ktftmetsn
+++GV$TEMP_EXTENT_POOL+++             select /*+ ordered use_nl(fc) */ fc.inst_id, ts.name, fc.ktstfctfno, fc.ktstfcec, fc.ktstfceu, fc.ktstfcbc, fc.ktstfcbu, fc.ktstfcbc*ts.blocksize, fc.ktstfcbu*ts.blocksize, fc.ktstfcfno, fc.con_id from ts$ ts, x$ktstfc fc where ts.contents$ = 1 and ts.bitmapped <> 0 and ts.online$ = 1 and ts.ts# = fc.ktstfctsn
+++GV$TEMP_PING+++                    select x.inst_id, kcftiofno,  0, 0, 0, 0, 0, 0, 0, 0,       0, 0, 0, 0, 0, 0, 0, 0,       0, 0, 0, 0, 0, 0, 0, 0, 0, x.con_id     from x$kcftio x, x$kcctf tf   where x.kcftiofno = tf.tfnum
+++GV$TEMP_SPACE_HEADER+++            select /*+ ordered use_nl(hc) */ hc.inst_id, ts.name, hc.ktfthctfno, (hc.ktfthcsz - hc.ktfthcfree)*ts.blocksize, (hc.ktfthcsz - hc.ktfthcfree), hc.ktfthcfree*ts.blocksize, hc.ktfthcfree, hc.ktfthcfno, hc.con_id from ts$ ts, x$ktfthc hc where ts.contents$ = 1 and ts.bitmapped <> 0 and ts.online$ = 1 and ts.ts# = hc.ktfthctsn and hc.ktfthccval = 0
+++GV$THREAD+++                       select rt.inst_id,rtnum,decode(bitand(rtsta,1),1,'OPEN','CLOSED'), decode(bitand(rtsta,6),0,'DISABLED',2,'PRIVATE',6,'PUBLIC','UNKNOWN'), rtnlf,tirsid,to_date(rtots,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), rtcln,rtseq, to_number(rtckp_scn), to_date(rtckp_tim,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(rtenb), to_date(rtets,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), to_number(rtdis), to_date(rtdit,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), cpodr_seq, cpodr_bno, to_number(cpods), to_date(cpodt,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), rt.con_id  from x$kccrt rt, x$kcctir tr, x$kcccp  where rtnlf != 0 and tr.inst_id = rt.inst_id  and tirnum = rtnum and cptno = rtnum
+++GV$THRESHOLD_TYPES+++              SELECT t.inst_id, mid_kelrtd, gid_kelrtd, opmask_kelrtd,            typnam_keltosd, alrtid_kelrtd, valtype_kelrtd, t.con_id          FROM x$kelrtd t, x$keltosd o          WHERE typid_keltosd = objtype_kelrtd
+++GV$TIMER+++                        select inst_id,ksutmtim,con_id from x$ksutm
+++GV$TIMEZONE_FILE+++                select FILENAME, VERSION, CON_ID from X$TIMEZONE_FILE
+++GV$TIMEZONE_NAMES+++               select TZNAME, TZABBREV, CON_ID from X$TIMEZONE_NAMES
+++GV$TOPLEVELCALL+++                 select inst_id, indx , orafn_name, con_id  from x$orafn where indx=orafn_number
+++GV$TRANSACTION+++                  select inst_id,ktcxbxba,kxidusn,kxidslt,kxidsqn,ktcxbkfn,kubablk, kubaseq,kubarec, decode(ktcxbsta,0,'IDLE',1,'COLLECTING',2,'PREPARED',3,'COMMITTED',                 4,'HEURISTIC ABORT',5,'HEURISTIC COMMIT',                 6,'HEURISTIC DAMAGE',7,'TIMEOUT',9,'INACTIVE',                 10,'ACTIVE',11,'PTX PREPARED',12,'PTX COMMITTED',                 'UNKNOWN'), ktcxbstm,ktcxbssb,ktcxbssw, ktcxbsen,ktcxbsfl,ktcxbsbk,ktcxbssq,ktcxbsrc, ktcxbses,ktcxbflg, decode(bitand(ktcxbflg,16),0,'NO','YES'), decode(bitand(ktcxbflg,32),0,'NO','YES'), decode(bitand(ktcxbflg,64),0,'NO','YES'), decode(bitand(ktcxbflg,8388608),0,'NO','YES'), ktcxbnam, ktcxbpus,ktcxbpsl,ktcxbpsq, ktcxbpxu,ktcxbpxs,ktcxbpxq, ktcxbdsb, ktcxbdsw, ktcxbubk,ktcxburc,ktcxblio,ktcxbpio,ktcxbcrg,ktcxbcrc, to_date(ktcxbstm,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'), ktcxbdsb, ktcxbdsw,  ktcxbssc, ktcxbdsc, ktcxbxid, ktcxbpid, ktcxbpxi, con_id  from x$ktcxb where bitand(ksspaflg,1)!=0 and bitand(ktcxbflg,2)!=0
+++GV$TRANSACTION_ENQUEUE+++          select  s.inst_id,l.ktcxbxba,l.ktcxblkp,s.ksusenum,r.ksqrsidt,r.ksqrsid1,          r.ksqrsid2, l.ksqlkmod, l.ksqlkreq,l.ksqlkctim,l.ksqlklblk, r.con_id  from x$ktcxb l,x$ksuse s,x$ksqrs r where l.ksqlkses=s.addr and  bitand(l.ksspaflg,1)!=0 and (l.ksqlkmod!=0 or l.ksqlkreq!=0) and  l.ksqlkres=r.addr
+++GV$TRANSPORTABLE_PLATFORM+++       SELECT INST_ID, PLATFORM_ID, PLATFORM_NAME,          decode(endian_format, 1,'Big' ,0,'Little','UNKNOWN FORMAT'), CON_ID          FROM  x$kcpxpl
+++GV$TSDP_SUPPORTED_FEATURE+++       select            INST_ID, KZDPSUPSFNM, KZDPSUPSFFN, KZDPSUPSFCOM, CON_ID          from X$KZDPSUPSF
+++GV$TSM_SESSIONS+++                 select  inst_id,  indx,  ksusmser,  decode(ksusmsta,         0,  'NONE',         1,  'SELECTED',         2,  'COMMITED SELECT',         3,  'READY FOR PREPARE',         4,  'PREPARED',         5,  'READY FOR SWITCH',         6,  'SWITCHED',         7,  'FAILED',         8,  'READY FOR STATE TRANSFER',         9,  'IN STATE TRANSFER',         10, 'END OF STATE TRANSFER',         'UNKNOWN'),  decode(bitand(ksusmflg, 1),         1, 'NO',         decode(ksusmbnd,                0, decode(bitand(ksusmflg, 8),                          8, 'NO',                          'YES'),                'YES')),  decode(bitand(ksusmflg, 1), 1, 'NO', 'YES'),  decode(bitand(ksusmflg, 8), 8, 'NO', 'YES'),  decode(bitand(ksusmflg, 16), 16, 'YES', 'NO'),  ksusmnmr,  ksusmnmi,  ksusmntr,  ksusmnti,  decode(ksusmbnd, 0, 'NEVER', 1, 'CALL', 2, 'TRANSACTION', 3, 'APPLICATION',         'UNKNOWN'),  decode(bitand(ksusmflg, 4), 4, 'YES', 'NO'),  ksusmcst,  ksusmdst,  ksusmnrt,  ksusmbcm,  ksusmstm,  ksusmseq,  con_id     from x$ksusm  where (bitand(ksspaflg, 1) != 0)  and   (bitand(ksusmsfl, 1) != 0)
+++GV$TYPE_SIZE+++                    select inst_id,kqfszcom,kqfsztyp,kqfszdsc,kqfszsiz, con_id  from x$kqfsz
+++GV$UNDOSTAT+++                     select inst_id,      to_date(KTUSMSTRBEGTIME,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),      to_date(KTUSMSTRENDTIME,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),      KTUSMSTTSN, KTUSMSTUSU, KTUSMSTTCT, KTUSMSTMQL, KTUSMSTRMQI, KTUSMSTMTC,      KTUSMSTUAC, KTUSMSTUBS, KTUSMSTUBR, KTUSMSTXAC, KTUSMSTXBS,  KTUSMSTXBR,      KTUSMSTSOC, KTUSMSTOOS, KTUSMSTABK, KTUSMSTUBK, KTUSMSTEBK,  KTUSMSTTUR,      CON_ID    from X$KTUSMST
+++GV$UNIFIED_AUDIT_TRAIL+++          select inst_id, audit_type, sessionid, proxy_sessionid,         os_user, host_name, terminal, instance_id, dbid,         authentication_type, userid, proxy_userid, external_userid,         global_userid, client_program_name, dblink_info,         xs_user_name, xs_sessionid,         entry_id, statement_id, event_timestamp, action, return_code,         os_process, transaction_id, scn, execution_id, obj_owner, obj_name,           sql_text, sql_binds, application_contexts,         client_identifier, new_owner, new_name, object_edition,           system_privilege_used, system_privilege, audit_option,           object_privileges, role, target_user,           excluded_user, excluded_schema, excluded_object, additional_info,           unified_audit_policies, fga_policy_name, xs_inactivity_timeout,           xs_entity_type, xs_target_principal_name, xs_proxy_user_name,           xs_datasec_policy_name, xs_schema_name,           xs_callback_event_type, xs_package_name,           xs_procedure_name, xs_enabled_role, xs_cookie,           xs_ns_name, xs_ns_attribute, xs_ns_attribute_old_val,           xs_ns_attribute_new_val,           dv_action_code, dv_action_name, dv_extended_action_code, dv_grantee,           dv_return_code, dv_action_object_name,           dv_rule_set_name, dv_comment, dv_factor_context,           dv_object_status, ols_policy_name, ols_grantee, ols_max_read_label,           ols_max_write_label, ols_min_write_label, ols_privileges_granted,           ols_program_unit_name, ols_privileges_used, ols_string_label,           ols_label_component_type, ols_label_component_name,           ols_parent_group_name, ols_old_value, ols_new_value,           rman_session_recid, rman_session_stamp, rman_operation,           rman_object_type, rman_device_type,           dp_text_parameters1, dp_boolean_parameters1,           direct_path_num_columns_loaded,           con_id from x$unified_audit_trail
+++GV$VERSION+++                      select inst_id, banner, con_id from x$version
+++GV$VPD_POLICY+++                   select c.inst_id,c.kglhdadr,c.kglhdpar,c.kglnahsh, c.kglobt03,         c.kglobt09, p.kzrtpdow,p.kzrtpdon,p.kzrtpdgp,p.kzrtpdpy,p.kzrtpdpo,         p.kzrtpdtx, c.con_id  from x$kglcursor_child c, x$kzrtpd p where c.kglhdpar = p.kzrtpdpa and c.kglhdadr = p.kzrtpdad
+++GV$WAITCLASSMETRIC+++              SELECT inst_id, begtime, endtime, intsize_csec,            wait#, wait_id, average_waiter_count,            dbtime_in_wait, time_waited, wait_count,            time_waited_fg, wait_count_fg, con_id          FROM   x$kewmevmv          WHERE flag1 = 1 AND GROUPID = 1
+++GV$WAITCLASSMETRIC_HISTORY+++      SELECT inst_id, begtime, endtime, intsize_csec,            wait#, wait_id, average_waiter_count,            dbtime_in_wait, time_waited, wait_count,            time_waited_fg, wait_count_fg, con_id          FROM   x$kewmevmv          WHERE GROUPID = 1
+++GV$WAITSTAT+++                     select inst_id,decode(mod(indx,19),1,'data block',2,'sort block',3,'save undo block', 4,'segment header',5,'save undo header',6,'free list',7,'extent map', 8,'1st level bmb',9,'2nd level bmb',10,'3rd level bmb', 11,'bitmap block',12,'bitmap index block',13,'file header block',14,'unused', 15,'system undo header',16,'system undo block', 17,'undo header',18,'undo block'), count,time, con_id from x$kcbwait where mod(indx,19)!=0
+++GV$WALLET+++                       SELECT          INST_ID, CERTID, CERTDN, CERTSERIAL, CERTISSUER, KEYSIZE,          CERTSTATUS, CON_ID          FROM X$KZEKMFVW
+++GV$WLM_PCMETRIC+++                 SELECT m.inst_id,                 begtime,                 endtime,                 intsize_csec,                 kywmpcmnhash,                 kywmpcmnsp,                 case                   when (requestspersec = -1)                   then BINARY_DOUBLE_NAN                   else cast(requestspersec/1000 as binary_double)                 end,                 0,                 case                   when (dbtimeperrequest = -1)                   then BINARY_DOUBLE_NAN                   else                   case                     when (dbtimeperrequest <                       (decode(cpuperrequest,-1,0,cpuperrequest)+                        decode(cpuwaitperrequest,-1,0,cpuwaitperrequest)+                        decode(ioperrequest,-1,0,ioperrequest)+                        decode(iowperrequest,-1,0,iowperrequest)+                        decode(gccrperrequest,-1,0,gccrperrequest)+                        decode(gccurperrequest,-1,0,gccurperrequest)) )                    then BINARY_DOUBLE_NAN                     else cast(dbtimeperrequest/1000 as binary_double)                   end                 end,                 case                   when (sum((decode(cpuperrequest,-1,0,cpuperrequest/1000)                              * (requestspersec/1000))/1000000) over () >                         vo.value)                   then BINARY_DOUBLE_NAN                   else                     case                       when (cpuperrequest = -1)                       then BINARY_DOUBLE_NAN                       else                       case                         when (dbtimeperrequest <                           (decode(cpuperrequest,-1,0,cpuperrequest)+                            decode(cpuwaitperrequest,-1,0,cpuwaitperrequest)+                            decode(ioperrequest,-1,0,ioperrequest)+                            decode(iowperrequest,-1,0,iowperrequest)+                            decode(gccrperrequest,-1,0,gccrperrequest)+                            decode(gccurperrequest,-1,0,gccurperrequest)) )                        then BINARY_DOUBLE_NAN                         else cast(cpuperrequest/1000 as binary_double)                       end                     end                 end,                 case                   when (cpuwaitperrequest = -1)                   then BINARY_DOUBLE_NAN                   else                   case                     when (dbtimeperrequest <                       (decode(cpuperrequest,-1,0,cpuperrequest)+                        decode(cpuwaitperrequest,-1,0,cpuwaitperrequest)+                        decode(ioperrequest,-1,0,ioperrequest)+                        decode(iowperrequest,-1,0,iowperrequest)+                        decode(gccrperrequest,-1,0,gccrperrequest)+                        decode(gccurperrequest,-1,0,gccurperrequest)) )                    then BINARY_DOUBLE_NAN                     else cast(cpuwaitperrequest/1000 as binary_double)                   end                 end,                 case                   when (ioperrequest = -1)                   then BINARY_DOUBLE_NAN                   else                   case                     when (dbtimeperrequest <                       (decode(cpuperrequest,-1,0,cpuperrequest)+                        decode(cpuwaitperrequest,-1,0,cpuwaitperrequest)+                        decode(ioperrequest,-1,0,ioperrequest)+                        decode(iowperrequest,-1,0,iowperrequest)+                        decode(gccrperrequest,-1,0,gccrperrequest)+                        decode(gccurperrequest,-1,0,gccurperrequest)) )                    then BINARY_DOUBLE_NAN                     else cast(ioperrequest/1000 as binary_double)                   end                 end,                 case                   when (iowperrequest = -1)                   then BINARY_DOUBLE_NAN                   else                   case                     when (dbtimeperrequest <                       (decode(cpuperrequest,-1,0,cpuperrequ
+++GV$WLM_PCMETRIC_HISTORY+++         SELECT m.inst_id,                 begtime,                 endtime,                 intsize_csec,                 kywmpcmnhash,                 kywmpcmnsp,                 requestspersec,                 0,                cast(dbtimeperrequest as binary_double),                 cast(cpuperrequest as binary_double),                 cast(cpuwaitperrequest as binary_double),                 cast(ioperrequest as binary_double),                 cast(iowperrequest as binary_double),                 case                   when (requestspersec = 0)                   then cast(gccrperrequest  as binary_double)                  else 0                 end,                 cast((gccrperrequest + gccurperrequest) as binary_double),                 cast(niwaitperrequest as binary_double),                 cast(schwaitperrequest as binary_double),                 p.con_id          FROM   x$kewmwpcmv m, x$kywmpcmn p          WHERE m.pckey = p.kywmpcmnmhash
+++GV$WLM_PC_STATS+++                 SELECT s.inst_id,                 p.kywmpcmnhash,                 p.kywmpcmnsp,                 m.extid,                 m.sname,                 s.statval,                 p.con_id          FROM x$kewepcs s, x$kewssmap m, x$kywmpcmn p          WHERE s.pcspos = m.offst AND                m.aggid = 8 AND                s.pckey = p.kywmpcmnmhash
+++GV$WORKLOAD_REPLAY_THREAD+++       SELECT inst_id, clock, next_ticker,        sid, serial#, spid, logon_user, logon_time,        event, event_id, event#,        p1text, p1, p2text, p2, p3text, p3, wait_for_scn,        file_id, call_counter,        dependent_scn, statement_scn,        commit_wait_scn, post_commit_scn,        action_type, session_type, wrc_id, file_name,        skip_it, dirty_buffers,        dbtime, network_time, think_time,        time_gain, time_loss, user_calls,        client_os_user, client_host, client_pid, program, con_id FROM   X$KECPRT
+++GV$XML_AUDIT_TRAIL+++              select INST_ID, AUDIT_TYPE, SESSION_ID, PROXY_SESSIONID, STATEMENTID, ENTRYID,        EXTENDED_TIMESTAMP, GLOBAL_UID, DB_USER, CLIENTIDENTIFIER, EXT_NAME,        OS_USER, OS_HOST, OS_PROCESS, TERMINAL, INSTANCE_NUMBER,        OBJECT_SCHEMA, OBJECT_NAME, POLICY_NAME, NEW_OWNER, NEW_NAME, ACTION,        STATEMENT_TYPE, TRANSACTIONID, RETURNCODE, SCN, COMMENT_TEXT,        AUTH_PRIVILEGES, GRANTEE, PRIV_USED, SES_ACTIONS, OS_PRIVILEGE,        ECONTEXT_ID, SQL_BIND, SQL_TEXT, OBJ_EDITION_NAME, DBID, CON_ID         from X$XML_AUDIT_TRAIL
+++GV$XSTREAM_APPLY_COORDINATOR+++    select x.inst_id,x.sid_knst,x.serial_knst, x.applynum_knstacr, x.applyname_knstacr,decode(x.state_knstacr,0,'INITIALIZING',        1,'APPLYING',2,'SHUTTING DOWN CLEANLY',3,'ABORTING',4,'IDLE'),x.total_applied_knstacr,decode(bitand(flag_knstacr, 1),        0, total_waitdeps_knstacr,        1, (select sum(total_waitdeps_knstasl) from x$knstasl            where applynum_knstacr = applynum_knstasl)       ), x.total_waitcommits_knstacr,x.total_admin_knstacr,x.total_assigned_knstacr,x.total_received_knstacr, x.total_ignored_knstacr,x.total_rollbacks_knstacr, x.total_errors_knstacr, x.unassigned_complete_knstacr,x.lwm_time_knstacr, x.lwm_msg_num_knstacr,x.lwm_msg_time_knstacr,x.hwm_time_knstacr, x.hwm_msg_num_knstacr, x.hwm_msg_time_knstacr,x.startup_time_knstacr, x.elapsed_schedule_time_knstacr, x.elapsed_idle_time_knstacr, x.lwm_position_knstacr, x.hwm_position_knstacr, x.processed_msg_num_knstacr, x.con_id, x.active_server_cnt_knstacr from x$knstacr x   where x.type_knst=1    and bitand(x.purpose_flag_knstacr, 12) = 4    and exists (select 1 from v$session s                where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$XSTREAM_APPLY_READER+++         select x.inst_id,x.sid_knst,x.serial_knst,x.applynum_knstasl, x.applyname_knstasl, decode(hs.state_knstasl,0,'IDLE; ',8,'DEQUEUE MESSAGES; ',        10,'SCHEDULE MESSAGES; ',        15,'INITIALIZING; ',16,'SPILLING; ',        17,'PAUSED - WAITING FOR DDL TO COMPLETE; ',        20, 'GENERATE DEPENDENCY HASH VALUES; ') || decode(x.state_knstasl,0,'IDLE',8,'DEQUEUE MESSAGES',10,'SCHEDULE MESSAGES',        15,'INITIALIZING',16,'SPILLING',        17,'PAUSED - WAITING FOR DDL TO COMPLETE'), x.total_msg_knstasl, x.total_spill_msg_knstasl, x.last_rcv_time_knstasl, x.last_rcv_msg_num_knstasl, x.last_rcv_msg_time_knstasl, x.sga_used_knstasl, x.elapsed_dequeue_time_knstasl, x.elapsed_schedule_time_knstasl, x.elapsed_spill_time_knstasl, x.oldest_scn_num_knstasl, x.oldest_xid_usn_knstasl, x.oldest_xid_slt_knstasl, x.oldest_xid_sqn_knstasl,x.spill_lwm_scn_knstasl, x.proxy_sid_knstasl, x.proxy_serial_knstasl, x.proxy_spid_knstasl, (SELECT sesstat.ksusestv         FROM   x$ksusd stat, x$ksusesta sesstat, x$ksuse sess WHERE  x.proxy_sid_knstasl=sesstat.ksusenum    AND  x.proxy_sid_knstasl=sess.indx    AND  x.proxy_serial_knstasl=sess.ksuseser    AND  bitand(sess.ksspaflg,1)!=0    AND  bitand(sess.ksuseflg,1)!=0    AND  sesstat.ksusestn = stat.indx    AND  bitand(sesstat.ksspaflg,1)!=0    AND  bitand(sesstat.ksuseflg,1)!=0    AND  sesstat.ksusestn<(select ksusgstl from x$ksusgif)   AND  stat.ksusdnam = 'bytes received via SQL*Net from client'),x.last_rcv_pos_knstasl, x.spill_lwm_pos_knstasl, x.oldest_xidtxt_knstasl, x.num_dep_lcrs_knstasl, x.num_wmdeps_knstasl, x.num_in_memory_lcrs_knstasl, x.sga_allocated_knstasl, x.con_id from (select * from x$knstasl where type_knst=7       and bitand(flag_knstasl, 12) = 4       and exists (select 1 from v$session s                   where s.sid=sid_knst and s.serial#=serial_knst)) x,   (select * from x$knstasl where type_knst = 14    and bitand(flag_knstasl, 12) = 4    and exists (select 1 from v$session s                where s.sid=sid_knst and s.serial#=serial_knst)) hs where x.proxy_sid_knstasl = hs.sid_knst(+) and       x.proxy_serial_knstasl = hs.serial_knst(+) and       x.inst_id = hs.inst_id(+)
+++GV$XSTREAM_APPLY_RECEIVER+++       select x.inst_id, x.sid_knst, x.serial_knst, x.apply_name_knstanr,                x.startup_time_knstanr, x.src_dbname_knstanr,                x.acknowlegement_knstanr, x.last_rcv_msg_knstanr,                x.total_rcv_msgs_knstanr, x.available_msgs_knstanr,                decode(x.state_knstanr,                       0, 'Initializing',                       1, 'Sending unapplied txns',                       2, 'Waiting for message from client',                       3, 'Receiving LCRs',                       4, 'Evaluating rules',                       5, 'Enqueueing LCRS',                       6, 'Waiting for memory',                       7, 'Waiting for apply to read',                       8, 'Waiting for LCR from client',                       9, 'Waiting for client flush request to complete',                       10, 'Waiting for client commit to complete', null),                x.last_rcv_pos_knstanr, x.acknowlegement_pos_knstanr,                x.con_id          from   x$knstanr x, x$knstacr y          where  x.inst_id=y.inst_id and x.con_id=y.con_id and                 x.apply_name_knstanr=y.applyname_knstacr and                 y.type_knst=1 and bitand(y.purpose_flag_knstacr, 12)=4                 and exists (select 1 from v$session s                             where s.sid=x.sid_knst and s.serial#=x.serial_knst)
+++GV$XSTREAM_APPLY_SERVER+++         select inst_id,sid_knst,serial_knst,applynum_knstasl, applyname_knstasl,slavid_knstasl,decode(state_knstasl,0,'IDLE',1,'POLL SHUTDOWN',2,'RECORD LOW-WATERMARK',3,'ADD PARTITION',4,'DROP PARTITION',5,'EXECUTE TRANSACTION',6,'WAIT COMMIT',7,'WAIT DEPENDENCY',8,'GET TRANSACTIONS',9,'WAIT FOR NEXT CHUNK',12,'ROLLBACK TRANSACTION',13,'TRANSACTION CLEANUP',14,'REQUEST UA SESSION',15,'INITIALIZING',16,'SPILL',18,'WAIT FOR CLIENT',19,'INACTIVE'), xid_usn_knstasl,xid_slt_knstasl,xid_sqn_knstasl,cscn_knstasl,depxid_usn_knstasl,depxid_slt_knstasl,depxid_sqn_knstasl,depcscn_knstasl,msg_num_knstasl,total_assigned_knstasl,total_admin_knstasl,total_rollbacks_knstasl,total_msg_knstasl, last_apply_time_knstasl, last_apply_msg_num_knstasl,last_apply_msg_time_knstasl,elapsed_dequeue_time_knstasl, elapsed_apply_time_knstasl,commit_position_knstasl, dep_commit_position_knstasl,last_apply_pos_knstasl, nosxid_knstasl, depnosxid_knstasl, con_id, total_lcrs_retried_knstasl, lcr_retry_iter_knstasl, total_txns_retried_knstasl, txn_retry_iter_knstasl, total_txns_discarded_knstasl  from x$knstasl x where type_knst=2 and bitand(flag_knstasl, 12) = 4  and (x.sid_knst = 0 or exists (select 1 from v$session s where s.sid=x.sid_knst and s.serial#=x.serial_knst))
+++GV$XSTREAM_CAPTURE+++              SELECT x.inst_id, x.sid_knst, x.serial_knst, x.capnum_knstcap,         x.capname_knstcap, x.logminer_id_knstcap, x.startup_time_knstcap,        case when (x.state_knstcap = 10 and                    d.loaded = 'ACTIVE')             then d.current_state || ' ' || d.progress              when (x.state_knstcap = 18)              then 'WAIT FOR ' || x.subscriber_num                               || ' SUBSCRIBER(S) INITIALIZING'              else DECODE(x.state_knstcap,                     0,  'INITIALIZING',    1,'CAPTURING CHANGES',                    2,  'EVALUATING RULE', 3,'ENQUEUING MESSAGE',                     4,  'SHUTTING DOWN',   5,'ABORTING',                     6,  'CREATING LCR',                     7,  DECODE(x.missing_logfile_info_knstcap,                                NULL, 'WAITING FOR DICTIONARY REDO',                                'WAITING FOR DICTIONARY REDO: ' ||                                x.missing_logfile_info_knstcap),                    8,  DECODE(x.missing_logfile_info_knstcap,                                NULL, 'WAITING FOR REDO',                                'WAITING FOR REDO: ' ||                                x.missing_logfile_info_knstcap),                    9,'PAUSED FOR FLOW CONTROL',                     10, 'DICTIONARY INITIALIZATION',                    11, 'WAITING FOR APPLY TO BE ENABLED',                     12, 'CONNECTING TO APPLY DATABASE',                     13, 'WAITING FOR PROPAGATION TO BE ENABLED',                     15, 'WAITING FOR A SUBSCRIBER TO BE ADDED',                     16, 'WAITING FOR BUFFERED QUEUE TO SHRINK',                     17, 'SUSPENDED FOR AUTO SPLIT/MERGE',                     19, 'WAITING FOR INACTIVE DEQUEUERS',                     20, 'WAITING FOR TRANSACTION')         end,         m.msgs_filtered, m.msgs_kept, m.msgs_total, x.total_captured_knstcap,        x.recent_time_knstcap, x.recent_msg_num_knstcap,        x.recent_msg_time_knstcap, x.total_messages_created_knstcap,        x.total_full_evaluations_knstcap, x.total_msg_enq_knstcap,        x.enqueue_time_knstcap, x.enqueue_msg_num_knstcap,        x.enqueue_msg_time_knstcap,        DECODE(bitand(x.flags_knstcap, 1),               0, upstream.next_scn,               1, DECODE(bitand(x.flags_knstcap, 8),                         0, downstream.next_scn,                            downstream_real.next_scn)),         DECODE(bitand(x.flags_knstcap, 1),               0, upstream.next_time,               1, DECODE(bitand(x.flags_knstcap, 8),                         0, downstream.next_time,                            downstream_real.next_time)),                    x.elapsed_capture_time_knstcap, x.elapsed_rule_time_knstcap,        x.elapsed_enqueue_time_knstcap, x.elapsed_lcr_time_knstcap, x.elapsed_wait_time_knstcap, x.elapsed_pause_time_knstcap,         x.state_changed_time_knstcap,         x.sga_used_knstcap, x.sga_allocated_knstcap,        brm.value, srs.value, x.con_id  FROM   x$knstcap x,        (SELECT session_id,                sum(skipped_filter_calls) msgs_filtered,                sum(kept_filter_calls) msgs_kept,                sum(total_filter_calls) msgs_total         FROM x$logmnr_process         GROUP BY session_id) m,        (SELECT last_write_scn next_scn,                last_write_scn_time next_time         FROM x$kcrfws) upstream,        (SELECT session#, max(next_change#) next_scn,                max(next_time) next_time         FROM x$logmnr_log         GROUP BY session#) downstream,        (SELECT max(to_number(slnxs)) next_scn,                max(to_date(slnxt,                    'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian')) next_time         FROM x$kccsl WHERE sign(slseq)=1) downstream_real,        x$logmnr_dictionary_load d,        (SELECT session_id, name, value FROM x$krvxsv         WHERE name = 'bytes of redo mined') brm,         (SELECT session_id, name, value FROM x$krvxsv         WHERE name = 'session restart SCN') srs  WHERE  type_knst=8 AND BITAND(x.flags_knstcap, 48)
+++GV$XSTREAM_MESSAGE_TRACKING+++     SELECT inst_id, tracking_label_knstmt, tag_knstmt, component_name_knstmt,         component_type_knstmt, action_knstmt, action_details_knstmt,         timestamp_knstmt, message_create_time_knstmt, message_number_knstmt,         tracking_id_knstmt, source_database_name_knstmt, object_owner_knstmt,         object_name_knstmt, xid_knstmt, command_type_knstmt,         message_position_knstmt, con_id                              FROM   x$knstmt      WHERE  procusectxid_knstmt = 1
+++GV$XSTREAM_OUTBOUND_SERVER+++      SELECT a.inst_id, a.sid_knst, a.serial_knst, a.proxy_spid_knstasl, a.applyname_knstasl, a.startup_time_knstasl, decode(state_knstasl,0, 'IDLE',  5,'SEND TRANSACTION', 8,'GET TRANSACTIONS',  9,'WAIT FOR NEXT CHUNK', 13,'TRANSACTION CLEANUP',15,'INITIALIZING',  18,'WAIT FOR CLIENT'), a.xid_usn_knstasl, a.xid_slt_knstasl, a.xid_sqn_knstasl, a.cscn_knstasl, a.total_assigned_knstasl, a.msg_num_knstasl, a.total_msg_knstasl, a.last_apply_time_knstasl, a.last_apply_msg_num_knstasl, a.last_apply_msg_time_knstasl, a.elapsed_apply_time_knstasl, a.commit_position_knstasl, a.last_apply_pos_knstasl, (SELECT sesstat.ksusestv  FROM   x$ksusd stat, x$ksusesta sesstat, x$ksuse sess  WHERE a.sid_knst=sesstat.ksusenum  AND a.sid_knst=sess.indx AND a.serial_knst=sess.ksuseser  AND bitand(sess.ksspaflg,1)!=0 AND bitand(sess.ksuseflg,1)!=0  AND sesstat.ksusestn = stat.indx AND bitand(sesstat.ksspaflg,1)!=0  AND bitand(sesstat.ksuseflg,1)!=0 AND  sesstat.ksusestn<(select ksusgstl from x$ksusgif)  AND stat.ksusdnam = 'bytes sent via SQL*Net to client'), 'YES', a.con_id FROM x$knstasl a WHERE a.type_knst=2 and  exists (select 1 from v$session s          where s.sid=a.sid_knst and s.serial#=a.serial_knst) and  a.slavid_knstasl = 2 and bitand(a.flag_knstasl, 1) = 1
+++GV$XSTREAM_TABLE_STATS+++          SELECT inst_id, svrnm_knstxsts, slaveid_knstxsts, old_sname_knstxsts,         old_oname_knstxsts, new_sname_knstxsts, new_oname_knstxsts,         last_update_knstxsts, inscnt_knstxsts,         updcnt_knstxsts, delcnt_knstxsts, inscolsn_knstxsts,         updcolsn_knstxsts, delcolsn_knstxsts, discrdcnt_knstxsts,         ignrcnt_knstxsts, waitdepcnt_knstxsts, con_id, cdrinsre_knstxsts,         cdrupdre_knstxsts, cdrupdrm_knstxsts, cdrdelre_knstxsts,         cdrdelrm_knstxsts,         (cdrinsre_knstxsts + cdrupdre_knstxsts +          cdrupdrm_knstxsts + cdrdelre_knstxsts + cdrdelrm_knstxsts),         cdrresfail_knstxsts, lobcnt_knstxsts  FROM   x$knstxsts     WHERE procusectxid_knstxsts = 1
+++GV$XSTREAM_TRANSACTION+++          SELECT inst_id, strmname_knsttxn, type_knsttxn,        xidusn_knsttxn, xidslt_knsttxn, xidsqn_knsttxn,         msg_count_knsttxn, actual_msg_count_knsttxn,         first_msg_time_knsttxn, first_msg_num_knsttxn,         last_msg_time_knsttxn,  last_msg_num_knsttxn,         first_msg_pos_knsttxn,  last_msg_pos_knsttxn, nosxid_knsttxn,         con_id                                  FROM   x$knsttxn                 WHERE  procusectxid_knsttxn = 1
+++GV$XS_SESSIONS+++                  select inst_id, sessid, dbsessnum, dbsernum, con_id from x$xs_sessions
+++GV$XS_SESSION_NS_ATTRIBUTE+++      SELECT inst_id, namespace_name, workspace_name, attribute_name,         attribute_value, attribute_events, attribute_default_value,         attribute_type, con_id  FROM   x$xs_session_ns_attributes
+++GV$XS_SESSION_ROLE+++              SELECT inst_id, role_wspace, role_name, flags, con_id  FROM   x$rxs_session_roles
+++GV$_LOCK+++                        select USERENV('Instance'),laddr,kaddr,saddr,raddr,lmode,request,ctime,  block, con_id from v$_lock1 union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktadm where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktatrfil where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktatrfsl where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktatl where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktstusc where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktstuss where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktstusg where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,ktcxbxba,ktcxblkp,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim,ksqlklblk, con_id from x$ktcxb where bitand(ksspaflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0)
+++GV$_LOCK1+++                       select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim, ksqlklblk, con_id from x$kdnssf where bitand(kssobflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0) union all select inst_id,addr,ksqlkadr,ksqlkses,ksqlkres,ksqlkmod,ksqlkreq, ksqlkctim, ksqlklblk, con_id from x$ksqeq where bitand(ksspaflg,1)!=0 and (ksqlkmod!=0 or ksqlkreq!=0)
+++GV$_RESUMABLE2+++                  select inst_id, ktrsfaddr, ktrsfsid, decode (bitand(ktrsfflg, 1), 0, 'NO', 'YES'), decode (ktrsfsta, 0, 'NORMAL', 1, 'SUSPENDED', 2, 'TIMEOUT', 3, 'ERROR', 4, 'ABORTED', ''), ktrsftmo, ktrsfspt, ktrsfrst, ktrsfnam, ktrsferr, ktrsfep1, ktrsfep2, ktrsfep3, ktrsfep4, ktrsfep5, ktrsfems, ktrsfobj, ktrsftyp, con_id from x$ktrso
+++GV$_SEQUENCES+++                   select inst_id, KGLNAOWN,KGLNAOBJ,KGLOBT08,decode(bitand(KGLOBT00,1),0,'N','Y'),decode(bitand(KGLOBT00,2),0,'N','Y'),decode(bitand(KGLOBT00,16),0,'N','Y'),KGLOBTN0,KGLOBTN2,KGLOBTN3,KGLOBTN1,decode(bitand(KGLOBT09,1),0,'N','Y'),decode(bitand(KGLOBT09,2),0,'N','Y'),KGLOBTN4,KGLOBTN5,decode(KGLOBT10,1,'Y','N'),decode(KGLOBT10,1,KGLOBT02,null), con_id,decode(bitand(KGLOBT09,32),0,'N','Y')from X$KGLOB where KGLOBTYP = 6 and KGLOBT11 = 1
+++O$SQL_BIND_CAPTURE+++              select ADDRESS, HASH_VALUE, SQL_ID, CHILD_ADDRESS,                 CHILD_NUMBER, NAME,                                                        POSITION, DUP_POSITION, DATATYPE, DATATYPE_STRING,                         CHARACTER_SID, PRECISION, SCALE, MAX_LENGTH, WAS_CAPTURED,                 LAST_CAPTURED, VALUE_STRING, VALUE_ANYDATA, CON_ID                  from go$sql_bind_capture                                                   where inst_id = USERENV('Instance')
+++V$ACCESS+++                        select  SID , OWNER , OBJECT , TYPE, CON_ID from GV$ACCESS where inst_id = USERENV('Instance')
+++V$ACTIVE_INSTANCES+++              select  INST_NUMBER , INST_NAME, CON_ID from GV$ACTIVE_INSTANCES where inst_id = USERENV('Instance')
+++V$ACTIVE_SERVICES+++               select SERVICE_ID, NAME, NAME_HASH, NETWORK_NAME, CREATION_DATE, CREATION_DATE_HASH, GOAL, DTP, BLOCKED,  AQ_HA_NOTIFICATION, CLB_GOAL,  COMMIT_OUTCOME, RETENTION_TIME, REPLAY_INITIATION_TIMEOUT,  SESSION_STATE_CONSISTENCY,  GLOBAL, CON_NAME, SQL_TRANSLATION_PROFILE, MAX_LAG_TIME,  CON_ID  from GV$ACTIVE_SERVICES where inst_id = USERENV('Instance')
+++V$ACTIVE_SESSION_HISTORY+++        SELECT sample_id, sample_time, is_awr_sample, session_id, session_serial#, session_type, flags, user_id, sql_id, is_sqlid_current, sql_child_number, sql_opcode, sql_opname, force_matching_signature, top_level_sql_id, top_level_sql_opcode, sql_adaptive_plan_resolved, sql_full_plan_hash_value, sql_plan_hash_value, sql_plan_line_id, sql_plan_operation, sql_plan_options, sql_exec_id, sql_exec_start, plsql_entry_object_id, plsql_entry_subprogram_id, plsql_object_id, plsql_subprogram_id, qc_instance_id, qc_session_id, qc_session_serial#, px_flags, event, event_id, event#, seq#, p1text, p1, p2text, p2, p3text, p3, wait_class, wait_class_id, wait_time, session_state, time_waited, blocking_session_status, blocking_session, blocking_session_serial#, blocking_inst_id, blocking_hangchain_info, current_obj#, current_file#, current_block#, current_row#, top_level_call#, top_level_call_name, consumer_group_id, xid, remote_instance#, time_model, in_connection_mgmt, in_parse, in_hard_parse, in_sql_execution, in_plsql_execution, in_plsql_rpc, in_plsql_compilation, in_java_execution, in_bind, in_cursor_close, in_sequence_load, in_inmemory_query, in_inmemory_populate, in_inmemory_prepopulate, in_inmemory_repopulate, in_inmemory_trepopulate, capture_overhead, replay_overhead, is_captured, is_replayed, service_hash, program, module, action, client_id, machine, port, ecid, dbreplay_file_id, dbreplay_call_counter, tm_delta_time, tm_delta_cpu_time, tm_delta_db_time, delta_time, delta_read_io_requests, delta_write_io_requests, delta_read_io_bytes, delta_write_io_bytes, delta_interconnect_io_bytes, delta_read_mem_bytes, pga_allocated, temp_space_allocated, con_dbid,con_id, dbop_name, dbop_exec_id FROM  GV$ACTIVE_SESSION_HISTORY WHERE inst_id = USERENV('INSTANCE')
+++V$ACTIVE_SESS_POOL_MTH+++          select name, con_id from gv$active_sess_pool_mth          where inst_id = userenv('instance')
+++V$ADVISOR_CURRENT_SQLPLAN+++       select TIMESTAMP, OPERATION, OPTIONS, OBJECT_NODE, OBJECT#,                 OBJECT_OWNER, OBJECT_NAME, OBJECT_ALIAS, OBJECT_TYPE,                 OPTIMIZER, ID, PARENT_ID, DEPTH, POSITION, SEARCH_COLUMNS,                 COST, CARDINALITY, BYTES, OTHER_TAG, PARTITION_START,                 PARTITION_STOP, PARTITION_ID, OTHER, DISTRIBUTION, CPU_COST,                 IO_COST, TEMP_SPACE, ACCESS_PREDICATES, FILTER_PREDICATES,                 PROJECTION, TIME, QBLOCK_NAME, REMARKS, OTHER_XML, CON_ID         from gv$advisor_current_sqlplan         where inst_id = USERENV('Instance')
+++V$ADVISOR_PROGRESS+++              select SID, SERIAL#, USERNAME, OPNAME, ADVISOR_NAME, TASK_ID,                   TARGET_DESC, SOFAR, TOTALWORK, UNITS,                                    BENEFIT_SOFAR, BENEFIT_MAX, FINDINGS,  RECOMMENDATIONS,                  TIME_REMAINING, START_TIME,                                              LAST_UPDATE_TIME,                                                        ELAPSED_SECONDS,                                                         ADVISOR_METRIC1, METRIC1_DESC,                                           EXECUTION_TYPE, CON_ID                                            from GV$ADVISOR_PROGRESS                                                 where inst_id = USERENV('Instance')
+++V$ALERT_TYPES+++                   SELECT reason_id, object_type, type, group_name, scope,            internal_metric_category, internal_metric_name, con_id          FROM gv$alert_types          WHERE inst_id = USERENV('INSTANCE')
+++V$AQ1+++                           select  QID , WAITING, READY, EXPIRED, AVERAGE_MSG_AGE,          TOTAL_CONSUMERS, TOTAL_WAIT, AVERAGE_WAIT, CON_ID          from GV$AQ1
+++V$AQ_BACKGROUND_COORDINATOR+++     select      process_id, process_name, num_jobs, job_latency, num_coordinators,      con_id    from GV$AQ_BACKGROUND_COORDINATOR where inst_id = USERENV('Instance')
+++V$AQ_BMAP_NONDUR_SUBSCRIBERS+++     select queue_id, USED_POS, con_id           from GV$AQ_BMAP_NONDUR_SUBSCRIBERS           where inst_id = USERENV('Instance')
+++V$AQ_CROSS_INSTANCE_JOBS+++        select      job_id, schema_name, queue_name, shard_id,      start_subshard_id, destination_instance_id,      coordinator_id, dest_server_process_id, job_state,      flow_control, msgs_sent, bytes_sent, ack_latency, con_id    from GV$AQ_CROSS_INSTANCE_JOBS where inst_id = USERENV('Instance')
+++V$AQ_JOB_COORDINATOR+++            select      coordinator_id, process_id, process_name, job_name, job_type,      server_count, max_server_count, con_id      from GV$AQ_JOB_COORDINATOR where inst_id = USERENV('Instance')
+++V$AQ_MESSAGE_CACHE+++              select      queue_id, shard_id, priority, subshard_id, partition_id,      max_msgs, enqueued_msgs, browsed_msgs,      msgs_made_expired, msgs_made_ready, chunk_size, num_chunks,      num_free_chunks, used_memory_size, state, con_id    from GV$AQ_MESSAGE_CACHE where inst_id = USERENV('Instance')
+++V$AQ_MSGBM+++                       select queue_id, msgid, bitmap, con_id from GV$AQ_MSGBM           where inst_id = USERENV('Instance')
+++V$AQ_NONDUR_REGISTRATIONS+++       select      reg_id, subscription, location, user#, user_context, context_size,      namespace, version, state, qos,      reg_time, con_id      from GV$AQ_NONDUR_REGISTRATIONS where inst_id = USERENV('Instance')
+++V$AQ_NONDUR_SUBSCRIBER+++           select queue_id, subscriber_id, subscriber_name, rule_condition,   transformation_owner, transformation_name, creation_time, flags,   subscriber_type, bitpos, con_id   from GV$AQ_NONDUR_SUBSCRIBER where inst_id = USERENV('Instance')
+++V$AQ_NONDUR_SUBSCRIBER_LWM+++      select queue_id, subscriber_id, shard_id, priority, lwm, con_id   from GV$AQ_NONDUR_SUBSCRIBER_LWM where inst_id = USERENV('Instance')
+++V$AQ_NOTIFICATION_CLIENTS+++       select client_id, emon_id, notification_state, num_message_sent,         num_bytes_sent, num_message_received,         last_send_time, last_receive_time, connect_time, disconnect_time,        last_error, con_id from GV$AQ_NOTIFICATION_CLIENTS where inst_id = USERENV('Instance')
+++V$AQ_SERVER_POOL+++                select      coordinator_id, coordinator_instance_id, process_id, process_name,      job_name, pool_state, con_id    from GV$AQ_SERVER_POOL where inst_id = USERENV('Instance')
+++V$AQ_SUBSCRIBER_LOAD+++            select queue_id, queue_schema, queue_name, subscriber_id, subscriber_name,           latency_state,latency, dequeue_requests, active_shards,                       active_listener, flags, con_id      from GV$AQ_SUBSCRIBER_LOAD  where inst_id = USERENV('Instance')
+++V$ARCHIVE+++                       select  GROUP# , THREAD# , SEQUENCE# , ISCURRENT , "CURRENT" , FIRST_CHANGE#, CON_ID from GV$ARCHIVE where inst_id = USERENV('Instance')
+++V$ARCHIVED_LOG+++                  select  RECID , STAMP , NAME , DEST_ID , THREAD# , SEQUENCE# ,  RESETLOGS_CHANGE# , RESETLOGS_TIME , RESETLOGS_ID ,  FIRST_CHANGE# , FIRST_TIME ,  NEXT_CHANGE# , NEXT_TIME , BLOCKS , BLOCK_SIZE , CREATOR, REGISTRAR ,  STANDBY_DEST , ARCHIVED , APPLIED , DELETED , STATUS , COMPLETION_TIME ,  DICTIONARY_BEGIN , DICTIONARY_END , END_OF_REDO, BACKUP_COUNT ,  ARCHIVAL_THREAD#, ACTIVATION#, IS_RECOVERY_DEST_FILE, COMPRESSED, FAL,  END_OF_REDO_TYPE, BACKED_BY_VSS, CON_ID from GV$ARCHIVED_LOG where inst_id = USERENV('Instance')
+++V$ARCHIVE_DEST+++                  select DEST_ID,DEST_NAME, STATUS, BINDING, NAME_SPACE, TARGET, ARCHIVER, SCHEDULE, DESTINATION, LOG_SEQUENCE, REOPEN_SECS, DELAY_MINS, MAX_CONNECTIONS, NET_TIMEOUT, PROCESS, REGISTER, FAIL_DATE, FAIL_SEQUENCE, FAIL_BLOCK, FAILURE_COUNT, MAX_FAILURE, ERROR, ALTERNATE, DEPENDENCY, REMOTE_TEMPLATE, QUOTA_SIZE, QUOTA_USED, MOUNTID, TRANSMIT_MODE, ASYNC_BLOCKS, AFFIRM, TYPE, VALID_NOW, VALID_TYPE, VALID_ROLE, DB_UNIQUE_NAME, VERIFY, COMPRESSION, APPLIED_SCN, CON_ID, ENCRYPTION  from GV$ARCHIVE_DEST  where inst_id = USERENV('Instance')
+++V$ARCHIVE_DEST_STATUS+++           select DEST_ID,DEST_NAME, STATUS, TYPE, DATABASE_MODE, RECOVERY_MODE, PROTECTION_MODE, DESTINATION, STANDBY_LOGFILE_COUNT, STANDBY_LOGFILE_ACTIVE, ARCHIVED_THREAD#, ARCHIVED_SEQ#, APPLIED_THREAD#, APPLIED_SEQ#, ERROR, SRL, DB_UNIQUE_NAME, SYNCHRONIZATION_STATUS, SYNCHRONIZED, GAP_STATUS, CON_ID  from GV$ARCHIVE_DEST_STATUS  where inst_id = USERENV('Instance')
+++V$ARCHIVE_GAP+++                   select  THREAD# , LOW_SEQUENCE# , HIGH_SEQUENCE#, CON_ID from GV$ARCHIVE_GAP where inst_id = USERENV('Instance')
+++V$ARCHIVE_PROCESSES+++             select PROCESS, STATUS, LOG_SEQUENCE, STATE, ROLES, CON_ID from GV$ARCHIVE_PROCESSES where inst_id = USERENV('Instance')
+++V$ASH_INFO+++                      SELECT total_size, fixed_size, sampling_interval,    decode(oldest_sample_id, 0, to_number(null), oldest_sample_id),    decode(oldest_sample_id, 0, to_timestamp(null),           oldest_sample_time),    decode(latest_sample_id, 0, to_number(null), latest_sample_id),    decode(latest_sample_id, 0, to_timestamp(null),           latest_sample_time),    sample_count, dropped_sample_count, sampled_bytes,    sampler_elapsed_time,    disk_filter_ratio, awr_flush_bytes, awr_flush_elapsed_time,    awr_flush_count, awr_flush_emergency_count, con_id FROM   GV$ASH_INFO WHERE inst_id = USERENV('INSTANCE')
+++V$ASM_ACFSREPL+++                  select                                    fsname,                                  voldev,                                  site,                                    lag,                                     status,                                  initstatus,                              dirsscan,                                percent,                                 lastsync,                                crsrun,                                  crstotal,                                pmntpt,                                  smntpt,                                  psvcname,                                ssvcname,                                phost,                                   shost,                                   remalias,                                tags,                                    compression,                             dbglvl,                                  con_id                                   from gv$asm_acfsrepl                     where inst_id = USERENV('Instance')
+++V$ASM_ACFSREPLTAG+++               select                                    fsname,                                  voldev,                                  tag,                                     con_id                                   from gv$asm_acfsrepltag                  where inst_id = USERENV('Instance')
+++V$ASM_ACFSSNAPSHOTS+++             select   fs_name, vol_device, snap_name, create_time, type, parent, con_id   from gv$asm_acfssnapshots                     where inst_id = USERENV('Instance')
+++V$ASM_ACFSTAG+++                   select                 tag_name,             fs_name,              path_name,            con_id                from gv$asm_acfstag   where inst_id = USERENV('Instance')
+++V$ASM_ACFSVOLUMES+++               select   fs_name, vol_device, vol_label,         primary_vol, total_mb, free_mb, con_id          from gv$asm_acfsvolumes                 where inst_id = USERENV('Instance')
+++V$ASM_ACFS_ENCRYPTION_INFO+++      select   fs_name, vol_device, set_status, enabled_status,        algorithm, key_length, last_rekey_time, con_id          from gv$asm_acfs_encryption_info                        where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SECURITY_INFO+++        select   fs_name, vol_device, prepared_status, enabled_status, con_id    from gv$asm_acfs_security_info                          where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_ADMIN+++            select                                       admin_name,                                 con_id                                      from gv$asm_acfs_sec_admin                  where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_CMDRULE+++          select                                       cmd_rule_name,                              fs_name, vol_device, con_id                 from gv$asm_acfs_sec_cmdrule                where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_REALM+++            select                                                                 realm_name, realm_status, realm_encr_status, realm_encr_keylen,       realm_encr_algo, realm_desc, fs_name, vol_device, con_id              from gv$asm_acfs_sec_realm                                            where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_REALM_FILTER+++     select                                       realm_name, cmd_rule_name, ruleset_name,    fs_name, vol_device, con_id                 from gv$asm_acfs_sec_realm_filter           where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_REALM_GROUP+++      select                                     realm_name, group_name,                   fs_name, vol_device, con_id               from gv$asm_acfs_sec_realm_group          where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_REALM_USER+++       select                                     realm_name, user_name,                    fs_name, vol_device, con_id               from gv$asm_acfs_sec_realm_user           where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_RULE+++             select                                                                 rule_name, rule_type, rule_value, rule_value2,                        rule_option, fs_name, vol_device, con_id                              from gv$asm_acfs_sec_rule                                             where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_RULESET+++          select                                       ruleset_name, ruleset_option,               fs_name, vol_device, con_id                 from gv$asm_acfs_sec_ruleset                where inst_id = USERENV('Instance')
+++V$ASM_ACFS_SEC_RULESET_RULE+++     select                                       ruleset_name, rule_name,                    fs_name, vol_device, con_id                 from gv$asm_acfs_sec_ruleset_rule           where inst_id = USERENV('Instance')
+++V$ASM_ALIAS+++                     select name, group_number, file_number, file_incarnation,  alias_index, alias_incarnation, parent_index, reference_index,  alias_directory, system_created, con_id  from gv$asm_alias where inst_id = USERENV('Instance')
+++V$ASM_ATTRIBUTE+++                 select name, value, group_number,  attribute_index, attribute_incarnation,  read_only, system_created, con_id  from gv$asm_attribute where inst_id = USERENV('Instance')
+++V$ASM_AUDIT_CLEANUP_JOBS+++        select job_name, job_status, audit_trail, job_frequency, con_id from  gv$asm_audit_cleanup_jobs where inst_id = USERENV('Instance')
+++V$ASM_AUDIT_CLEAN_EVENTS+++        select audit_trail, cleanup_time, delete_count, was_forced, con_id from  gv$asm_audit_clean_events where inst_id = USERENV('Instance')
+++V$ASM_AUDIT_CONFIG_PARAMS+++       select parameter_name, parameter_value, audit_trail, con_id from  gv$asm_audit_config_params where inst_id = USERENV('Instance')
+++V$ASM_AUDIT_LAST_ARCH_TS+++        select audit_trail, last_archive_ts, con_id from  gv$asm_audit_last_arch_ts where inst_id = USERENV('Instance')
+++V$ASM_CLIENT+++                    select group_number, instance_name, db_name, cluster_name, status,   software_version, compatible_version, con_id  from gv$asm_client where inst_id = USERENV('Instance')
+++V$ASM_DISK+++                      select   group_number, disk_number, compound_index, incarnation,   mount_status, header_status, mode_status, state, redundancy, library,   os_mb, total_mb, free_mb, hot_used_mb, cold_used_mb, name, failgroup,    label, path, udid, product,   create_date, mount_date, repair_timer, reads, writes, read_errs,   write_errs, read_timeout, write_timeout, read_time, write_time,   bytes_read, bytes_written, preferred_read, hash_value,   hot_reads, hot_writes, hot_bytes_read, hot_bytes_written,   cold_reads, cold_writes, cold_bytes_read, cold_bytes_written, voting_file,   sector_size, failgroup_type, con_id  from gv$asm_disk  where inst_id = USERENV('Instance')
+++V$ASM_DISKGROUP+++                 select group_number, name, sector_size, block_size,       allocation_unit_size, state, type, total_mb, free_mb,    hot_used_mb, cold_used_mb,   required_mirror_free_mb, usable_file_mb, offline_disks,   compatibility, database_compatibility, voting_files, con_id  from gv$asm_diskgroup where inst_id = USERENV('Instance')
+++V$ASM_DISKGROUP_SPARSE+++          select   group_number, allocated_mat_mb, total_mat_mb,   con_id  from gv$asm_diskgroup_sparse  where inst_id = USERENV('Instance')
+++V$ASM_DISKGROUP_STAT+++            select group_number, name, sector_size, block_size,       allocation_unit_size, state, type, total_mb, free_mb,    hot_used_mb, cold_used_mb,   required_mirror_free_mb, usable_file_mb, offline_disks,   compatibility, database_compatibility, voting_files, con_id  from gv$asm_diskgroup_stat where inst_id = USERENV('Instance')
+++V$ASM_DISK_IOSTAT+++               select   instname, dbname, clustername, group_number,   disk_number, failgroup, reads,   writes, read_errs, write_errs, read_timeout, write_timeout,   read_time, write_time, bytes_read, bytes_written,   hot_reads, hot_writes, hot_bytes_read, hot_bytes_written,   cold_reads, cold_writes, cold_bytes_read, cold_bytes_written, con_id  from gv$asm_disk_iostat  where inst_id = USERENV('Instance')
+++V$ASM_DISK_IOSTAT_SPARSE+++        select   instname, dbname, clustername, group_number,   disk_number, sparse_reads, sparse_read_time, sparse_bytes_read, con_id   from gv$asm_disk_iostat_sparse   where inst_id = USERENV('Instance')
+++V$ASM_DISK_SPARSE+++               select   group_number, disk_number, compound_index, incarnation,   allocated_mat_mb, total_mat_mb, sparse_reads, sparse_read_time,   sparse_bytes_read, con_id  from gv$asm_disk_sparse  where inst_id = USERENV('Instance')
+++V$ASM_DISK_SPARSE_STAT+++          select   group_number, disk_number, compound_index, incarnation,   allocated_mat_mb, total_mat_mb,   sparse_reads, sparse_read_time, sparse_bytes_read,   con_id  from gv$asm_disk_sparse_stat  where inst_id = USERENV('Instance')
+++V$ASM_DISK_STAT+++                 select   group_number, disk_number, compound_index, incarnation,   mount_status, header_status, mode_status, state, redundancy, library,   os_mb, total_mb, free_mb, hot_used_mb, cold_used_mb, name, failgroup,    label, path, udid, product,   create_date, mount_date, repair_timer, reads, writes, read_errs,   write_errs, read_timeout, write_timeout, read_time, write_time,   bytes_read, bytes_written,   preferred_read, hash_value,   hot_reads, hot_writes, hot_bytes_read, hot_bytes_written,   cold_reads, cold_writes, cold_bytes_read, cold_bytes_written, voting_file,   sector_size, failgroup_type, con_id  from gv$asm_disk_stat  where inst_id = USERENV('Instance')
+++V$ASM_ESTIMATE+++                  select group_number, statement_id, timestamp, est_work, con_id  from gv$asm_estimate where inst_id = USERENV('Instance')
+++V$ASM_FILE+++                      select   group_number, file_number, compound_index, incarnation,   block_size, blocks, bytes, space, type, redundancy, striped,   creation_date, modification_date, redundancy_lowered,   permissions, user_number, user_incarnation, usergroup_number,   usergroup_incarnation, primary_region, mirror_region,   hot_reads, hot_writes, hot_bytes_read, hot_bytes_written,   cold_reads, cold_writes, cold_bytes_read, cold_bytes_written, con_id  from gv$asm_file  where inst_id = USERENV('Instance')
+++V$ASM_FILESYSTEM+++                select   fs_name, available_time, block_size, state,   corrupt, num_vol, total_size, total_free,     total_snap_space_usage, replstate, con_id     from gv$asm_filesystem                        where inst_id = USERENV('Instance')
+++V$ASM_OPERATION+++                 select   group_number, operation, pass, state, power, actual,   sofar, est_work, est_rate, est_minutes, error_code, con_id  from gv$asm_operation where inst_id = USERENV('Instance')
+++V$ASM_TEMPLATE+++                  select group_number, entry_number, redundancy, stripe, system, name,         primary_region, mirror_region, con_id  from gv$asm_template  where inst_id = USERENV('Instance')
+++V$ASM_USER+++                      select group_number, user_number, compound_index,  incarnation, cluster_id, os_id, os_name, con_id  from gv$asm_user where inst_id = USERENV('Instance')
+++V$ASM_USERGROUP+++                 select group_number, usergroup_number, compound_index,  incarnation, owner_number, owner_incarnation, name, con_id  from gv$asm_usergroup where inst_id = USERENV('Instance')
+++V$ASM_USERGROUP_MEMBER+++          select group_number, member_number, member_incarnation,  usergroup_number, usergroup_incarnation, con_id  from gv$asm_usergroup_member where inst_id = USERENV('Instance')
+++V$ASM_VOLUME+++                    select   group_number, volume_name, compound_index,   size_mb, volume_number, redundancy, stripe_columns,   stripe_width_k, state, file_number, incarnation,   drl_file_number, resize_unit_mb, usage, volume_device, mountpath, con_id   from gv$asm_volume    where inst_id = USERENV('Instance')
+++V$ASM_VOLUME_STAT+++               select   group_number, volume_name, compound_index, volume_number, reads, writes,   read_errs, write_errs, read_time, write_time,   bytes_read, bytes_written, con_id    from gv$asm_volume_stat   where inst_id = USERENV('Instance')
+++V$AW_AGGREGATE_OP+++               select name_xsagopft as name, desc_xsagopft as longname, case when weight_xsagopft >= 0 then weight_xsagopft else null end as default_weight, con_id from x$xsagop where not bitand(flags_xsagopft, 32) = 0
+++V$AW_ALLOCATE_OP+++                select name_xsagopft as name, desc_xsagopft as longname, con_id from x$xsagop where not bitand(flags_xsagopft, 64) = 0
+++V$AW_CALC+++                       select SESSION_ID, AGGREGATE_CACHE_HITS, AGGREGATE_CACHE_MISSES, SESSION_CACHE_HITS, SESSION_CACHE_MISSES, POOL_HITS, POOL_MISSES, POOL_NEW_PAGES, POOL_RECLAIMED_PAGES, CACHE_WRITES, POOL_SIZE, CURR_DML_COMMAND, PREV_DML_COMMAND, AGGR_FUNC_LOGICAL_NA, AGGR_FUNC_PRECOMPUTE, AGGR_FUNC_CALCS, CON_ID from gv$aw_calc where inst_id = USERENV('Instance')
+++V$AW_LONGOPS+++                    select SESSION_ID, CURSOR_NAME, COMMAND, STATUS, ROWS_PROCESSED, SEQ_NUMBER, SQL_ID, TARGET, TARGET_DESC, START_TIME, LAST_UPDATE_TIME,  ELAPSED_SECONDS, SOFAR, TOTALWORK, UNITS, MESSAGE, USERNAME, CON_ID  from gv$aw_longops where inst_id = USERENV('Instance')
+++V$AW_OLAP+++                       select session_id, aw_number, attach_mode, generation,  temp_space_pages, temp_space_reads, lob_reads, pool_changed_pages,  pool_unchanged_pages, con_id  from gv$aw_olap where inst_id = USERENV('Instance')
+++V$AW_SESSION_INFO+++               select SESSION_ID, CLIENT_TYPE, SESSION_STATE, SESSION_HANDLE, USERID, TOTAL_TRANSACTION,  TRANSACTION_TIME, TOTAL_TRANSACTION_TIME, AVERAGE_TRANSACTION_TIME,  TRANSACTION_CPU_TIME, TOTAL_TRANSACTION_CPU_TIME, AVERAGE_TRANSACTION_CPU_TIME, CON_ID from gv$aw_session_info where inst_id = USERENV('Instance')
+++V$BACKUP+++                        select  FILE# , STATUS , CHANGE# , TIME, CON_ID from GV$BACKUP where inst_id = USERENV('Instance')
+++V$BACKUP_ARCHIVELOG_DETAILS+++     select a.*,        sys.dbms_rcvman.num2displaysize(filesize) filesize_display, 1  from (select unique 'BACKUPSET' btype, b.recid btype_key,        b.session_recid session_key,        b.session_recid,        b.session_stamp,        a.set_stamp id1, b.set_count id2,        thread#, sequence#, resetlogs_change#, resetlogs_time,        first_change#,         first_time,       next_change#,        next_time,        (blocks+1)*a.block_size filesize, case when b.compression_ratio>1 then            b.compression_ratio else 1 end compression_ratio    from v$backup_redolog a, v$backup_set_details b where         a.set_stamp = b.set_stamp and         a.set_count = b.set_count union select unique 'PROXYCOPY', a.recid btype_key,        session_recid session_key,        session_recid,       session_stamp,       a.recid, a.stamp,         thread#, sequence#, resetlogs_change#, resetlogs_time,        first_change#, first_time,        next_change#, next_time,        (blocks+1)*block_size filesize, 1    from v$proxy_archivedlog a, v$rman_status b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time))a
+++V$BACKUP_ARCHIVELOG_SUMMARY+++     select a.*,   case when      input_bytes/decode(output_bytes, 0, null, output_bytes) > 1   then      input_bytes/decode(output_bytes, 0, null, output_bytes)   else 1 end compression_ratio,   sys.dbms_rcvman.num2displaysize(input_bytes) input_bytes_display,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1  from (select sum(num_files_backed) num_files_backed,       sum(distinct_files_backed) distinct_files_backed,       min(min_first_change#) min_first_change#,       max(max_next_change#) max_next_change#,       min(min_first_time) min_first_time,       max(max_next_time) max_next_time,       sum(original_input_bytes) input_bytes,       sum(output_bytes) output_bytes  from ((select num_files_backed,       distinct_files_backed,       min_first_change#,       max_next_change#,       min_first_time,       max_next_time,       original_input_bytes,       output_bytes  from (select count(*) num_files_backed,       min(first_change#)min_first_change#,       max(next_change#) max_next_change#,       min(first_time)min_first_time,       max(next_time) max_next_time    from v$backup_redolog     where (set_stamp, set_count) in      (select set_stamp, set_count from v$backup_set_details)),(select count(*) distinct_files_backed     from (select unique thread#, sequence#,resetlogs_change#, resetlogs_time           from v$backup_redolog           where (set_stamp, set_count) in              (select set_stamp, set_count from v$backup_set_details))), (select nvl(sum(original_input_bytes),0) original_input_bytes,         nvl(sum(output_bytes), 0) output_bytes        from        (select unique set_count, set_stamp, original_input_bytes,                       output_bytes from         v$backup_set_details where backup_type='L'))) union (select num_files_backed,        distinct_files_backed,        min_first_change#,        max_next_change#,        min_first_time,        max_next_time,        original_input_bytes,        output_bytes  from (select count(*) num_files_backed,       min(first_change#)min_first_change#,        max(next_change#) max_next_change#,        min(first_time)min_first_time,        max(next_time) max_next_time,        nvl(sum((blocks+1)*block_size),0) original_input_bytes,        nvl(sum((blocks+1)*block_size),0) output_bytes     from v$proxy_archivedlog a, v$rman_status  b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)), (select count(*) distinct_files_backed     from (select unique thread#, sequence#, resetlogs_change#,resetlogs_time           from v$proxy_archivedlog a, v$rman_status   b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time))))))a
+++V$BACKUP_ASYNC_IO+++               select SID, SERIAL, USE_COUNT, RMAN_STATUS_RECID, RMAN_STATUS_STAMP,DEVICE_TYPE, TYPE, STATUS,FILENAME, SET_COUNT, SET_STAMP, BUFFER_SIZE, BUFFER_COUNT, TOTAL_BYTES, OPEN_TIME, CLOSE_TIME, ELAPSED_TIME, MAXOPENFILES, BYTES, EFFECTIVE_BYTES_PER_SECOND, IO_COUNT, READY, SHORT_WAITS, SHORT_WAIT_TIME_TOTAL, SHORT_WAIT_TIME_MAX, LONG_WAITS, LONG_WAIT_TIME_TOTAL, LONG_WAIT_TIME_MAX, CON_ID from gv$backup_async_io where inst_id = userenv('Instance')
+++V$BACKUP_COMPRESSION_PROGRESS+++   select SID, BACKUP_ID, COMPRESSED_SO_FAR, BACKUP_PIECE_SIZE,  COMPRESSION_MODE, TOTAL_DATAFILES, REMAINING_DATAFILES, MB_WRITTEN_SO_FAR,  CURRENT_COMPRESSION_FACTOR, START_TIME, LAST_UPDATE_TIME, TIME_REMAINING,  ELAPSED_SECONDS,  CON_ID from GV$BACKUP_COMPRESSION_PROGRESS where inst_id=USERENV('Instance')
+++V$BACKUP_CONTROLFILE_DETAILS+++    select a.*,        sys.dbms_rcvman.num2displaysize(filesize) filesize_display, 1  from (select unique 'BACKUPSET' btype, b.recid btype_key,        b.session_recid session_key,        b.session_recid,        b.session_stamp,        a.set_stamp id1,         b.set_count id2,        creation_time,        resetlogs_change#,resetlogs_time,checkpoint_change#,checkpoint_time,        (datafile_blocks+1)*a.block_size filesize,       1 compression_ratio    from v$backup_datafile a, v$backup_set_details b where         a.set_stamp = b.set_stamp and         a.set_count = b.set_count and         file# = 0 union select unique 'IMAGECOPY' btype, a.recid btype_key,         b.session_recid session_key,        b.session_recid,       b.session_stamp,       a.recid, a.stamp,        creation_time,        resetlogs_change#,resetlogs_time,checkpoint_change#,checkpoint_time,        (blocks+1)*block_size filesize,        1 compression_ratio    from v$datafile_copy a, v$rman_status b ,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.file# = 0 and            a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)union select unique 'PROXYCOPY' btype, a.recid btype_key,         b.session_recid session_key,        b.session_recid,        b.session_stamp,        a.recid, a.stamp,         creation_time,        resetlogs_change#,resetlogs_time,checkpoint_change#,checkpoint_time,        (blocks+1)*block_size filesize,        1 compression_ratio    from v$proxy_datafile a, v$rman_status b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.file# = 0 and            a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time))a
+++V$BACKUP_CONTROLFILE_SUMMARY+++    select a.*,   case when      input_bytes/decode(output_bytes, 0, null, output_bytes) > 1   then      input_bytes/decode(output_bytes, 0, null, output_bytes)   else 1 end compression_ratio,   sys.dbms_rcvman.num2displaysize(input_bytes) input_bytes_display,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1  from (select sum(num_times_backed) num_files_backed,        1 num_distinct_files_backed,       min(min_checkpoint_change#) min_checkpoint_change#,       max(max_checkpoint_change#) max_checkpoint_change#,       min(min_checkpoint_time) min_checkpoint_time,       max(max_checkpoint_time) max_checkpoint_time,       sum(input_bytes) input_bytes,       sum(output_bytes) output_bytes   from    ((select unique count(*) over (partition by creation_time)            num_times_backed,       min(checkpoint_change#) over (partition by creation_time)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by creation_time)                  max_checkpoint_change#,       min(checkpoint_time) over (partition by creation_time)                  min_checkpoint_time,       max(checkpoint_time) over (partition by creation_time)                  max_checkpoint_time,       sum((datafile_blocks+1)*block_size)                  over (partition by creation_time) input_bytes,       sum((blocks+1)*block_size) over (partition by creation_time)                 output_bytes,       creation_time     from v$backup_datafile     where file# = 0 and      (set_stamp, set_count) in      (select set_stamp, set_count from v$backup_set_details)    )     union     (select unique count(*) over (partition by creation_time)              num_times_backed,       min(checkpoint_change#) over (partition by creation_time)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by creation_time)                  max_checkpoint_change#,       min(checkpoint_time) over (partition by creation_time)                  min_checkpoint_time,       max(checkpoint_time) over (partition by creation_time)                  max_checkpoint_time,       sum((blocks+1)*block_size) over (partition by creation_time)                  input_bytes,        sum((blocks+1)*block_size) over (partition by creation_time)                  output_bytes,        creation_time     from v$datafile_copy a, v$rman_status  b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.file# = 0 and a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)     )     union     (select unique count(*) over (partition by creation_time)              num_times_backed,        min(checkpoint_change#) over (partition by creation_time)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by creation_time)                  max_checkpoint_change#,       min(checkpoint_time) over (partition by creation_time)                  min_checkpoint_time,        max(checkpoint_time) over (partition by creation_time)                  max_checkpoint_time,        sum((blocks+1)*block_size) over (partition by creation_time)                  input_bytes,        sum((blocks+1)*block_size) over (partition by creation_time)                  output_bytes,        creation_time     from v$proxy_datafile a, v$rman_status  b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from
+++V$BACKUP_COPY_DETAILS+++           select a.*,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1 from (select b.session_recid session_key, b.session_recid, b.session_stamp,        a.recid copy_key, a.file#, a.name, a.tag, a.creation_change#,        a.creation_time, a.checkpoint_change#, a.checkpoint_time,        a.marked_corrupt, (a.blocks+1)*a.block_size output_bytes,        a.completion_time, a.controlfile_type, keep, keep_until,       keep_options, is_recovery_dest_file   from v$datafile_copy a, v$rman_status b,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and            a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time))a
+++V$BACKUP_COPY_SUMMARY+++           select a.*,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1  from (select nvl(sum(num_times_backed),0) num_copies,       sum(distinct_copies)  distinct_copies,       min(min_checkpoint_change#) min_checkpoint_change#,       max(max_checkpoint_change#) max_checkpoint_change#,       min(min_checkpoint_time) min_checkpoint_time,       max(max_checkpoint_time) max_checkpoint_time,       sum(output_bytes) output_bytes    from     (select unique file#,count(*) over (partition by file#, creation_change#)              num_times_backed,       count(distinct file#)               over (partition by file#, creation_change#,checkpoint_change#)              distinct_copies,       min(checkpoint_change#) over (partition by file#, creation_change#)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by file#, creation_change#)                  max_checkpoint_change#,       min(checkpoint_time) over (partition by file#, creation_change#)                  min_checkpoint_time,       max(checkpoint_time) over (partition by file#, creation_change#)                  max_checkpoint_time,       sum((blocks+1)*block_size) over (partition by file#, creation_change#)                  output_bytes     from v$datafile_copy a, v$rman_status   b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)))a
+++V$BACKUP_CORRUPTION+++             select  RECID , STAMP , SET_STAMP , SET_COUNT , PIECE# , FILE# , BLOCK# , BLOCKS , CORRUPTION_CHANGE# , MARKED_CORRUPT, CORRUPTION_TYPE, CON_ID from GV$BACKUP_CORRUPTION where inst_id = USERENV('Instance')
+++V$BACKUP_DATAFILE+++               select  RECID , STAMP , SET_STAMP , SET_COUNT , FILE# , CREATION_CHANGE# , CREATION_TIME , RESETLOGS_CHANGE# , RESETLOGS_TIME , INCREMENTAL_LEVEL , INCREMENTAL_CHANGE# , CHECKPOINT_CHANGE# , CHECKPOINT_TIME , ABSOLUTE_FUZZY_CHANGE# , MARKED_CORRUPT , MEDIA_CORRUPT , LOGICALLY_CORRUPT , DATAFILE_BLOCKS , BLOCKS , BLOCK_SIZE, OLDEST_OFFLINE_RANGE, COMPLETION_TIME ,CONTROLFILE_TYPE, USED_CHANGE_TRACKING, BLOCKS_READ, USED_OPTIMIZATION, FOREIGN_DBID, PLUGGED_READONLY, PLUGIN_CHANGE#, PLUGIN_RESETLOGS_CHANGE#, PLUGIN_RESETLOGS_TIME, SECTION_SIZE, UNDO_OPTIMIZED, BLOCKS_SKIPPED_IN_CELL, CON_ID, BACKED_BY_PDB from GV$BACKUP_DATAFILE where inst_id = USERENV('Instance')
+++V$BACKUP_DATAFILE_DETAILS+++       select a.*, b.ts#, b.name tsname,       sys.dbms_rcvman.num2displaysize(filesize) filesize_display, b.con_id  from (select unique 'BACKUPSET' btype, b.recid btype_key,        b.session_recid session_key,        b.session_recid,        b.session_stamp,        a.set_stamp id1,         b.set_count id2, file#,        creation_change#, creation_time,        resetlogs_change#, resetlogs_time, a.incremental_level,        incremental_change#, checkpoint_change#, checkpoint_time,        marked_corrupt,        (datafile_blocks+1)*a.block_size filesize,       (datafile_blocks+1)/(blocks+1)    from v$backup_datafile a, v$backup_set_details b where         a.set_stamp = b.set_stamp and         a.set_count = b.set_count and         file#<>0 union select unique 'IMAGECOPY' btype, a.recid btype_key,         b.session_recid session_key,        b.session_recid,       b.session_stamp,       a.recid, a.stamp, file#,        creation_change#, creation_time,        resetlogs_change#, resetlogs_time, incremental_level,         0 incremental_change#, checkpoint_change#, checkpoint_time,        marked_corrupt,         (blocks+1)*block_size filesize,        1 compression_ratio    from v$datafile_copy a, v$rman_status b ,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.file#<>0 and            a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)union select unique 'PROXYCOPY' btype, a.recid btype_key,         b.session_recid session_key,        b.session_recid,        b.session_stamp,        a.recid, a.stamp, file#,         creation_change#, creation_time,        resetlogs_change#, resetlogs_time, incremental_level,         0 incremental_change#, checkpoint_change#, checkpoint_time,        null marked_corrupt,         (blocks+1)*block_size filesize,        1 compression_ratio    from v$proxy_datafile a, v$rman_status b ,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.file#<>0 and            a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)) a, (select df.file#, df.ts#, ts.name, df.con_id    from v$datafile df, v$tablespace ts   where ts.ts# = df.ts#     and ts.con_id = df.con_id) b where a.file# = b.file#(+)
+++V$BACKUP_DATAFILE_SUMMARY+++       select /*+ rule */ a.*,   case when      input_bytes/decode(output_bytes, 0, null, output_bytes) > 1   then      input_bytes/decode(output_bytes, 0, null, output_bytes)   else 1 end compression_ratio,   sys.dbms_rcvman.num2displaysize(input_bytes) input_bytes_display,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1  from (select sum(num_times_backed) num_files_backed,        count(*) num_distinct_files_backed,       count(distinct ts# || '.' || ts_conid) num_distinct_ts_backed,       min(min_checkpoint_change#) min_checkpoint_change#,       max(max_checkpoint_change#) max_checkpoint_change#,       min(min_checkpoint_time) min_checkpoint_time,       max(max_checkpoint_time) max_checkpoint_time,       sum(input_bytes) input_bytes,       sum(output_bytes) output_bytes    from    (select a.*, b.ts#, b.con_id ts_conid   from    (select unique a.file#, sum(a.num_times_backed) num_times_backed,           min(min_checkpoint_change#) min_checkpoint_change#,            max(max_checkpoint_change#) max_checkpoint_change#,            min(min_checkpoint_time) min_checkpoint_time,            max(max_checkpoint_time) max_checkpoint_time,            sum(input_bytes) input_bytes,            sum(output_bytes) output_bytes,            creation_change#     from    ((select unique file#,count(*) over (partition by file#, creation_change#)            num_times_backed,       min(checkpoint_change#) over (partition by file#, creation_change#)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by file#, creation_change#)                  max_checkpoint_change#,       min(checkpoint_time) over (partition by file#, creation_change#)                  min_checkpoint_time,       max(checkpoint_time) over (partition by file#, creation_change#)                  max_checkpoint_time,       sum((datafile_blocks+1)*block_size)                  over (partition by file#, creation_change#) input_bytes,       sum((blocks+1)*block_size) over (partition by file#, creation_change#)                 output_bytes,       creation_change#     from v$backup_datafile     where file# <> 0 and      (set_stamp, set_count) in      (select set_stamp, set_count from v$backup_set_details)    )     union     (select unique file#, count(*) over (partition by file#,creation_change#)              num_times_backed,       min(checkpoint_change#) over (partition by file#, creation_change#)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by file#, creation_change#)                  max_checkpoint_change#,       min(checkpoint_time) over (partition by file#, creation_change#)                  min_checkpoint_time,       max(checkpoint_time) over (partition by file#, creation_change#)                  max_checkpoint_time,       sum((blocks+1)*block_size) over (partition by file#, creation_change#)                  input_bytes,        sum((blocks+1)*block_size) over (partition by file#, creation_change#)                  output_bytes,        creation_change#     from v$datafile_copy a, v$rman_status  b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.file# <> 0 and a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)     )     union     (select unique file#, count(*) over (partition by file#,creation_change#)              num_times_backed,        min(checkpoint_change#) over (partition by file#, creation_change#)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by file#, creation_change#)
+++V$BACKUP_DEVICE+++                 select DEVICE_TYPE, DEVICE_NAME, CON_ID FROM GV$BACKUP_DEVICE  where INST_ID = USERENV('Instance')
+++V$BACKUP_NONLOGGED+++               select                                                                         recid,                                                                       stamp,                                                                       set_stamp,                                                                   set_count,                                                                   piece#,                                                                      file#,                                                                       block#,                                                                      blocks,                                                                      nonlogged_change#,                                                           nonlogged_time,                                                              resetlogs_change#,                                                           resetlogs_time,                                                              object#,                                                                     reason,                                                                      con_id                                                                     from                                                                           gv$backup_nonlogged                                                        where                                                                          inst_id = userenv('Instance')
+++V$BACKUP_PIECE+++                  select  RECID , STAMP ,SET_STAMP , SET_COUNT , PIECE# , COPY#, DEVICE_TYPE , HANDLE , COMMENTS , MEDIA , MEDIA_POOL , CONCUR , TAG , STATUS , START_TIME , COMPLETION_TIME , ELAPSED_SECONDS, DELETED, BYTES, IS_RECOVERY_DEST_FILE, RMAN_STATUS_RECID, RMAN_STATUS_STAMP, COMPRESSED, BACKED_BY_VSS, ENCRYPTED, BACKED_BY_OSB, FOR_XTTS, SAME_ENDIAN, CON_ID from GV$BACKUP_PIECE where inst_id = USERENV('Instance')
+++V$BACKUP_PIECE_DETAILS+++          select unique b.session_recid session_key, b.session_recid, b.session_stamp,        a.*,        sys.dbms_rcvman.num2displaysize(bytes) size_bytes_display    from    (select a.recid bs_key, c.recid bp_key, c.*    from v$backup_set a,    (select v$backup_piece.*,        count(piece#) over             (partition by set_count, set_stamp, copy#) pieces_per_set     from v$backup_piece     where status = 'A') c     where a.set_stamp = c.set_stamp and a.set_count = c.set_count and          a.pieces = c.pieces_per_set) a,    (select session_recid, session_stamp, recid, stamp, start_time, end_time     from v$rman_status) b ,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.rman_status_recid = b.recid (+) and            a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)
+++V$BACKUP_REDOLOG+++                select  RECID , STAMP , SET_STAMP , SET_COUNT , THREAD# , SEQUENCE# , RESETLOGS_CHANGE# , RESETLOGS_TIME , FIRST_CHANGE# , FIRST_TIME , NEXT_CHANGE# , NEXT_TIME , BLOCKS , BLOCK_SIZE, TERMINAL, CON_ID from GV$BACKUP_REDOLOG where inst_id = USERENV('Instance')
+++V$BACKUP_SET+++                    select  RECID , STAMP , SET_STAMP , SET_COUNT , BACKUP_TYPE , CONTROLFILE_INCLUDED , INCREMENTAL_LEVEL , PIECES , START_TIME , COMPLETION_TIME , ELAPSED_SECONDS , BLOCK_SIZE , INPUT_FILE_SCAN_ONLY, KEEP, KEEP_UNTIL, KEEP_OPTIONS, MULTI_SECTION, FOR_XTTS, SAME_ENDIAN, INC_DMPFILE, CON_ID from GV$BACKUP_SET where inst_id = USERENV('Instance')
+++V$BACKUP_SET_DETAILS+++            select unique b.session_recid session_key, b.session_recid, b.session_stamp,              a.recid bs_key, a.RECID, a.stamp,              a.set_stamp, a.set_count, a.backup_type, a.controlfile_included,              a.incremental_level, a.pieces, a.start_time, a.completion_time,              a.elapsed_seconds, a.block_size, a.keep, a.keep_until,              a.keep_options, a.device_type, a.compressed,               a.num_copies, a.output_bytes,              a.original_input_bytes, case when a.compression_ratio > 1 then                                  a.compression_ratio else 1 end, 'A' status,              a.original_inprate_bytes, a.output_rate_bytes,   sys.dbms_rcvman.num2displaysize(original_input_bytes)         original_input_bytes_display,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display ,   sys.dbms_rcvman.num2displaysize(original_inprate_bytes)         original_inprate_bytes_display,   sys.dbms_rcvman.num2displaysize(output_rate_bytes)         output_rate_bytes_display,   sys.dbms_rcvman.sec2displaytime(elapsed_seconds) time_taken_display,    a.encrypted, a.backed_by_osb, a.con_id    from    (   select unique a.*,       b.rman_status_recid, b.rman_status_stamp,       decode(b.devcnt, 1, first_value(b.device_type) over                                      (partition by b.set_stamp, b.set_count),                             '*') device_type, b.compressed,         count(distinct copy#)              over (partition by b.set_stamp, b.set_count) num_copies,        b.output_bytes output_bytes,         c.original_input_bytes,        c.original_input_bytes /           (decode(b.output_bytes,0,c.original_input_bytes,b.output_bytes))               compression_ratio,         c.original_input_bytes/                (decode(a.elapsed_seconds, 0, 1, a.elapsed_seconds))                 original_inprate_bytes,        b.output_bytes/                (decode(a.elapsed_seconds, 0, 1, a.elapsed_seconds))                 output_rate_bytes,        b.encrypted, b.backed_by_osb    from v$backup_set a,   (select set_stamp, set_count, device_type, status,   count(distinct device_type) over (partition by set_count,set_stamp)devcnt,    compressed, encrypted, backed_by_osb,     sum(bytes) over (partition by set_count, set_stamp, copy#) output_bytes,     copy#, RMAN_STATUS_RECID, RMAN_STATUS_STAMP,     count(piece#) over (partition by set_count, set_stamp, copy#) npieces     from v$backup_piece where status = 'A') b,   (     select set_stamp, set_count, sum(original_input_bytes)            original_input_bytes from    (       select set_stamp, set_count,       sum((datafile_blocks+1)*block_size)          over (partition by set_count, set_stamp) original_input_bytes       from v$backup_datafile       union       select set_stamp, set_count,       sum(bytes)          over (partition by set_count, set_stamp) original_input_bytes       from v$backup_spfile     ) group by set_stamp, set_count     union     select set_stamp, set_count,       sum((blocks+1)*block_size)        over (partition by set_count, set_stamp) original_input_bytes     from v$backup_redolog     ) c    where a.set_stamp=b.set_stamp and a.set_count=b.set_count and          a.set_stamp=c.set_stamp and a.set_count=c.set_count and          a.pieces=b.npieces    ) a,    (select session_recid, session_stamp, recid, stamp, start_time, end_time     from v$rman_status) b,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.rman_status_recid = b.recid (+) and            a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)
+++V$BACKUP_SET_SUMMARY+++            select a.*,   case when      original_input_bytes/decode(output_bytes, 0, null, output_bytes) > 1   then      original_input_bytes/decode(output_bytes, 0, null, output_bytes)   else 1 end compression_ratio,   sys.dbms_rcvman.num2displaysize(original_input_bytes)         original_input_bytes_display,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display ,   sys.dbms_rcvman.num2displaysize(original_inprate_bytes)         original_inprate_bytes_display,   sys.dbms_rcvman.num2displaysize(output_rate_bytes)         output_rate_bytes_display, 1 from (select count(*) num_backupsets,       min(start_time) oldest_backup_time,       max(start_time) newest_backup_time,       sum(output_bytes) output_bytes,       sum(original_input_bytes) original_input_bytes,       avg(original_inprate_bytes) original_inprate_bytes,       avg(output_rate_bytes) output_rate_bytes from   (select unique      set_stamp, set_count,     start_time,     output_bytes,     original_input_bytes,     original_inprate_bytes,     output_rate_bytes,     compression_ratio    from      v$backup_set_details))a
+++V$BACKUP_SPFILE+++                 select  RECID , STAMP , SET_STAMP , SET_COUNT , MODIFICATION_TIME,  BYTES , COMPLETION_TIME, DB_UNIQUE_NAME, CON_ID from GV$BACKUP_SPFILE  where inst_id = USERENV('Instance')
+++V$BACKUP_SPFILE_DETAILS+++         select unique b.session_recid session_key, b.session_recid,        b.session_stamp, b.recid bs_key, a.set_stamp, b.set_count,        modification_time,        a.bytes,        sys.dbms_rcvman.num2displaysize(a.bytes) filesize_display, b.con_id    from v$backup_spfile a, v$backup_set_details b where         a.set_stamp = b.set_stamp and         a.set_count = b.set_count
+++V$BACKUP_SPFILE_SUMMARY+++         select num_files_backed,        num_distinct_files_backed,        min_modification_time,        max_modification_time,        input_bytes,    sys.dbms_rcvman.num2displaysize(input_bytes) input_bytes_display, 1  from (select count(*) num_files_backed,        min(modification_time)min_modification_time,        max(modification_time) max_modification_time,        sum(bytes) input_bytes     from v$backup_spfile     where (set_stamp, set_count) in      (select set_stamp, set_count from v$backup_set_details)), (select count(*) num_distinct_files_backed     from (select unique modification_time           from v$backup_spfile           where (set_stamp, set_count) in              (select set_stamp, set_count                  from v$backup_set_details)))
+++V$BACKUP_SYNC_IO+++                select SID, SERIAL, USE_COUNT, RMAN_STATUS_RECID, RMAN_STATUS_STAMP,DEVICE_TYPE, TYPE, STATUS, FILENAME, SET_COUNT, SET_STAMP, BUFFER_SIZE, BUFFER_COUNT, TOTAL_BYTES, OPEN_TIME, CLOSE_TIME, ELAPSED_TIME, MAXOPENFILES, BYTES, EFFECTIVE_BYTES_PER_SECOND, IO_COUNT, IO_TIME_TOTAL, IO_TIME_MAX, DISCRETE_BYTES_PER_SECOND, CON_ID from gv$backup_sync_io where inst_id = userenv('Instance')
+++V$BGPROCESS+++                     select paddr,pserial#,name,description,error, con_id  from gv$bgprocess where inst_id  = USERENV('Instance')
+++V$BH+++                            select file#, block#, class#, status, xnc, forced_reads, forced_writes, lock_element_addr, lock_element_name, lock_element_class, dirty, temp, ping, stale, direct, new, objd, ts#, lobid, cachehint, flash_cache, cell_flash_cache, con_id from gv$bh where inst_id = USERENV('Instance')
+++V$BLOCKING_QUIESCE+++              select sid, con_id from gv$blocking_quiesce         where inst_id = userenv('instance')
+++V$BLOCK_CHANGE_TRACKING+++         select decode(di2ctst, 0, 'DISABLED', 1, 'TRANSITION', 2, 'ENABLED','ERROR'),fnnam, fh.bytes, a.con_id from x$kccdi2, x$kccfn a, (select max(fhfsz*fhbsz) bytes from x$krcfh) fh where fnnum(+)=di2ctfn and fntyp(+)=200
+++V$BSP+++                           select cr_requests, current_requests, data_requests,            undo_requests, tx_requests, current_results,                    private_results, zero_results, disk_read_results,               fail_results, fairness_down_converts, fairness_clears,          free_lock_elements, flushes, flushes_queued,                    flush_queue_full, flush_max_time, light_works, errors, con_id           from gv$bsp where inst_id = USERENV('Instance')
+++V$BTS_STAT+++                      SELECT tsn, tsv, maxsize, cursize, used, utime,          dalloc, dfree, nalloc, nfree, dtime,          talloc, tfree, ttime, flag, con_id          FROM GV$BTS_STAT WHERE INST_ID = USERENV('INSTANCE')
+++V$BT_SCAN_CACHE+++                 select BT_CACHE_ALLOC, BT_CACHE_TARGET, OBJECT_COUNT,          MEMORY_BUF_ALLOC, MIN_CACHED_TEMP,                             CON_ID                                                         from GV$BT_SCAN_CACHE                                          where INST_ID = USERENV('Instance')
+++V$BT_SCAN_OBJ_TEMPS+++             select TS#, DATAOBJ#, SIZE_IN_BLKS, TEMPERATURE,          POLICY, CACHED_IN_MEM, CON_ID          from GV$BT_SCAN_OBJ_TEMPS                where INST_ID = USERENV('Instance')
+++V$BUFFERED_PUBLISHERS+++           select queue_id, queue_schema, queue_name, sender_name,  sender_address, sender_protocol, num_msgs, cnum_msgs, last_enqueued_msg,  unbrowsed_msgs, overspilled_msgs, memory_usage,  elapsed_enqueue_time, enqueue_cpu_time, last_enqueue_time,  publisher_state, con_id  from gv$buffered_publishers where inst_id = USERENV('Instance')
+++V$BUFFERED_QUEUES+++               select queue_id, queue_schema, queue_name, startup_time,  num_msgs, spill_msgs,  cnum_msgs, cspill_msgs, expired_msgs,  oldest_msgid, oldest_msg_enqtm, queue_state,  elapsed_enqueue_time, elapsed_dequeue_time,  elapsed_transformation_time, elapsed_rule_evaluation_time,  enqueue_cpu_time, dequeue_cpu_time, avg_msg_age,  last_enqueue_time, last_dequeue_time, queue_size, con_id from gv$buffered_queues where inst_id =  USERENV('Instance')
+++V$BUFFERED_SUBSCRIBERS+++          select queue_id, queue_schema, queue_name, subscriber_id, subscriber_name,  subscriber_address, protocol, subscriber_type,  startup_time, last_browsed_seq,  last_browsed_num, last_dequeued_seq, last_dequeued_num, current_enq_seq,  num_msgs, cnum_msgs, total_dequeued_msg, total_spilled_msg, expired_msgs,  message_lag, elapsed_dequeue_time, dequeue_cpu_time, avg_msg_age,  last_dequeue_time, oldest_msgid, oldest_msg_enqtm, con_id  from gv$buffered_subscribers where inst_id = USERENV('Instance')
+++V$BUFFER_POOL+++                   select id, name, block_size, resize_state, current_size, buffers,            target_size, target_buffers, prev_size, prev_buffers,                 lo_bnum, hi_bnum, lo_setid, hi_setid, set_count, con_id        from gv$buffer_pool  where inst_id = USERENV('Instance')
+++V$BUFFER_POOL_STATISTICS+++        select id, name, block_size, set_msize, cnum_repl, cnum_write, cnum_set, buf_got, sum_write, sum_scan, free_buffer_wait, write_complete_wait, buffer_busy_wait, free_buffer_inspected, dirty_buffers_inspected, db_block_change, db_block_gets, consistent_gets, physical_reads, physical_writes, con_id from gv$buffer_pool_statistics where inst_id = USERENV('Instance')
+++V$CACHE+++                         SELECT file#, block#, class#, status, xnc, forced_reads,         forced_writes, name, partition_name, kind, owner#,         lock_element_addr, lock_element_name, con_id  FROM   gv$cache  WHERE  INST_ID = USERENV('Instance')
+++V$CACHE_LOCK+++                    SELECT file#, block#, status, xnc, forced_reads, forced_writes,        name, kind, owner#, c.lock_element_addr, c.lock_element_name,         indx, class, c.con_id  FROM   v$cache c, v$lock_element l  WHERE  l.lock_element_addr = c.lock_element_addr
+++V$CACHE_TRANSFER+++                select file#, block#, class#, status, xnc, forced_reads,         forced_writes, name, partition_name, kind, owner#,         lock_element_addr, lock_element_name, con_id  FROM   gv$cache_transfer  WHERE  INST_ID = USERENV('Instance')
+++V$CALLTAG+++                       select session_id, performance_class, work_request_class,         hop_count, pc_unknown, service_name, module, action,         username, program, con_id         from gv$calltag where inst_id = USERENV('Instance')
+++V$CELL+++                          SELECT CELL_PATH, CELL_HASHVAL, CON_ID, CELL_TYPE         FROM GV$CELL WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_CONFIG+++                   SELECT CELLNAME, CELLHASH, CONFTYPE, CONFVAL, CON_ID         FROM GV$CELL_CONFIG WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_CONFIG_INFO+++              SELECT CELLNAME, CELLHASH, CONFTYPE, CONFVAL_HASH, CONFVAL, CON_ID         FROM GV$CELL_CONFIG_INFO WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_DB+++                       SELECT CELL_NAME, CELL_HASH, INCARNATION_NUM, METRIC_TIMESTAMP, SRC_DBNAME, SRC_DBID, METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_TYPE, CON_ID FROM GV$CELL_DB WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_DB_HISTORY+++               SELECT CELL_NAME, CELL_HASH, INCARNATION_NUM, BEGIN_TIME, END_TIME, SRC_DBNAME, SRC_DBID, METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_TYPE, CON_ID FROM GV$CELL_DB_HISTORY WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_DISK+++                     SELECT CELL_NAME, CELL_HASH, INCARNATION_NUM, METRIC_TIMESTAMP, DISK_NAME, DISK_ID, METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_TYPE, CON_ID FROM GV$CELL_DISK WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_DISK_HISTORY+++             SELECT CELL_NAME, CELL_HASH, INCARNATION_NUM, BEGIN_TIME, END_TIME, DISK_NAME, DISK_ID, METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_TYPE, CON_ID FROM GV$CELL_DISK_HISTORY WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_GLOBAL+++                   SELECT CELL_NAME, CELL_HASH, INCARNATION_NUM, METRIC_TIMESTAMP, METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_TYPE, CON_ID FROM GV$CELL_GLOBAL WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_GLOBAL_HISTORY+++           SELECT CELL_NAME, CELL_HASH, INCARNATION_NUM, BEGIN_TIME, END_TIME, METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_TYPE, CON_ID FROM GV$CELL_GLOBAL_HISTORY WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_IOREASON+++                 SELECT CELL_NAME, CELL_HASH, INCARNATION_NUM, METRIC_TIMESTAMP, REASON_ID, REASON_NAME, METRIC_ID, METRIC_NAME, METRIC_VALUE, METRIC_TYPE, CON_ID FROM GV$CELL_IOREASON WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_IOREASON_NAME+++            SELECT REASON_ID, REASON_NAME, CON_ID FROM GV$CELL_IOREASON_NAME WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_METRIC_DESC+++              SELECT METRIC_ID, METRIC_NAME, METRIC_TYPE, CON_ID FROM GV$CELL_METRIC_DESC WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_OFL_THREAD_HISTORY+++       SELECT CELL_NAME, GROUP_NAME, PROCESS_ID, SNAPSHOT_ID, SNAPSHOT_TIME, THREAD_ID, JOB_TYPE, WAIT_STATE, WAIT_OBJECT_NAME, SQL_ID, DATABASE_ID, INSTANCE_ID, SESSION_ID, SESSION_SERIAL_NUM, CON_ID FROM GV$CELL_OFL_THREAD_HISTORY WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_OPEN_ALERTS+++              SELECT CELL_NAME, CELL_HASH, BEGIN_TIME, SEQ_NO, MESSAGE, STATEFUL, SEVERITY, CON_ID FROM GV$CELL_OPEN_ALERTS WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_REQUEST_TOTALS+++           SELECT CELL_NAME, SNAPSHOT_ID, SNAPSHOT_TIME, STATISTICS_NAME, STATISTICS_VALUE, CON_ID FROM GV$CELL_REQUEST_TOTALS WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_STATE+++                    SELECT CELL_NAME, STATISTICS_TYPE, OBJECT_NAME, STATISTICS_VALUE, CON_ID FROM GV$CELL_STATE WHERE INST_ID = USERENV('INSTANCE')
+++V$CELL_THREAD_HISTORY+++           SELECT CELL_NAME, SNAPSHOT_ID, SNAPSHOT_TIME, THREAD_ID, JOB_TYPE, WAIT_STATE, WAIT_OBJECT_NAME, SQL_ID, DATABASE_ID, INSTANCE_ID, SESSION_ID, SESSION_SERIAL_NUM, CON_ID FROM GV$CELL_THREAD_HISTORY WHERE INST_ID = USERENV('INSTANCE')
+++V$CHANNEL_WAITS+++                 select            CHANNEL, MESSAGES_PUBLISHED, WAIT_COUNT, WAIT_TIME_USEC, CON_ID          from GV$CHANNEL_WAITS where INST_ID = USERENV('Instance')
+++V$CIRCUIT+++                       select  CIRCUIT , DISPATCHER , SERVER , WAITER , SADDR , STATUS , QUEUE , MESSAGE0 , MESSAGE1 , MESSAGE2, MESSAGE3, MESSAGES , BYTES , BREAKS , PRESENTATION, PCIRCUIT, CON_ID from GV$CIRCUIT where inst_id = USERENV('Instance')
+++V$CLASS_CACHE_TRANSFER+++          select class,                                          x_2_null,              x_2_null_forced_write,          x_2_null_forced_stale, x_2_s,                          x_2_s_forced_write,    s_2_null,                       s_2_null_forced_stale, null_2_x,                       s_2_x,                 null_2_s,                       cr_transfer,           current_transfer, con_id                from gv$class_cache_transfer                           where inst_id = USERENV('Instance')
+++V$CLASS_PING+++                    select class, x_2_null, x_2_null_forced_write, x_2_null_forced_stale,  x_2_s, x_2_s_forced_write, x_2_ssx, x_2_ssx_forced_write, s_2_null,    s_2_null_forced_stale, ss_2_null, ss_2_rls, op_2_ss, null_2_x, s_2_x,  ssx_2_x, null_2_s, null_2_ss, con_id from gv$class_ping                        where inst_id = USERENV('Instance')
+++V$CLIENT_RESULT_CACHE_STATS+++     select  CACHE_ID, STAT_ID, NAME, VALUE, CON_ID from GV$CLIENT_RESULT_CACHE_STATS where inst_id=USERENV('Instance')
+++V$CLIENT_SECRETS+++                SELECT CLIENT, SECRET_TAG, CREATION_TIME, ACTIVATION_TIME, OWNER, OWNER_ID, KEYSTORE_TYPE, BACKED_UP, OWNER_DBNAME, OWNER_DBID, OWNER_INSTANCE_NAME, OWNER_INSTANCE_NUMBER, OWNER_INSTANCE_SERIAL, OWNER_PDBNAME, OWNER_PDBID, OWNER_PDBUID, OWNER_PDBGUID, CON_ID FROM GV$CLIENT_SECRETS WHERE INST_ID = USERENV('Instance')
+++V$CLIENT_STATS+++                  select  CLIENT_IDENTIFIER , STAT_ID , STAT_NAME ,  VALUE, CON_ID from GV$CLIENT_STATS  where inst_id = USERENV('Instance')
+++V$CLONEDFILE+++                    select SNAPSHOTFILENAME, CLONEFILENAME, SNAPSHOTBLKREAD, SNAPSHOTREQUEST,  FILENUMBER, CON_ID, BLOCKS_ALLOCATED from gv$clonedfile
+++V$CLUSTER_INTERCONNECTS+++         SELECT NAME, IP_ADDRESS, IS_PUBLIC, SOURCE, CON_ID          FROM GV$CLUSTER_INTERCONNECTS  WHERE          INST_ID=USERENV('Instance')
+++V$CONFIGURED_INTERCONNECTS+++      SELECT NAME, IP_ADDRESS, IS_PUBLIC,          SOURCE, CON_ID FROM GV$CONFIGURED_INTERCONNECTS WHERE          INST_ID=USERENV('Instance')
+++V$CONTAINERS+++                    select con_id, dbid, con_uid, guid, name,  open_mode, restricted, open_time, create_scn, total_size, block_size, recovery_status, snapshot_parent_con_id from GV$CONTAINERS  WHERE  INST_ID = USERENV('Instance')
+++V$CONTEXT+++                       select namespace, attribute, value, con_id from x$context
+++V$CONTROLFILE+++                   select  STATUS , NAME, IS_RECOVERY_DEST_FILE, BLOCK_SIZE, FILE_SIZE_BLKS,  CON_ID from GV$CONTROLFILE where inst_id = USERENV('Instance')
+++V$CONTROLFILE_RECORD_SECTION+++    select  TYPE , RECORD_SIZE , RECORDS_TOTAL , RECORDS_USED , FIRST_INDEX , LAST_INDEX , LAST_RECID, CON_ID from GV$CONTROLFILE_RECORD_SECTION where inst_id = USERENV('Instance')
+++V$CON_SYSSTAT+++                   select  STATISTIC# , NAME , CLASS , VALUE, STAT_ID, CON_ID from GV$CON_SYSSTAT where inst_id = USERENV('Instance')
+++V$CON_SYSTEM_EVENT+++               select event,total_waits,total_timeouts,time_waited,average_wait,  time_waited_micro, total_waits_fg, total_timeouts_fg, time_waited_fg,  average_wait_fg, time_waited_micro_fg,  event_id, wait_class_id, wait_class#, wait_class, con_id   from gv$con_system_event where inst_id = USERENV('Instance')
+++V$CON_SYSTEM_WAIT_CLASS+++         select wait_class_id, wait_class#,wait_class,total_waits,time_waited, total_waits_fg, time_waited_fg, con_id from gv$con_system_wait_class where inst_id = USERENV('Instance')
+++V$CON_SYS_TIME_MODEL+++            select STAT_ID, STAT_NAME, VALUE, CON_ID from GV$CON_SYS_TIME_MODEL  where inst_id = USERENV('Instance')
+++V$COPY_CORRUPTION+++               select  RECID , STAMP , COPY_RECID , COPY_STAMP , FILE# , BLOCK# , BLOCKS , CORRUPTION_CHANGE# , MARKED_CORRUPT, CORRUPTION_TYPE, CON_ID from GV$COPY_CORRUPTION where inst_id = USERENV('Instance')
+++V$COPY_NONLOGGED+++                 select                                                                         inst_id,                                                                     recid,                                                                       stamp,                                                                       copy_recid,                                                                  copy_stamp,                                                                  file#,                                                                       block#,                                                                      blocks,                                                                      nonlogged_change#,                                                           nonlogged_time,                                                              resetlogs_change#,                                                           resetlogs_time,                                                              object#,                                                                     reason,                                                                      con_id                                                                     from                                                                           gv$copy_nonlogged                                                          where                                                                          inst_id = userenv('Instance')
+++V$CORRUPT_XID_LIST+++              select  CORRUPT_XID, CON_ID from GV$CORRUPT_XID_LIST         where inst_id=USERENV('instance')
+++V$CPOOL_CC_INFO+++                 select  POOL_NAME,        CCLASS_NAME,         CON_ID from GV$CPOOL_CC_INFO where inst_id=USERENV('Instance')
+++V$CPOOL_CC_STATS+++                select  CCLASS_NAME,        NUM_REQUESTS,        NUM_HITS,        NUM_MISSES,        NUM_WAITS,        WAIT_TIME,        CLIENT_REQ_TIMEOUTS,        NUM_AUTHENTICATIONS,         CON_ID from GV$CPOOL_CC_STATS where inst_id=USERENV('Instance')
+++V$CPOOL_CONN_INFO+++               select  CMON_ADDR,         SESSION_ADDR,        CONNECTION_ADDR,        USERNAME,         PROXY_USER,        CCLASS_NAME,         PURITY,         TAG,         SERVICE,         PROCESS_ID,         PROGRAM,         MACHINE,         TERMINAL,         CONNECTION_MODE,         CONNECTION_STATUS,         CLIENT_REGID,         CURSTATUS_TIME,         CON_ID        from GV$CPOOL_CONN_INFO a where a.inst_id=USERENV('Instance')
+++V$CPOOL_STATS+++                   select  POOL_NAME,        NUM_OPEN_SERVERS,        NUM_BUSY_SERVERS,        NUM_AUTH_SERVERS,        NUM_REQUESTS,        NUM_HITS,        NUM_MISSES,        NUM_WAITS,        WAIT_TIME,        CLIENT_REQ_TIMEOUTS,        NUM_AUTHENTICATIONS,        NUM_PURGED,        HISTORIC_MAX,         CON_ID from GV$CPOOL_STATS where inst_id=USERENV('Instance')
+++V$CR_BLOCK_SERVER+++               select cr_requests, current_requests, data_requests,                   undo_requests, tx_requests, other_requests, current_results,           private_results, zero_results, disk_read_results,                      fail_results, stale, fairness_down_converts, fairness_clears,          free_gc_elements, flushes, flushes_queued,                             flush_queue_full, flush_max_time, light_works, errors, con_id          from gv$cr_block_server where inst_id = USERENV('Instance')
+++V$CURRENT_BLOCK_SERVER+++          select pin1, pin10, pin100, pin1000, pin10000,             flush1, flush10, flush100, flush1000, flush10000,          write1, write10, write100, write1000, write10000,          cleandc, rcvdc, queuedc, evictdc, writedc, con_id          from gv$current_block_server where inst_id = USERENV('Instance')
+++V$DATABASE+++                      select  DBID, NAME, CREATED, RESETLOGS_CHANGE#, RESETLOGS_TIME, PRIOR_RESETLOGS_CHANGE#, PRIOR_RESETLOGS_TIME,LOG_MODE, CHECKPOINT_CHANGE#, ARCHIVE_CHANGE#, CONTROLFILE_TYPE, CONTROLFILE_CREATED, CONTROLFILE_SEQUENCE#, CONTROLFILE_CHANGE#, CONTROLFILE_TIME, OPEN_RESETLOGS, VERSION_TIME, OPEN_MODE, PROTECTION_MODE, PROTECTION_LEVEL, REMOTE_ARCHIVE, ACTIVATION#, SWITCHOVER#, DATABASE_ROLE, ARCHIVELOG_CHANGE#, ARCHIVELOG_COMPRESSION, SWITCHOVER_STATUS, DATAGUARD_BROKER, GUARD_STATUS, SUPPLEMENTAL_LOG_DATA_MIN, SUPPLEMENTAL_LOG_DATA_PK, SUPPLEMENTAL_LOG_DATA_UI, FORCE_LOGGING, PLATFORM_ID, PLATFORM_NAME, RECOVERY_TARGET_INCARNATION#, LAST_OPEN_INCARNATION#, CURRENT_SCN, FLASHBACK_ON,SUPPLEMENTAL_LOG_DATA_FK, SUPPLEMENTAL_LOG_DATA_ALL, DB_UNIQUE_NAME, STANDBY_BECAME_PRIMARY_SCN, FS_FAILOVER_STATUS, FS_FAILOVER_CURRENT_TARGET, FS_FAILOVER_THRESHOLD, FS_FAILOVER_OBSERVER_PRESENT, FS_FAILOVER_OBSERVER_HOST, CONTROLFILE_CONVERTED, PRIMARY_DB_UNIQUE_NAME, SUPPLEMENTAL_LOG_DATA_PL, MIN_REQUIRED_CAPTURE_CHANGE#, CDB, CON_ID, PENDING_ROLE_CHANGE_TASKS, CON_DBID, FORCE_FULL_DB_CACHING from GV$DATABASE where inst_id = USERENV('Instance')
+++V$DATABASE_BLOCK_CORRUPTION+++     select FILE#, BLOCK#, BLOCKS, CORRUPTION_CHANGE#, CORRUPTION_TYPE, CON_ID  from GV$DATABASE_BLOCK_CORRUPTION   where inst_id = USERENV('Instance')
+++V$DATABASE_INCARNATION+++          select incarnation#, resetlogs_change#, resetlogs_time,         prior_resetlogs_change#, prior_resetlogs_time, status,         resetlogs_id, prior_incarnation#, flashback_database_allowed, con_id  from GV$DATABASE_INCARNATION  where inst_id = USERENV('Instance')
+++V$DATABASE_KEY_INFO+++             select ENCRYPTIONALG, ENCRYTPEDKEY,             MASTERKEYID, CON_ID from GV$DATABASE_KEY_INFO           where INST_ID = USERENV('Instance')
+++V$DATAFILE+++                      select  FILE# , CREATION_CHANGE# , CREATION_TIME , TS# , RFILE# , STATUS , ENABLED , CHECKPOINT_CHANGE# , CHECKPOINT_TIME, UNRECOVERABLE_CHANGE#, UNRECOVERABLE_TIME, LAST_CHANGE# , LAST_TIME , OFFLINE_CHANGE# , ONLINE_CHANGE# , ONLINE_TIME , BYTES , BLOCKS , CREATE_BYTES , BLOCK_SIZE , NAME, PLUGGED_IN, BLOCK1_OFFSET , AUX_NAME , FIRST_NONLOGGED_SCN, FIRST_NONLOGGED_TIME, FOREIGN_DBID, FOREIGN_CREATION_CHANGE#, FOREIGN_CREATION_TIME, PLUGGED_READONLY, PLUGIN_CHANGE#, PLUGIN_RESETLOGS_CHANGE#, PLUGIN_RESETLOGS_TIME, CON_ID from GV$DATAFILE where inst_id = USERENV('Instance')
+++V$DATAFILE_COPY+++                 select  RECID , STAMP , NAME , TAG , FILE# , RFILE# , CREATION_CHANGE# , CREATION_TIME , RESETLOGS_CHANGE# , RESETLOGS_TIME , INCREMENTAL_LEVEL, CHECKPOINT_CHANGE# , CHECKPOINT_TIME , ABSOLUTE_FUZZY_CHANGE# , RECOVERY_FUZZY_CHANGE# , RECOVERY_FUZZY_TIME , ONLINE_FUZZY , BACKUP_FUZZY , MARKED_CORRUPT , MEDIA_CORRUPT , LOGICALLY_CORRUPT , BLOCKS , BLOCK_SIZE , OLDEST_OFFLINE_RANGE, DELETED, STATUS, COMPLETION_TIME , CONTROLFILE_TYPE, KEEP, KEEP_UNTIL, KEEP_OPTIONS, SCANNED, IS_RECOVERY_DEST_FILE, RMAN_STATUS_RECID, RMAN_STATUS_STAMP, CONVERTED_FILE, SAME_ENDIAN, FOREIGN_DBID, PLUGGED_READONLY, PLUGIN_CHANGE#, PLUGIN_RESETLOGS_CHANGE#, PLUGIN_RESETLOGS_TIME, BACKED_BY_VSS, CON_ID, BACKED_BY_PDB from GV$DATAFILE_COPY where inst_id = USERENV('Instance')
+++V$DATAFILE_HEADER+++               select  FILE# , STATUS , ERROR , FORMAT, RECOVER , FUZZY, CREATION_CHANGE#, CREATION_TIME , TABLESPACE_NAME , TS# , RFILE# , RESETLOGS_CHANGE# , RESETLOGS_TIME , CHECKPOINT_CHANGE# , CHECKPOINT_TIME , CHECKPOINT_COUNT , BYTES , BLOCKS , NAME, SPACE_HEADER, LAST_DEALLOC_CHANGE#,  UNDO_OPT_CURRENT_CHANGE#, CON_ID from GV$DATAFILE_HEADER where inst_id = USERENV('Instance')
+++V$DATAGUARD_CONFIG+++              select DGCDBUN,         DGCPDBUN,         decode(DGCDROLE, 1, 'PRIMARY DATABASE',                          2, 'PHYSICAL STANDBY',                          3, 'SNAPSHOT STANDBY',                          4, 'FAR SYNC INSTANCE',                          5, 'LOGICAL STANDBY',                          6, 'BACKUP APPLIANCE',                             'UNKNOWN'),         to_number(DGCSCN),         CON_ID  from x$krstdgc
+++V$DATAGUARD_STATS+++               select SOURCE_DBID, SOURCE_DB_UNIQUE_NAME, NAME, VALUE, UNIT, TIME_COMPUTED, DATUM_TIME, CON_ID FROM GV$DATAGUARD_STATS where inst_id=USERENV('Instance')
+++V$DATAGUARD_STATUS+++              select FACILITY, SEVERITY, DEST_ID, MESSAGE_NUM, ERROR_CODE, CALLOUT, TIMESTAMP, MESSAGE, CON_ID  from GV$DATAGUARD_STATUS  where inst_id = USERENV('Instance')
+++V$DATAPUMP_JOB+++                  SELECT job_id, job_name, owner_name, msg_ctrl_queue,                 status_queue, operation, job_mode, master_id,                 state, workers, flags, serialnum, queue_tabnum, con_id          FROM   gv$datapump_job          WHERE  inst_id = USERENV('INSTANCE')
+++V$DATAPUMP_SESSION+++              SELECT attach_id, job_id, saddr, type, con_id          FROM   gv$datapump_session          WHERE  inst_id = USERENV('INSTANCE')
+++V$DBFILE+++                        select  FILE# , NAME, CON_ID from GV$DBFILE where inst_id = USERENV('Instance')
+++V$DBLINK+++                        select  DB_LINK , OWNER_ID , LOGGED_ON , HETEROGENEOUS , PROTOCOL , OPEN_CURSORS , IN_TRANSACTION , UPDATE_SENT , COMMIT_POINT_STRENGTH, CON_ID  from GV$DBLINK where inst_id = USERENV('Instance')
+++V$DB_CACHE_ADVICE+++               select id, name, block_size, advice_status,                  size_for_estimate, size_factor, buffers_for_estimate,        estd_physical_read_factor, estd_physical_reads,              estd_physical_read_time,                                     estd_pct_of_db_time_for_reads,                               estd_cluster_reads,                                          estd_cluster_read_time, con_id                               from   gv$db_cache_advice where inst_id = userenv('instance')
+++V$DB_OBJECT_CACHE+++               select  OWNER , NAME , DB_LINK , NAMESPACE , TYPE , SHARABLE_MEM , LOADS ,   EXECUTIONS , LOCKS , PINS , KEPT , CHILD_LATCH , INVALIDATIONS, HASH_VALUE,   LOCK_MODE, PIN_MODE, STATUS, TIMESTAMP, PREVIOUS_TIMESTAMP,                   LOCKED_TOTAL, PINNED_TOTAL, PROPERTY, FULL_HASH_VALUE, CON_ID, CON_NAME,      ADDR from GV$DB_OBJECT_CACHE where inst_id = USERENV('Instance')
+++V$DB_PIPES+++                      select  OWNERID , NAME , TYPE , PIPE_SIZE, CON_ID, CON_NAME from GV$DB_PIPES  where inst_id = USERENV('Instance')
+++V$DB_TRANSPORTABLE_PLATFORM+++     select PLATFORM_ID, PLATFORM_NAME,          decode(endian_format, 1,'Big' ,0,'Little','UNKNOWN FORMAT'), con_id          from x$kcpxpl          where endian_format =            (select endian_format from x$kcpxpl pl, x$kccdi di             where pl.platform_id = di.diplid)
+++V$DEAD_CLEANUP+++                  select type, paddr, saddr, state,         dead_time, cleanup_attempts,         last_attempt, cleanup_time,         num_blocked,         con_id    from gv$dead_cleanup   where inst_id = userenv('Instance')
+++V$DELETED_OBJECT+++                select  RECID, STAMP, TYPE, OBJECT_RECID, OBJECT_STAMP, OBJECT_DATA,  SET_STAMP, SET_COUNT, CON_ID from GV$DELETED_OBJECT where inst_id = USERENV('Instance')
+++V$DETACHED_SESSION+++              SELECT INDX, PG_NAME, SID, SERIAL#, PID, CON_ID    FROM gv$detached_session WHERE  INST_ID = USERENV('INSTANCE')
+++V$DG_BROKER_CONFIG+++              select DATABASE, CONNECT_IDENTIFIER, DATAGUARD_ROLE, REDO_SOURCE,         ENABLED, STATUS, VERSION, CON_ID from GV$DG_BROKER_CONFIG    where INST_ID = USERENV('Instance')
+++V$DIAG_CRITICAL_ERROR+++           SELECT facility, error, con_id          FROM X$DBKECE where excluded = 0 and facility != 'dbge'
+++V$DIAG_INFO+++                     SELECT inst_id, name, value, con_id FROM gv$diag_info          WHERE  inst_id = USERENV('INSTANCE')
+++V$DISPATCHER+++                    select  NAME , NETWORK , PADDR , STATUS , ACCEPT , MESSAGES , BYTES , BREAKS , OWNED , CREATED , IDLE , BUSY , LISTENER, CONF_INDX, CON_ID from GV$DISPATCHER where inst_id = USERENV('Instance')
+++V$DISPATCHER_CONFIG+++             select conf_indx, network, dispatchers, connections, sessions,  multiplex, listener, service, con_id from GV$DISPATCHER_CONFIG where inst_id = USERENV('Instance')
+++V$DISPATCHER_RATE+++               select  NAME, PADDR,CUR_LOOP_RATE,CUR_EVENT_RATE,CUR_EVENTS_PER_LOOP,CUR_MSG_RATE,CUR_SVR_BUF_RATE,CUR_SVR_BYTE_RATE,CUR_SVR_BYTE_PER_BUF,CUR_CLT_BUF_RATE,CUR_CLT_BYTE_RATE,CUR_CLT_BYTE_PER_BUF,CUR_BUF_RATE,CUR_BYTE_RATE,CUR_BYTE_PER_BUF,CUR_IN_CONNECT_RATE,CUR_OUT_CONNECT_RATE,CUR_RECONNECT_RATE,MAX_LOOP_RATE,MAX_EVENT_RATE,MAX_EVENTS_PER_LOOP,MAX_MSG_RATE,MAX_SVR_BUF_RATE,MAX_SVR_BYTE_RATE,MAX_SVR_BYTE_PER_BUF,MAX_CLT_BUF_RATE,MAX_CLT_BYTE_RATE,MAX_CLT_BYTE_PER_BUF,MAX_BUF_RATE,MAX_BYTE_RATE,MAX_BYTE_PER_BUF,MAX_IN_CONNECT_RATE,MAX_OUT_CONNECT_RATE,MAX_RECONNECT_RATE,AVG_LOOP_RATE,AVG_EVENT_RATE,AVG_EVENTS_PER_LOOP,AVG_MSG_RATE,AVG_SVR_BUF_RATE,AVG_SVR_BYTE_RATE,AVG_SVR_BYTE_PER_BUF,AVG_CLT_BUF_RATE,AVG_CLT_BYTE_RATE,AVG_CLT_BYTE_PER_BUF,AVG_BUF_RATE,AVG_BYTE_RATE,AVG_BYTE_PER_BUF,AVG_IN_CONNECT_RATE,AVG_OUT_CONNECT_RATE,AVG_RECONNECT_RATE,TTL_LOOPS,TTL_MSG,TTL_SVR_BUF,TTL_CLT_BUF,TTL_BUF,TTL_IN_CONNECT,TTL_OUT_CONNECT,TTL_RECONNECT,SCALE_LOOPS,SCALE_MSG,SCALE_SVR_BUF,SCALE_CLT_BUF,SCALE_BUF,SCALE_IN_CONNECT,SCALE_OUT_CONNECT,SCALE_RECONNECT, CON_ID from GV$DISPATCHER_RATE where inst_id = USERENV('Instance')
+++V$DLM_ALL_LOCKS+++                 select LOCKP, GRANT_LEVEL, REQUEST_LEVEL, RESOURCE_NAME1,          RESOURCE_NAME2, PID, TRANSACTION_ID0, TRANSACTION_ID1, GROUP_ID,          OPEN_OPT_DEADLOCK, OPEN_OPT_PERSISTENT, OPEN_OPT_PROCESS_OWNED,          OPEN_OPT_NO_XID, CONVERT_OPT_GETVALUE,          CONVERT_OPT_PUTVALUE, CONVERT_OPT_NOVALUE,          CONVERT_OPT_DUBVALUE, CONVERT_OPT_NOQUEUE,          CONVERT_OPT_EXPRESS, CONVERT_OPT_NODEADLOCKWAIT,          CONVERT_OPT_NODEADLOCKBLOCK, WHICH_QUEUE, LOCKSTATE,          AST_EVENT0, OWNER_NODE, BLOCKED, BLOCKER, CON_ID          from GV$DLM_ALL_LOCKS          where INST_ID = USERENV('Instance')
+++V$DLM_CONVERT_LOCAL+++             select INST_ID, CONVERT_TYPE, AVERAGE_CONVERT_TIME, CONVERT_COUNT, CON_ID from GV$DLM_CONVERT_LOCAL where INST_ID = USERENV('Instance')
+++V$DLM_CONVERT_REMOTE+++            select INST_ID, CONVERT_TYPE, AVERAGE_CONVERT_TIME, CONVERT_COUNT, CON_ID from GV$DLM_CONVERT_REMOTE where INST_ID = USERENV('Instance')
+++V$DLM_LATCH+++                     select addr, latch#, level#, name, gets, misses,  sleeps,immediate_gets, immediate_misses, waiters_woken,  waits_holding_latch, spin_gets, sleep1, sleep2, sleep3, sleep4,  sleep5, sleep6, sleep7, sleep8, sleep9, sleep10, sleep11,  wait_time, con_id  from GV$DLM_LATCH where INST_ID = USERENV('Instance')
+++V$DLM_LOCKS+++                     select LOCKP, GRANT_LEVEL, REQUEST_LEVEL, RESOURCE_NAME1,          RESOURCE_NAME2, PID, TRANSACTION_ID0, TRANSACTION_ID1, GROUP_ID,          OPEN_OPT_DEADLOCK, OPEN_OPT_PERSISTENT, OPEN_OPT_PROCESS_OWNED,          OPEN_OPT_NO_XID, CONVERT_OPT_GETVALUE,          CONVERT_OPT_PUTVALUE, CONVERT_OPT_NOVALUE,          CONVERT_OPT_DUBVALUE, CONVERT_OPT_NOQUEUE,          CONVERT_OPT_EXPRESS, CONVERT_OPT_NODEADLOCKWAIT,          CONVERT_OPT_NODEADLOCKBLOCK, WHICH_QUEUE, LOCKSTATE,          AST_EVENT0, OWNER_NODE, BLOCKED, BLOCKER, CON_ID          from GV$DLM_LOCKS          where INST_ID = USERENV('Instance')
+++V$DLM_MISC+++                      select STATISTIC#, NAME, VALUE, CON_ID FROM GV$DLM_MISC  where INST_ID = USERENV('Instance')
+++V$DLM_RESS+++                      select RESP, RESOURCE_NAME, ON_CONVERT_Q, ON_GRANT_Q,          PERSISTENT_RES, MASTER_NODE, NEXT_CVT_LEVEL,          VALUE_BLK_STATE, VALUE_BLK, CON_ID from GV$DLM_RESS          where INST_ID = USERENV('Instance')
+++V$DLM_TRAFFIC_CONTROLLER+++        select            LOCAL_NID,REMOTE_NID,REMOTE_RID,REMOTE_INC,            TCKT_AVAIL,TCKT_LIMIT,TCKT_RCVD,TCKT_WAIT,            SND_SEQ_NO,RCV_SEQ_NO,            SND_Q_LEN, SND_Q_MAX, SND_Q_TOT,            SND_Q_TM_BASE, SND_Q_TM_WRAP,            STATUS,SND_PROXY, CON_ID          from GV$DLM_TRAFFIC_CONTROLLER          where INST_ID = userenv('instance')
+++V$DNFS_CHANNELS+++                 select pnum, svrname, path, local, ch_id, svr_id, sends,          recvs, pings, spreco, dpreco, con_id, rdma, rdma_credits, clientport,          active_speed, peak_fmr, current_fmr, fmrreg_count          from gv$dnfs_channels where inst_id = USERENV('Instance')
+++V$DNFS_FILES+++                    select filename, filesize, pnum, svr_id, con_id          from gv$dnfs_files where inst_id = USERENV('Instance')
+++V$DNFS_SERVERS+++                  select id, svrname, dirname, mntport, nfsport, nfsversion, wtmax,          rtmax, con_id, rdmaenable, rdmaport from gv$dnfs_servers where inst_id = USERENV('Instance')
+++V$DNFS_STATS+++                    select pnum, nfs_null, nfs_getattr, nfs_setattr,          nfs_lookup, nfs_access, nfs_readlink, nfs_read, nfs_write,          nfs_create, nfs_mkdir, nfs_symlink, nfs_mknod, nfs_remove, nfs_rmdir,          nfs_rename, nfs_link, nfs_readdir, nfs_readdirplus,          nfs_fsstat, nfs_fsinfo, nfs_pathconf, nfs_commit, nfs_mount,          nfs_readbytes, nfs_writebytes, con_id          from gv$dnfs_stats where inst_id = USERENV('Instance')
+++V$DYNAMIC_REMASTER_STATS+++        select REMASTER_TYPE, REMASTER_OPS, REMASTER_TIME, REMASTERED_OBJECTS, QUIESCE_TIME,  FREEZE_TIME, CLEANUP_TIME, REPLAY_TIME, FIXWRITE_TIME, SYNC_TIME,  RESOURCES_CLEANED, REPLAYED_LOCKS_SENT, REPLAYED_LOCKS_RECEIVED,  CURRENT_OBJECTS, CON_ID FROM GV$DYNAMIC_REMASTER_STATS  where INST_ID = USERENV('Instance')
+++V$EDITIONABLE_TYPES+++             select editionable_type, type#, con_id from GV$EDITIONABLE_TYPES where inst_id = USERENV('Instance')
+++V$EMON+++                          SELECT          EMON#, SID, STARTUP_TIME ,SERVER_TYPE,         STATUS,STATUS_CHANGE_TIME,NUM_NTFNS,         NUM_GROUPING_NTFNS, NUM_NTFNS_ALL_GROUPS, NUM_OCI_NTFNS,         NUM_PLSQL_NTFNS, NUM_EMAIL_NTFNS,         NUM_HTTP_NTFNS, NUM_EVENTS_PROCESSED,         NUM_EVENTS_PENDING, NUM_ANONYMOUS_NTFNS ,         NUM_AQ_NTFNS, NUM_DBCHANGE_NTFNS,         TOTAL_ANONYMOUS_NTFN_TIME, TOTAL_AQ_NTFN_TIME,         TOTAL_DBCHANGE_NTFN_TIME, TOTAL_PLSQL_NTFN_TIME,         TOTAL_OCI_NTFN_TIME, TOTAL_EMAIL_NTFN_TIME,         TOTAL_HTTP_NTFN_TIME, TOTAL_EMON_LATENCY,         REGISTRATIONS_EXPIRED, REGISTRATIONS_PURGED,         REGISTRATIONS_INVALID,         LAST_UPDATE_TIME, CON_ID          FROM GV$EMON         WHERE INST_ID = USERENV('INSTANCE')
+++V$EMX_USAGE_STATS+++               select REPORT,        COUNT,        LOGIN_ELAPSED_TIME,        INITREQ_ELAPSED_TIME,        SQL_ELAPSED_TIME,        SEND_ELAPSED_TIME,        TOTAL_ELAPSED_TIME,        LAST_REQ_TIME,        CON_ID   from GV$EMX_USAGE_STATS  where inst_id=USERENV('Instance')
+++V$ENABLEDPRIVS+++                  select  PRIV_NUMBER, CON_ID from GV$ENABLEDPRIVS where inst_id = USERENV('Instance')
+++V$ENCRYPTED_TABLESPACES+++         select TS#, ENCRYPTIONALG, ENCRYPTEDTS,          ENCRYPTEDKEY, MASTERKEYID,                       BLOCKS_ENCRYPTED, BLOCKS_DECRYPTED, CON_ID          from GV$ENCRYPTED_TABLESPACES                     where INST_ID = USERENV('Instance')
+++V$ENCRYPTION_KEYS+++               SELECT KEY_ID, TAG, CREATION_TIME, ACTIVATION_TIME, CREATOR, CREATOR_ID, USER, USER_ID, KEY_USE, KEYSTORE_TYPE, ORIGIN, BACKED_UP, CREATOR_DBNAME, CREATOR_DBID, CREATOR_INSTANCE_NAME, CREATOR_INSTANCE_NUMBER, CREATOR_INSTANCE_SERIAL, CREATOR_PDBNAME, CREATOR_PDBID, CREATOR_PDBUID, CREATOR_PDBGUID, ACTIVATING_DBNAME, ACTIVATING_DBID, ACTIVATING_INSTANCE_NAME, ACTIVATING_INSTANCE_NUMBER, ACTIVATING_INSTANCE_SERIAL, ACTIVATING_PDBNAME, ACTIVATING_PDBID, ACTIVATING_PDBUID, ACTIVATING_PDBGUID, CON_ID FROM GV$ENCRYPTION_KEYS WHERE INST_ID = USERENV('Instance')
+++V$ENCRYPTION_WALLET+++             SELECT WRL_TYPE, WRL_PARAMETER, STATUS, WALLET_TYPE, WALLET_ORDER, FULLY_BACKED_UP, CON_ID FROM GV$ENCRYPTION_WALLET WHERE INST_ID = USERENV('Instance')
+++V$ENQUEUE_LOCK+++                  select  ADDR , KADDR , SID , TYPE , ID1 , ID2 , LMODE , REQUEST , CTIME , BLOCK, CON_ID from GV$ENQUEUE_LOCK where inst_id = USERENV('Instance')
+++V$ENQUEUE_STAT+++                  select INST_ID, EQ_TYPE, TOTAL_REQ#, TOTAL_WAIT#, SUCC_REQ#, FAILED_REQ#,    CUM_WAIT_TIME, CON_ID from GV$ENQUEUE_STAT    where INST_ID = USERENV('Instance')
+++V$ENQUEUE_STATISTICS+++            select EQ_NAME, EQ_TYPE, REQ_REASON,           TOTAL_REQ#, TOTAL_WAIT#, SUCC_REQ#, FAILED_REQ#, CUM_WAIT_TIME,           REQ_DESCRIPTION, EVENT#, CON_ID    from GV$ENQUEUE_STATISTICS    where INST_ID = USERENV('Instance')
+++V$EVENTMETRIC+++                   SELECT begin_time, end_time, intsize_csec,            event#, event_id, num_sess_waiting, time_waited, wait_count,            time_waited_fg, wait_count_fg, con_id          FROM gv$eventmetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$EVENT_HISTOGRAM+++               select event#, event, wait_time_milli, wait_count, last_update_time, con_id  from gv$event_histogram where inst_id = USERENV('Instance')
+++V$EVENT_HISTOGRAM_MICRO+++         select event#, event, wait_time_format, wait_time_micro, wait_count,  last_update_time, con_id from gv$event_histogram_micro where          inst_id = USERENV('Instance')
+++V$EVENT_NAME+++                    select event#, event_id, name, parameter1, parameter2, parameter3,  wait_class_id, wait_class#, wait_class, display_name, con_id        from gv$event_name                                                  where inst_id = USERENV('Instance')
+++V$EXECUTION+++                     select  PID , DEPTH , FUNCTION , TYPE , NVALS , VAL1 , VAL2 , SEQH , SEQL, CON_ID from GV$EXECUTION where inst_id = USERENV('Instance')
+++V$FALSE_PING+++                    SELECT p.file#, p.block#, p.status, p.xnc, p.forced_reads,         p.forced_writes, p.name, p.partition_name, p.kind,         p.owner#, p.lock_element_addr, p.lock_element_name,         p.class#, p.con_id  FROM   v$ping p, v$locks_with_collisions c  WHERE  (p.forced_reads + p.forced_writes) > 5         AND p.lock_element_addr = c.lock_element_addr
+++V$FAST_START_SERVERS+++            SELECT STATE, UNDOBLOCKSDONE, PID, XID, CON_ID from GV$FAST_START_SERVERS where inst_id = USERENV('Instance')
+++V$FAST_START_TRANSACTIONS+++       SELECT USN, SLT, SEQ, STATE, UNDOBLOCKSDONE, UNDOBLOCKSTOTAL, PID, CPUTIME, PARENTUSN, PARENTSLT, PARENTSEQ, XID, PXID, RCVSERVERS, CON_ID from GV$FAST_START_TRANSACTIONS where INST_ID = USERENV('Instance')
+++V$FILEMETRIC+++                    SELECT begin_time, end_time, intsize_csec,            file_id, creation_time, average_read_time,            average_write_time, physical_reads, physical_writes,            physical_block_reads, physical_block_writes, con_id          FROM gv$filemetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$FILEMETRIC_HISTORY+++            SELECT begin_time, end_time, intsize_csec,            file_id, creation_time, average_read_time,            average_write_time, physical_reads, physical_writes,            physical_block_reads, physical_block_writes, con_id          FROM gv$filemetric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$FILESPACE_USAGE+++               SELECT TABLESPACE_ID, RFNO, ALLOCATED_SPACE, FILE_SIZE,          FILE_MAXSIZE, CHANGESCN_BASE, CHANGESCN_WRAP, FLAG, CON_ID          FROM GV$FILESPACE_USAGE WHERE INST_ID = USERENV('INSTANCE')
+++V$FILESTAT+++                      select  FILE# , PHYRDS , PHYWRTS , PHYBLKRD , OPTIMIZED_PHYBLKRD ,  PHYBLKWRT , SINGLEBLKRDS,  READTIM , WRITETIM, SINGLEBLKRDTIM, AVGIOTIM, LSTIOTIM, MINIOTIM, MAXIORTM,  MAXIOWTM, CON_ID from GV$FILESTAT where inst_id = USERENV('Instance')
+++V$FILE_CACHE_TRANSFER+++           select  file_number,                                               x_2_null, x_2_null_forced_write, x_2_null_forced_stale,            x_2_s, x_2_s_forced_write,                                         s_2_null, s_2_null_forced_stale,                                   rbr, rbr_forced_write, rbr_forced_stale,                           null_2_x, s_2_x, null_2_s, cr_transfers, cur_transfers, con_id     from gv$file_cache_transfer                                        where inst_id = USERENV('Instance')
+++V$FILE_HISTOGRAM+++                select  FILE#, SINGLEBLKRDTIM_MILLI, SINGLEBLKRDS, CON_ID  from GV$FILE_HISTOGRAM where inst_id = USERENV('Instance')
+++V$FILE_OPTIMIZED_HISTOGRAM+++      select  FILE#, SINGLEBLKRDTIM_MICRO, SINGLEBLKRDS, CON_ID  from GV$FILE_OPTIMIZED_HISTOGRAM where inst_id = USERENV('Instance')
+++V$FILE_PING+++                     select  file_number, frequency,                                    x_2_null, x_2_null_forced_write, x_2_null_forced_stale,            x_2_s, x_2_s_forced_write, x_2_ssx, x_2_ssx_forced_write,          s_2_null, s_2_null_forced_stale, ss_2_null, ss_2_rls, wrb, wrb_forced_write, rbr, rbr_forced_write, rbr_forced_stale, cbr, cbr_forced_write,    null_2_x, s_2_x, ssx_2_x, null_2_s, null_2_ss, op_2_ss, con_id     from gv$file_ping                                                  where inst_id = USERENV('Instance')
+++V$FIXED_TABLE+++                   select  NAME , OBJECT_ID , TYPE , TABLE_NUM, CON_ID from GV$FIXED_TABLE where inst_id = USERENV('Instance')
+++V$FIXED_VIEW_DEFINITION+++         select  VIEW_NAME , VIEW_DEFINITION, CON_ID from GV$FIXED_VIEW_DEFINITION where inst_id = USERENV('Instance')
+++V$FLASHBACK_DATABASE_LOG+++        select  OLDEST_FLASHBACK_SCN, OLDEST_FLASHBACK_TIME, RETENTION_TARGET,                  FLASHBACK_SIZE, ESTIMATED_FLASHBACK_SIZE, CON_ID          from GV$FLASHBACK_DATABASE_LOG          where inst_id = USERENV('Instance')
+++V$FLASHBACK_DATABASE_LOGFILE+++    select  NAME, LOG#, THREAD#, SEQUENCE#, BYTES,                  FIRST_CHANGE#, FIRST_TIME, TYPE, CON_ID          from GV$FLASHBACK_DATABASE_LOGFILE          where inst_id = USERENV('Instance')
+++V$FLASHBACK_DATABASE_STAT+++       select BEGIN_TIME, END_TIME, FLASHBACK_DATA, DB_DATA, REDO_DATA,  ESTIMATED_FLASHBACK_SIZE, CON_ID  from GV$FLASHBACK_DATABASE_STAT  where inst_id = USERENV('Instance')
+++V$FLASHBACK_TXN_GRAPH+++           select  COMPENSATING_XID,        COMPENSATING_TXN_NAME,        XID,        TXN_NAME,        PARENT_XID,        INTERESTING,        ORIGINAL,        BACKOUT_SEQ,        NUM_PREDS,        NUM_SUCCS,        DEP_XID,        DEP_TXN_NAME,        TXN_CONF_SQL_ID,        DEP_TXN_CONF_SQL_ID,        CONFLICT_TYPE,        CON_ID         from X$KTFTBTXNGRAPH
+++V$FLASHBACK_TXN_MODS+++            select COMPENSATING_XID,       COMPENSATING_TXN_NAME,       XID,       TXN_NAME,       PARENT_XID,       INTERESTING,       ORIGINAL,       BACKOUT_SEQ,       UNDO_SQL,       UNDO_SQL_SQN,       UNDO_SQL_SUB_SQN,       BACKOUT_SQL_ID,       OPERATION,       BACKEDOUT,       CONFLICT_MOD,       MODS_PER_LCR,       CON_ID        from X$KTFTBTXNMODS
+++V$FLASHFILESTAT+++                 select FLASHFILE#, NAME, BYTES, ENABLED, SINGLEBLKRDS, SINGLEBLKRDTIM_MICRO,  CON_ID from GV$FLASHFILESTAT where inst_id = USERENV('Instance')
+++V$FLASH_RECOVERY_AREA_USAGE+++     select file_type, percent_space_used,         percent_space_reclaimable, number_of_files, con_id    from v$recovery_area_usage
+++V$FOREIGN_ARCHIVED_LOG+++          select  RECID , STAMP , NAME , DEST_ID , THREAD# , SEQUENCE# ,  RESETLOGS_CHANGE# , RESETLOGS_TIME , RESETLOGS_ID ,  FIRST_CHANGE# , FIRST_TIME ,  NEXT_CHANGE# , NEXT_TIME , BLOCKS , BLOCK_SIZE , CREATOR, REGISTRAR ,  ARCHIVED , APPLIED , DELETED , STATUS , COMPLETION_TIME ,  DICTIONARY_BEGIN , DICTIONARY_END , END_OF_REDO,  ARCHIVAL_THREAD#, IS_RECOVERY_DEST_FILE, COMPRESSED, FAL,  END_OF_REDO_TYPE, SOURCE_DBID, CON_ID from GV$FOREIGN_ARCHIVED_LOG where inst_id = USERENV('Instance')
+++V$FS_FAILOVER_HISTOGRAM+++         select REDO_LATENCY,FREQUENCY,LAST_TIME, CON_ID from GV$FS_FAILOVER_HISTOGRAM where inst_id=USERENV('Instance')
+++V$FS_FAILOVER_STATS+++             select LAST_FAILOVER_TIME, LAST_FAILOVER_REASON, CON_ID from GV$FS_FAILOVER_STATS where inst_id=USERENV('Instance')
+++V$FS_OBSERVER_HISTOGRAM+++         select WAIT_TIME,WAIT_COUNT,LAST_UPDATE_TIME, CON_ID from GV$FS_OBSERVER_HISTOGRAM where inst_id=USERENV('Instance')
+++V$GCSHVMASTER_INFO+++              select HV_ID, CURRENT_MASTER, PREVIOUS_MASTER, REMASTER_CNT, CON_ID  from GV$GCSHVMASTER_INFO  where inst_id = USERENV('Instance')
+++V$GCSPFMASTER_INFO+++              select FILE_ID, DATA_OBJECT_ID, GC_MASTERING_POLICY,  CURRENT_MASTER, PREVIOUS_MASTER, REMASTER_CNT, CON_ID  from GV$GCSPFMASTER_INFO  where inst_id = USERENV('Instance')
+++V$GC_ELEMENT+++                    select gc_element_addr, indx, class, gc_element_name,          mode_held, block_count, releasing, acquiring,                  writing, recovering, local, flags, con_id                      from gv$gc_element where inst_id = USERENV('Instance')
+++V$GC_ELEMENTS_WITH_COLLISIONS+++   select gc_element_addr, con_id from gv$gc_elements_with_collisions          where inst_id = USERENV('Instance')
+++V$GES_BLOCKING_ENQUEUE+++          select HANDLE, GRANT_LEVEL, REQUEST_LEVEL, RESOURCE_NAME1,          RESOURCE_NAME2, PID, TRANSACTION_ID0, TRANSACTION_ID1, GROUP_ID,          OPEN_OPT_DEADLOCK, OPEN_OPT_PERSISTENT, OPEN_OPT_PROCESS_OWNED,          OPEN_OPT_NO_XID, CONVERT_OPT_GETVALUE,          CONVERT_OPT_PUTVALUE, CONVERT_OPT_NOVALUE,          CONVERT_OPT_DUBVALUE, CONVERT_OPT_NOQUEUE,          CONVERT_OPT_EXPRESS, CONVERT_OPT_NODEADLOCKWAIT,          CONVERT_OPT_NODEADLOCKBLOCK, WHICH_QUEUE, STATE,          AST_EVENT0, OWNER_NODE, BLOCKED, BLOCKER, CON_ID          from GV$GES_BLOCKING_ENQUEUE          where INST_ID = USERENV('Instance')
+++V$GES_DEADLOCKS+++                 select did, dd_time, number_of_sessions,          master_instance, victim_instance, victim_pid, victim_resnm,         victim_sid, victim_serial#, victim_req_level, con_id          from GV$GES_DEADLOCKS WHERE  INST_ID = USERENV('Instance')
+++V$GES_DEADLOCK_SESSIONS+++         select did, sid, serial#, instance, blocker_sid, blocker_serial#,         blocker_instance, osuser, app_name, blocked_res_name, request_level,          blocker_res_name, grant_level, con_id          from GV$GES_DEADLOCK_SESSIONS WHERE  INST_ID = USERENV('Instance')
+++V$GES_ENQUEUE+++                   select HANDLE, GRANT_LEVEL, REQUEST_LEVEL, RESOURCE_NAME1,          RESOURCE_NAME2, PID, TRANSACTION_ID0, TRANSACTION_ID1, GROUP_ID,          OPEN_OPT_DEADLOCK, OPEN_OPT_PERSISTENT, OPEN_OPT_PROCESS_OWNED,          OPEN_OPT_NO_XID, CONVERT_OPT_GETVALUE,          CONVERT_OPT_PUTVALUE, CONVERT_OPT_NOVALUE,          CONVERT_OPT_DUBVALUE, CONVERT_OPT_NOQUEUE,          CONVERT_OPT_EXPRESS, CONVERT_OPT_NODEADLOCKWAIT,          CONVERT_OPT_NODEADLOCKBLOCK, WHICH_QUEUE, STATE,          AST_EVENT0, OWNER_NODE, BLOCKED, BLOCKER, CON_ID          from GV$GES_ENQUEUE          where INST_ID = USERENV('Instance')
+++V$GG_APPLY_COORDINATOR+++          SELECT SID, SERIAL#, STATE, APPLY#, APPLY_NAME, TOTAL_APPLIED,TOTAL_WAIT_DEPS,TOTAL_WAIT_COMMITS, TOTAL_ADMIN, TOTAL_ASSIGNED, TOTAL_RECEIVED,TOTAL_IGNORED, TOTAL_ROLLBACKS, TOTAL_ERRORS, UNASSIGNED_COMPLETE_TXNS,LWM_TIME, LWM_MESSAGE_NUMBER, LWM_MESSAGE_CREATE_TIME,HWM_TIME, HWM_MESSAGE_NUMBER, HWM_MESSAGE_CREATE_TIME,STARTUP_TIME, ELAPSED_SCHEDULE_TIME, ELAPSED_IDLE_TIME,LWM_POSITION, HWM_POSITION, PROCESSED_MESSAGE_NUMBER, CON_ID, ACTIVE_SERVER_COUNT from GV$GG_APPLY_COORDINATOR WHERE INST_ID = USERENV('Instance')
+++V$GG_APPLY_READER+++               select SID, SERIAL#, APPLY#, APPLY_NAME, STATE, TOTAL_MESSAGES_DEQUEUED, TOTAL_MESSAGES_SPILLED, DEQUEUE_TIME,  DEQUEUED_MESSAGE_CREATE_TIME, SGA_USED, ELAPSED_DEQUEUE_TIME,  ELAPSED_SCHEDULE_TIME, ELAPSED_SPILL_TIME,  SPILL_LWM_SCN, PROXY_SID, PROXY_SERIAL, PROXY_SPID, BYTES_RECEIVED,  DEQUEUED_POSITION, SPILL_LWM_POSITION, OLDEST_TRANSACTION_ID,  TOTAL_LCRS_WITH_DEP, TOTAL_LCRS_WITH_WMDEP, TOTAL_IN_MEMORY_LCRS,  SGA_ALLOCATED, CON_ID from GV$GG_APPLY_READER where INST_ID = USERENV('Instance')
+++V$GG_APPLY_RECEIVER+++             select SID, SERIAL#, APPLY_NAME, STARTUP_TIME,                SOURCE_DATABASE_NAME, ACKNOWLEDGEMENT,LAST_RECEIVED_MSG,                TOTAL_MESSAGES_RECEIVED, TOTAL_AVAILABLE_MESSAGES,                STATE, LAST_RECEIVED_MSG_POSITION, ACKNOWLEDGEMENT_POSITION,                CON_ID          from   GV$GG_APPLY_RECEIVER          where  INST_ID = USERENV('Instance')
+++V$GG_APPLY_SERVER+++               select SID, SERIAL#, APPLY#, APPLY_NAME,SERVER_ID, STATE, XIDUSN, XIDSLT, XIDSQN, COMMITSCN,DEP_XIDUSN, DEP_XIDSLT, DEP_XIDSQN, DEP_COMMITSCN, MESSAGE_SEQUENCE,TOTAL_ASSIGNED, TOTAL_ADMIN, TOTAL_ROLLBACKS,TOTAL_MESSAGES_APPLIED, APPLY_TIME, ELAPSED_APPLY_TIME, COMMIT_POSITION, DEP_COMMIT_POSITION, LAST_APPLY_POSITION, TRANSACTION_ID, DEP_TRANSACTION_ID, CON_ID, TOTAL_LCRS_RETRIED, LCR_RETRY_ITERATION, TOTAL_TXNS_RETRIED, TXN_RETRY_ITERATION, TOTAL_TXNS_RECORDED  from GV$GG_APPLY_SERVER where INST_ID = USERENV('Instance')
+++V$GLOBALCONTEXT+++                 select namespace, attribute, value,           username,clientidentifier, con_id           from gv$globalcontext
+++V$GLOBAL_BLOCKED_LOCKS+++          select  ADDR , KADDR , SID , TYPE , ID1 , ID2 , LMODE , REQUEST , CTIME, CON_ID from gv$global_blocked_locks where inst_id = userenv('instance')
+++V$GLOBAL_TRANSACTION+++             select FORMATID, GLOBALID, BRANCHID, BRANCHES, REFCOUNT, PREPARECOUNT,    STATE, FLAGS, COUPLING, CON_ID                                            from GV$GLOBAL_TRANSACTION                                                where INST_ID = USERENV('Instance')
+++V$GOLDENGATE_CAPABILITIES+++       select name, count, last_used, con_id from GV$GOLDENGATE_CAPABILITIES  where inst_id = USERENV('Instance')
+++V$GOLDENGATE_CAPTURE+++            select SID, SERIAL#, CAPTURE#, CAPTURE_NAME, LOGMINER_ID,        STARTUP_TIME, STATE, TOTAL_PREFILTER_DISCARDED, TOTAL_PREFILTER_KEPT,        TOTAL_PREFILTER_EVALUATIONS,TOTAL_MESSAGES_CAPTURED, CAPTURE_TIME,        CAPTURE_MESSAGE_NUMBER, CAPTURE_MESSAGE_CREATE_TIME,        TOTAL_MESSAGES_CREATED, TOTAL_FULL_EVALUATIONS,        TOTAL_MESSAGES_ENQUEUED, ENQUEUE_TIME, ENQUEUE_MESSAGE_NUMBER,        ENQUEUE_MESSAGE_CREATE_TIME, AVAILABLE_MESSAGE_NUMBER,        AVAILABLE_MESSAGE_CREATE_TIME, ELAPSED_CAPTURE_TIME,        ELAPSED_RULE_TIME,ELAPSED_ENQUEUE_TIME,        ELAPSED_LCR_TIME, ELAPSED_REDO_WAIT_TIME, ELAPSED_PAUSE_TIME,         STATE_CHANGED_TIME,         SGA_USED, SGA_ALLOCATED, BYTES_OF_REDO_MINED,         SESSION_RESTART_SCN, CON_ID,         SPID, EXTRACT_NAME, SERVER_SID, SERVER_SERIAL#, SERVER_SPID,         TOTAL_MESSAGES_SENT, SEND_TIME, LAST_SENT_MESSAGE_NUMBER,         LAST_SENT_MESSAGE_CREATE_TIME, ELAPSED_SEND_TIME, BYTES_SENT  from   GV$GOLDENGATE_CAPTURE  where  INST_ID = USERENV('Instance')
+++V$GOLDENGATE_MESSAGE_TRACKING+++   select TRACKING_LABEL, TAG, COMPONENT_NAME, COMPONENT_TYPE,         ACTION, ACTION_DETAILS, TIMESTAMP, MESSAGE_CREATION_TIME,                     MESSAGE_NUMBER, TRACKING_ID,                SOURCE_DATABASE_NAME, OBJECT_OWNER, OBJECT_NAME,         XID, COMMAND_TYPE, MESSAGE_POSITION, CON_ID                    from   GV$GOLDENGATE_MESSAGE_TRACKING          where  INST_ID = USERENV('Instance')
+++V$GOLDENGATE_TABLE_STATS+++        select APPLY_NAME, SERVER_ID, SOURCE_TABLE_OWNER, SOURCE_TABLE_NAME,                DESTINATION_TABLE_OWNER, DESTINATION_TABLE_NAME,                 LAST_UPDATE, TOTAL_INSERTS, TOTAL_UPDATES, TOTAL_DELETES,                INSERT_COLLISIONS, UPDATE_COLLISIONS, DELETE_COLLISIONS,                REPERROR_RECORDS, REPERROR_IGNORES, WAIT_DEPENDENCIES, CON_ID,                CDR_INSERT_ROW_EXISTS, CDR_UPDATE_ROW_EXISTS,                 CDR_UPDATE_ROW_MISSING, CDR_DELETE_ROW_EXISTS,                 CDR_DELETE_ROW_MISSING,                 CDR_SUCCESSFUL_RESOLUTIONS, CDR_FAILED_RESOLUTIONS,                 LOB_OPERATIONS          from   GV$GOLDENGATE_TABLE_STATS          where  INST_ID = USERENV('Instance')
+++V$GOLDENGATE_TRANSACTION+++        select COMPONENT_NAME, COMPONENT_TYPE, XIDUSN, XIDSLT, XIDSQN,                 BATCH_XIDUSN, BATCH_XIDSLT, BATCH_XIDSQN,                 CUMULATIVE_MESSAGE_COUNT, TOTAL_MESSAGE_COUNT,                 FIRST_MESSAGE_TIME, FIRST_MESSAGE_NUMBER,                LAST_MESSAGE_TIME, LAST_MESSAGE_NUMBER,                 FIRST_MESSAGE_POSITION, LAST_MESSAGE_POSITION,                 TRANSACTION_ID, CON_ID                               from   GV$GOLDENGATE_TRANSACTION          where  INST_ID = USERENV('Instance')
+++V$HANG_INFO+++                     SELECT a.hid, a.numsess, a.ttlnumsess,  decode(a.hngtyp, 1, 'Hang',                   2, 'Uninteresting Hang',                   3, 'Deadlock'),  to_char(a.hngcretm, 'DD-Mon-YYYY HH24:MI:SS'),  decode(a.hngsts, 5, to_char(a.hngreltm, 'HH24:MI:SS'),                   7, to_char(a.hngreltm, 'HH24:MI:SS'),                  10, to_char(a.hngreltm, 'HH24:MI:SS'),  to_char(a.hngrestm, 'DD-Mon-YYYY HH24:MI:SS')),  decode(bitand(a.hngrssts,8054112231), 0, 'N', 'Y'),  decode(bitand(a.hngopst,1), 0, 'N', 'Y'),  decode(bitand(a.hngopst,2), 0, 'N', 'Y'),  decode(bitand(a.hngopst,8), 0, 'N', 'Y'),  c.kjznrslnrcrsn,  a.vcinstnum,  a.vcsid,  a.vcsno,  a.vcospid,  decode(bitand(a.vctyp,2), 0, 'N', 'Y'),  a.vcprcnm,  decode(a.vcwtevt, 4294967295, 'not in a wait', b.kslednam),  d.kjznwlmpcrankdesc,  a.vcpcitt, a.vcpcrtt, a.vcpckey,  a.con_id  FROM x$kjznhangs a, x$ksled b, x$kjznrslnrc c, x$kjznwlmpcrank d  WHERE a.vcwtevt = b.indx (+)    AND a.hngsts = c.kjznrslnrchngsts    AND bitand(a.hngrssts, c.kjznrslnrcrbc) != 0    AND a.hngspstyp = c.kjznrslnrcspsbtyp    AND a.vcpcrank = d.kjznwlmpcrankval
+++V$HANG_SESSION_INFO+++             SELECT a.hid, a.inst, a.sid, a.sno,  a.ospid,  decode(bitand(a.flgs,2), 0, 'N', 'Y'),  decode(bitand(a.flgs,4), 0, 'N', 'Y'),  a.prcnm,  decode(a.wtevt, 4294967295, 'not in a wait', b.kslednam),  e.kjznwlmpcrankdesc,  a.pcitt, a.pcrtt, a.pckey, a.con_id  FROM x$kjznhangses a, x$ksled b, x$kjznhangs c, x$kjznrslnrc d,       x$kjznwlmpcrank e  WHERE a.wtevt = b.indx (+)  AND a.hid = c.hid  AND c.hngsts = d.kjznrslnrchngsts  AND bitand(c.hngrssts, d.kjznrslnrcrbc) != 0  AND c.hngspstyp = d.kjznrslnrcspsbtyp  AND a.pcrank = e.kjznwlmpcrankval  ORDER BY a.hid ASC, a.indx ASC
+++V$HANG_STATISTICS+++               select STATISTIC#, NAME, VALUE, CON_ID FROM GV$HANG_STATISTICS  where INST_ID = USERENV('Instance')
+++V$HEAT_MAP_SEGMENT+++              select OBJECT_NAME, SUBOBJECT_NAME, OBJ#, DATAOBJ#,          TS#, TRACK_TIME,          SEGMENT_WRITE, SEGMENT_READ, FULL_SCAN, LOOKUP_SCAN, CON_ID          from GV$HEAT_MAP_SEGMENT          where INST_ID = USERENV('Instance')
+++V$HM_CHECK+++                      select ID,       NAME,       NAME_NLS,       CLSID,       CLS_NAME,       FLAGS,       INTERNAL_CHECK,       OFFLINE_CAPABLE,       DESCRIPTION,        CON_ID from  GV$HM_CHECK where inst_id=USERENV('Instance')
+++V$HM_CHECK_PARAM+++                select ID,       NAME,       CHECK_ID,       TYPE,        DEFAULT_VALUE,       FLAGS,       DESCRIPTION,        CON_ID from   GV$HM_CHECK_PARAM where inst_id=USERENV('Instance')
+++V$HM_FINDING+++                    select FINDING_ID,       RUN_ID,       NAME,       PARENT_ID,       CHILD_COUNT,       CLASS_NAME,       TIME_DETECTED,       MODIFIED,       PRIORITY,       STATUS,       TYPE,       DESCRIPTION,        DAMAGE_DESCRIPTION,        CON_ID from GV$HM_FINDING where inst_id=USERENV('Instance')
+++V$HM_INFO+++                       select ID,       TYPE,        NAME,       VALUE,        CON_ID from GV$HM_INFO where inst_id=USERENV('Instance')
+++V$HM_RECOMMENDATION+++             select RECOMMENDATION_ID,       FDG_ID,       RUN_ID,       NAME,       TYPE,        RANK,       TIME_DETECTED,       EXECUTED,       STATUS,        DESCRIPTION,        REPAIR_SCRIPT,        CON_ID from GV$HM_RECOMMENDATION where inst_id=USERENV('Instance')
+++V$HM_RUN+++                        select RUN_ID,       NAME,       CHECK_NAME,       RUN_MODE,       TIMEOUT,       START_TIME,       LAST_RESUME_TIME,       END_TIME,       MODIFIED_TIME,       STATUS,        SRC_INCIDENT,         NUM_INCIDENT,         ERROR_NUMBER,         PROBLEM_ID,         CON_ID from GV$HM_RUN where inst_id=USERENV('Instance')
+++V$HS_AGENT+++                      select unique AGENT_ID, MACHINE, PROCESS, PROGRAM,          OSUSER, STARTTIME, AGENT_TYPE, FDS_CLASS_ID, FDS_INST_ID, CON_ID          from GV$HS_AGENT where INST_ID = USERENV('Instance')
+++V$HS_PARAMETER+++                  select HS_SESSION_ID, PARAMETER, VALUE,  SOURCE, ENV, CON_ID          from GV$HS_PARAMETER WHERE INST_ID = userenv('instance')
+++V$HS_SESSION+++                    select          HS_SESSION_ID, AGENT_ID, SID, DB_LINK, DB_LINK_OWNER,          STARTTIME, CON_ID          from GV$HS_SESSION where INST_ID = USERENV('Instance')
+++V$HVMASTER_INFO+++                 select HV_ID, CURRENT_MASTER, PREVIOUS_MASTER, REMASTER_CNT, CON_ID from  GV$HVMASTER_INFO where inst_id = USERENV('Instance')
+++V$IM_COLUMN_LEVEL+++               select INST_ID, OWNER, OBJ_NUM, TABLE_NAME, SEGMENT_COLUMN_ID,          COLUMN_NAME, INMEMORY_COMPRESSION, CON_ID from gv$im_column_level
+++V$IM_COL_CU+++                     select  OBJD, TSN, HEAD_PIECE_ADDRESS, COLUMN_NUMBER, LENGTH,         ROW_LEN, TRANSFORMED_LEN, COMPRESSION_NUMBER, DICTIONARY_ENTRIES,          MINIMUM_VALUE, MAXIMUM_VALUE, CON_ID from gv$im_col_cu          where INST_ID= userenv('instance')
+++V$IM_HEADER+++                     select  OBJD, TSN, IMCU_ADDR, ALLOCATED_LEN, USED_LEN,          IS_HEAD_PIECE, PREPOPULATED, REPOPULATED, TRICKLE_REPOPULATED,          ADDITIONAL_IMCU_PIECES, HEAD_PIECE_ADDRESS,          NEXT_PIECE_ADDRESS, COMPRESSION_LEVEL, NUM_DISK_EXTENTS,          NUM_TARGET_ROWS, NUM_TARGET_BLOCKS, HEADER_SIZE,          NUM_COLS, NUM_ROWS, NUM_BLOCKS, CON_ID, TIME_TO_POPULATE, TIMESTAMP          from gv$im_header          where INST_ID= userenv('instance')
+++V$IM_SEGMENTS+++                   select owner, segment_name, partition_name, segment_type,          tablespace_name, inmemory_size, bytes, bytes_not_populated,          populate_status, inmemory_priority, inmemory_distribute,          inmemory_duplicate, inmemory_compression, con_id          from gv$im_segments          where INST_ID = userenv('instance')
+++V$IM_SEGMENTS_DETAIL+++            select TSN, RELFILE, BLOCK_ID, DATAOBJ, OBJ, BASEOBJ, INC, SPARE_ID,          SEGTYPE, DISTDIM, MEMADDR, MEMEXTENTS, MEMBYTES,          EXTENTS, BLOCKS,DATABLOCKS,          BLOCKSINMEM, BYTES, CREATETIME, STATUS, POPULATE_STATUS, CON_ID          from gv$im_segments_detail where INST_ID = userenv('instance')
+++V$IM_SEG_EXT_MAP+++                select EXT_ADDR, EXT_LEN, START_DBA, SLEN, NUMA_ID,          FREENESS, TYPE,          STRP_CTRL_ID, STRP_BLK_ID, POOL_ID, CON_ID          from gv$im_seg_ext_map where INST_ID = userenv('instance')
+++V$IM_SMU_CHUNK+++                  select TSN, OBJD, OBJN,          STARTDBA, CHUNK_ID, CHUNK_ADDRESS, ULE_COUNT,          FIRST_LOG_UPDATE_ENTRY, FIRST_UPDATE_LOG_SCN,          CON_ID from gv$im_smu_chunk where INST_ID= userenv('instance')
+++V$IM_SMU_HEAD+++                   select TSN, OBJD, OBJN,          STARTDBA, EXTENT_CNT, BLOCK_CNT, LOAD_SCN,          ITL_CNT, FIRST_LOG_UPDATE_ENTRY, TOTAL_ROWS,          INVALID_ROWS, INVALID_BLOCKS, CHUNKS,          CON_ID from gv$im_smu_head where INST_ID= userenv('instance')
+++V$IM_TBS_EXT_MAP+++                select START_DBA, END_DBA, DATAOBJ, IMCU_ADDR, LEN,          SMU_ADDR, CON_ID          from gv$im_tbs_ext_map where INST_ID = userenv('instance')
+++V$IM_USER_SEGMENTS+++              select segment_name, partition_name, segment_type,          tablespace_name, inmemory_size, bytes, bytes_not_populated,          populate_status, inmemory_priority, inmemory_distribute,          inmemory_duplicate, inmemory_compression, con_id          from gv$im_user_segments          where INST_ID = userenv('instance')
+++V$INCMETER_CONFIG+++               select TRANSIENT_INCIDENT_LIFETIME,       CRITICAL_FACTOR,        WARNING_FACTOR,       WEIGHT_FACTOR,        MODIFICATION_TIME,        CON_ID from GV$INCMETER_CONFIG where inst_id=USERENV('Instance')
+++V$INCMETER_INFO+++                 select INCIDENT_ID,       CREATE_TIME,        IS_DISABLED,        IS_ACTIVE,        IMPT_NATURE,        IMPACT1,       IMPACT2,        IMPACT3,        IMPACT4,        CON_ID from GV$INCMETER_INFO where inst_id=USERENV('Instance')
+++V$INCMETER_SUMMARY+++              select SEVERITY_INDEX,       CRITICAL_INICDENTS,        WARNING_INCIDENTS,       LAST_HOUR_INCIDENTS,        CREATE_TIME,        OLDEST_TRANSIENT_INC_CTIME,        OLDEST_PERSISTENT_INC_CTIME,        LATEST_INC_CTIME,        CON_ID from GV$INCMETER_SUMMARY where inst_id=USERENV('Instance')
+++V$INDEXED_FIXED_COLUMN+++          select  TABLE_NAME , INDEX_NUMBER , COLUMN_NAME , COLUMN_POSITION, CON_ID from GV$INDEXED_FIXED_COLUMN where inst_id = USERENV('Instance')
+++V$INMEMORY_AREA+++                 select POOL, ALLOC_BYTES, USED_BYTES, POPULATE_STATUS, CON_ID          from gv$inmemory_area where INST_ID= userenv('instance')
+++V$INSTANCE+++                      select  INSTANCE_NUMBER , INSTANCE_NAME , HOST_NAME , VERSION , STARTUP_TIME , STATUS , PARALLEL , THREAD# , ARCHIVER , LOG_SWITCH_WAIT , LOGINS , SHUTDOWN_PENDING, DATABASE_STATUS, INSTANCE_ROLE, ACTIVE_STATE, BLOCKED, CON_ID, INSTANCE_MODE, EDITION, FAMILY from GV$INSTANCE where inst_id = USERENV('Instance')
+++V$INSTANCE_CACHE_TRANSFER+++       select instance, class,  lost, lost_time,  cr_block, cr_block_time,  cr_2hop, cr_2hop_time, cr_3hop, cr_3hop_time,  cr_busy, cr_busy_time, cr_congested, cr_congested_time,  current_block, current_block_time,  current_2hop, current_2hop_time, current_3hop, current_3hop_time,  current_busy, current_busy_time, current_congested, current_congested_time, con_id   from gv$instance_cache_transfer  where inst_id = USERENV('Instance')
+++V$INSTANCE_LOG_GROUP+++            select  THREAD# , STATUS , ENABLED , GROUPS , INSTANCE , OPEN_TIME , CURRENT_GROUP# , SEQUENCE# , CHECKPOINT_CHANGE# , CHECKPOINT_TIME , ENABLE_CHANGE# , ENABLE_TIME , DISABLE_CHANGE# , DISABLE_TIME, CON_ID from GV$INSTANCE_LOG_GROUP where inst_id = USERENV('Instance')
+++V$INSTANCE_PING+++                 SELECT instance,  CURRENT_500B, AVERAGE_500B, MAX_500B, COUNT_500B, WAIT_TIME_500B,  WAIT_TIME_SQUARED_500B,  CURRENT_8K, AVERAGE_8K, MAX_8K, COUNT_8K, WAIT_TIME_8K,  WAIT_TIME_SQUARED_8K, CON_ID  FROM GV$INSTANCE_PING  WHERE INST_ID = USERENV('Instance')
+++V$INSTANCE_RECOVERY+++             select         RECOVERY_ESTIMATED_IOS, ACTUAL_REDO_BLKS, TARGET_REDO_BLKS,         LOG_FILE_SIZE_REDO_BLKS, LOG_CHKPT_TIMEOUT_REDO_BLKS,         LOG_CHKPT_INTERVAL_REDO_BLKS, FAST_START_IO_TARGET_REDO_BLKS,         TARGET_MTTR, ESTIMATED_MTTR, CKPT_BLOCK_WRITES,         OPTIMAL_LOGFILE_SIZE, ESTD_CLUSTER_AVAILABLE_TIME,         WRITES_MTTR, WRITES_LOGFILE_SIZE, WRITES_LOG_CHECKPOINT_SETTINGS,         WRITES_OTHER_SETTINGS, WRITES_AUTOTUNE, WRITES_FULL_THREAD_CKPT,         CON_ID from GV$INSTANCE_RECOVERY where INST_ID = USERENV('Instance')
+++V$IOFUNCMETRIC+++                  SELECT begin_time, end_time, intsize_csec,                 function_id, function_name,                 small_read_mbps, small_write_mbps,                 large_read_mbps, large_write_mbps,                 small_read_iops, small_write_iops,                 large_read_iops, large_write_iops,                 avg_wait_time, con_id          FROM   gv$iofuncmetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$IOFUNCMETRIC_HISTORY+++          SELECT begin_time, end_time, intsize_csec,                 function_id, function_name,                 small_read_mbps, small_write_mbps,                 large_read_mbps, large_write_mbps,                 small_read_iops, small_write_iops,                 large_read_iops, large_write_iops,                 avg_wait_time, con_id          FROM   gv$iofuncmetric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$IOSTAT_CONSUMER_GROUP+++         SELECT CONSUMER_GROUP_ID, SMALL_READ_MEGABYTES,                               SMALL_WRITE_MEGABYTES, LARGE_READ_MEGABYTES,                                  LARGE_WRITE_MEGABYTES, SMALL_READ_REQS,                                       SMALL_WRITE_REQS, LARGE_READ_REQS,                                            LARGE_WRITE_REQS, NUMBER_OF_WAITS, WAIT_TIME, CON_ID                          FROM GV$IOSTAT_CONSUMER_GROUP where inst_id=USERENV('Instance')
+++V$IOSTAT_FILE+++                   SELECT FILE_NO, FILETYPE_ID, FILETYPE_NAME,                        SMALL_READ_MEGABYTES, SMALL_WRITE_MEGABYTES,                       LARGE_READ_MEGABYTES, LARGE_WRITE_MEGABYTES,                       SMALL_READ_REQS, SMALL_WRITE_REQS,                                 SMALL_SYNC_READ_REQS, LARGE_READ_REQS,                             LARGE_WRITE_REQS, SMALL_READ_SERVICETIME,                          SMALL_WRITE_SERVICETIME, SMALL_SYNC_READ_LATENCY,                  LARGE_READ_SERVICETIME, LARGE_WRITE_SERVICETIME,                   ASYNCH_IO, ACCESS_METHOD, RETRIES_ON_ERROR, CON_ID                 FROM GV$IOSTAT_FILE where inst_id=USERENV('Instance')
+++V$IOSTAT_FUNCTION+++               SELECT FUNCTION_ID, FUNCTION_NAME,                                     SMALL_READ_MEGABYTES, SMALL_WRITE_MEGABYTES,                           LARGE_READ_MEGABYTES, LARGE_WRITE_MEGABYTES, SMALL_READ_REQS,          SMALL_WRITE_REQS, LARGE_READ_REQS, LARGE_WRITE_REQS,                   NUMBER_OF_WAITS, WAIT_TIME, CON_ID                                     FROM GV$IOSTAT_FUNCTION where inst_id=USERENV('Instance')
+++V$IOSTAT_FUNCTION_DETAIL+++        SELECT FUNCTION_ID, FUNCTION_NAME, FILETYPE_ID, FILETYPE_NAME,           SMALL_READ_MEGABYTES, SMALL_WRITE_MEGABYTES,                             LARGE_READ_MEGABYTES, LARGE_WRITE_MEGABYTES, SMALL_READ_REQS,            SMALL_WRITE_REQS, LARGE_READ_REQS, LARGE_WRITE_REQS,                     NUMBER_OF_WAITS, WAIT_TIME, CON_ID                                       FROM GV$IOSTAT_FUNCTION_DETAIL                                           where inst_id=USERENV('Instance')
+++V$IOSTAT_NETWORK+++                select  CLIENT,        READS#,        WRITES#,        KBYTES_READ,        KBYTES_WRITTEN,        READ_LATENCY,        WRITE_LATENCY,         CON_ID from GV$IOSTAT_NETWORK where inst_id=USERENV('Instance')
+++V$IOS_CLIENT+++                    select client_id, cluster_id, node, instance_name, db_name, group_number,   con_id  from gv$ios_client where inst_id = USERENV('Instance')
+++V$IO_CALIBRATION_STATUS+++         SELECT status, calibration_time, con_id                      FROM GV$IO_CALIBRATION_STATUS                                WHERE  inst_id = USERENV('INSTANCE')
+++V$IO_OUTLIER+++                    SELECT FUNCTION_NAME,          IO_SIZE,                       WAIT_EVENT,                    FILE_NAME,                     IO_LATENCY,                    DISK1_NAME,                    DISK1_LATENCY,              DISK2_NAME,                    DISK2_LATENCY,              DISK3_NAME,                    DISK3_LATENCY,               CON_ID                          FROM GV$IO_OUTLIER WHERE INST_ID=USERENV('Instance')
+++V$IR_FAILURE+++                    select FAILURE_ID,       PARENT_ID,       CHILD_COUNT,       CLASS_NAME,       TIME_DETECTED,       MODIFIED,       DESCRIPTION,       IMPACTS,       PRIORITY,       STATUS,        CON_ID from GV$IR_FAILURE where inst_id=USERENV('Instance')
+++V$IR_FAILURE_SET+++                select ADVISE_ID,       FAILURE_ID,       MANUAL_REPAIRS_ONLY,        CON_ID from GV$IR_FAILURE_SET where inst_id=USERENV('Instance')
+++V$IR_MANUAL_CHECKLIST+++           select ADVISE_ID,       RANK,       REQUIRED,       MESSAGE,        CON_ID from GV$IR_MANUAL_CHECKLIST where inst_id=USERENV('Instance')
+++V$IR_REPAIR+++                     select REPAIR_ID,       ADVISE_ID,       SUMMARY,       RANK,       TIME_DETECTED,       EXECUTED,       ESTIMATED_DATA_LOSS,       DETAILED_DESCRIPTION,       REPAIR_SCRIPT,       ESTIMATED_REPAIR_TIME,       ACTUAL_REPAIR_TIME,       STATUS,        CON_ID from GV$IR_REPAIR where inst_id=USERENV('Instance')
+++V$JAVAPOOL+++                      select CATEGORY, MEMUSED, CON_ID from gv$javapool  where inst_id = USERENV('Instance')
+++V$JAVA_LIBRARY_CACHE_MEMORY+++     select lc_namespace, lc_inuse_memory_objects, lc_inuse_memory_size,  lc_freeable_memory_objects, lc_freeable_memory_size, con_id  from gv$java_library_cache_memory where inst_id = USERENV('Instance')
+++V$JAVA_POOL_ADVICE+++              select java_pool_size_for_estimate, java_pool_size_factor,  estd_lc_size, estd_lc_memory_objects, estd_lc_time_saved,  estd_lc_time_saved_factor, estd_lc_load_time,  estd_lc_load_time_factor, estd_lc_memory_object_hits, con_id  from gv$java_pool_advice where inst_id = USERENV('Instance')
+++V$KERNEL_IO_OUTLIER+++             SELECT TIMESTAMP,                  IO_SIZE,                           IO_OFFSET,                         DEVICE_NAME,                       PROCESS_NAME,                      TOTAL_LATENCY,                     SETUP_LATENCY,                     QUEUE_TO_HBA_LATENCY,              TRANSFER_LATENCY,                  CLEANUP_LATENCY,                   PID,                               CON_ID                             FROM GV$KERNEL_IO_OUTLIER          WHERE INST_ID=USERENV('Instance')
+++V$KEY_VECTOR+++                    select    session_id, con_id, translate_id, sql_id, sql_exec_start, sql_exec_id,   process, state, type, width, key_data_type,    join_column_count, join_key_count, dup_join_key_count,    min_join_key, max_join_key, group_key_count,    filtered, probed, active, disabled,    memory_allocated, join_structure_size,    fact_owner, fact_name, dimension_owner, dimension_name  from GV$KEY_VECTOR where inst_id = USERENV('Instance')
+++V$LATCH+++                         select addr,latch#,level#,name,hash,gets,misses,sleeps,immediate_gets, immediate_misses,waiters_woken,waits_holding_latch,spin_gets, sleep1,sleep2,sleep3,sleep4,sleep5,sleep6,sleep7,sleep8,sleep9, sleep10,sleep11,wait_time, con_id from gv$latch where inst_id = USERENV('Instance')
+++V$LATCHHOLDER+++                   select  PID , SID , LADDR , NAME , GETS, CON_ID from GV$LATCHHOLDER where inst_id = USERENV('Instance')
+++V$LATCHNAME+++                     select latch#, name, display_name, hash, con_id from gv$latchname where inst_id = userenv('Instance')
+++V$LATCH_CHILDREN+++                 select  ADDR , LATCH# , CHILD# , LEVEL# , NAME , HASH , GETS , MISSES , SLEEPS , IMMEDIATE_GETS , IMMEDIATE_MISSES , WAITERS_WOKEN , WAITS_HOLDING_LATCH , SPIN_GETS , SLEEP1 , SLEEP2 , SLEEP3 , SLEEP4 , SLEEP5 , SLEEP6 , SLEEP7 , SLEEP8 , SLEEP9 , SLEEP10 , SLEEP11 , WAIT_TIME, CON_ID from GV$LATCH_CHILDREN where inst_id = USERENV('Instance')
+++V$LATCH_MISSES+++                  select  PARENT_NAME, LOCATION, NWFAIL_COUNT, SLEEP_COUNT,  WTR_SLP_COUNT, LONGHOLD_COUNT, LOCATION, CON_ID from GV$LATCH_MISSES where inst_id = USERENV('Instance')
+++V$LATCH_PARENT+++                  select  ADDR , LATCH# , LEVEL# , NAME , HASH , GETS , MISSES , SLEEPS , IMMEDIATE_GETS , IMMEDIATE_MISSES , WAITERS_WOKEN , WAITS_HOLDING_LATCH , SPIN_GETS , SLEEP1 , SLEEP2 , SLEEP3 , SLEEP4 , SLEEP5 , SLEEP6 , SLEEP7 , SLEEP8 , SLEEP9 , SLEEP10 , SLEEP11 , WAIT_TIME, CON_ID from GV$LATCH_PARENT where inst_id = USERENV('Instance')
+++V$LGWRIO_OUTLIER+++                SELECT FUNCTION_NAME,          IO_SIZE,                       WAIT_EVENT,                    FILE_NAME,                     IO_LATENCY,                    DISK1_NAME,                    DISK1_LATENCY,              DISK2_NAME,                    DISK2_LATENCY,              DISK3_NAME,                    DISK3_LATENCY,               CON_ID                          FROM GV$LGWRIO_OUTLIER WHERE INST_ID=USERENV('Instance')
+++V$LIBCACHE_LOCKS+++                SELECT TYPE, ADDR, HOLDING_USER_SESSION, HOLDING_SESSION,         OBJECT_HANDLE, LOCK_HELD, REFCOUNT, MODE_HELD, MODE_REQUESTED,        SAVEPOINT_NUMBER, CON_ID FROM GV$LIBCACHE_LOCKS         WHERE INST_ID = USERENV('INSTANCE')
+++V$LIBRARYCACHE+++                  select  NAMESPACE , GETS , GETHITS , GETHITRATIO , PINS , PINHITS , PINHITRATIO , RELOADS , INVALIDATIONS , DLM_LOCK_REQUESTS , DLM_PIN_REQUESTS , DLM_PIN_RELEASES , DLM_INVALIDATION_REQUESTS , DLM_INVALIDATIONS, CON_ID from GV$LIBRARYCACHE where inst_id = USERENV('Instance')
+++V$LIBRARY_CACHE_MEMORY+++          select lc_namespace, lc_inuse_memory_objects, lc_inuse_memory_size,  lc_freeable_memory_objects, lc_freeable_memory_size, con_id  from gv$library_cache_memory where inst_id = USERENV('Instance')
+++V$LICENSE+++                       select sessions_max,sessions_warning,sessions_current,sessions_highwater, users_max, cpu_count_current, cpu_core_count_current, cpu_socket_count_current, cpu_count_highwater, cpu_core_count_highwater, cpu_socket_count_highwater, con_id from gv$license where inst_id = userenv('Instance')
+++V$LISTENER_NETWORK+++              SELECT NETWORK, TYPE, VALUE, CON_ID          FROM GV$LISTENER_NETWORK          WHERE INST_ID = USERENV('INSTANCE')          ORDER BY NETWORK, TYPE, VALUE
+++V$LOADISTAT+++                     select  OWNER, TABNAME, INDEXNAME, SUBNAME, MESSAGE_NUM, MESSAGE, CON_ID from GV$LOADISTAT where INST_ID = USERENV('Instance')
+++V$LOADPSTAT+++                     select  OWNER , TABNAME , PARTNAME , LOADED, CON_ID from GV$LOADPSTAT where inst_id = USERENV('Instance')
+++V$LOBSTAT+++                       select  inst_id, LOBTSN, LOBRDBA, LOBOBJID, LOBCURRTIME, LOBEXPMQL, LOBSQLMQL, LOBSPCANALTIME,           LOBUNDORETTIME, CON_ID           from gv$lobstat where inst_id = userenv('instance')
+++V$LOCK+++                          select  ADDR , KADDR , SID , TYPE , ID1 , ID2 , LMODE , REQUEST , CTIME , BLOCK, CON_ID from GV$LOCK where inst_id = USERENV('Instance')
+++V$LOCKED_OBJECT+++                 select xidusn,xidslot,xidsqn,object_id,session_id,oracle_username, os_user_name,process,locked_mode,con_id from gv$locked_object where inst_id = USERENV('Instance')
+++V$LOCKS_WITH_COLLISIONS+++         select lock_element_addr, con_id  from v$bh                  where (forced_writes + forced_reads) > 10                    group by lock_element_addr, con_id                           having count(*) >= 2
+++V$LOCK_ACTIVITY+++                 SELECT FROM_VAL,TO_VAL,ACTION_VAL,COUNTER, con_id         FROM GV$LOCK_ACTIVITY          where INST_ID = USERENV('INSTANCE')
+++V$LOCK_ELEMENT+++                  select lock_element_addr, indx, class, lock_element_name,          mode_held, block_count, releasing, acquiring, invalid, flags, con_id          from gv$lock_element where inst_id = USERENV('Instance')
+++V$LOCK_TYPE+++                     select TYPE, NAME, ID1_TAG, ID2_TAG, IS_USER, IS_RECYCLE, DESCRIPTION, CON_ID    from GV$LOCK_TYPE    where INST_ID = USERENV('Instance')
+++V$LOG+++                           select   GROUP# , THREAD# , SEQUENCE# , BYTES , BLOCKSIZE, MEMBERS , ARCHIVED , STATUS , FIRST_CHANGE# , FIRST_TIME, NEXT_CHANGE#, NEXT_TIME, CON_ID from GV$LOG where inst_id = USERENV('Instance')
+++V$LOGFILE+++                       select  GROUP# , STATUS , TYPE , MEMBER, IS_RECOVERY_DEST_FILE, CON_ID from GV$LOGFILE where inst_id = USERENV('Instance')
+++V$LOGHIST+++                       select  THREAD# , SEQUENCE# , FIRST_CHANGE# , FIRST_TIME , SWITCH_CHANGE#, CON_ID from GV$LOGHIST where inst_id = USERENV('Instance')
+++V$LOGMNR_CONTENTS+++               select SCN, START_SCN, COMMIT_SCN,         TIMESTAMP, START_TIMESTAMP, COMMIT_TIMESTAMP,         XIDUSN, XIDSLT, XIDSQN, XID,         PXIDUSN, PXIDSLT, PXIDSQN, PXID,         TX_NAME,         OPERATION, OPERATION_CODE, ROLLBACK,         SEG_OWNER, SEG_NAME, TABLE_NAME, SEG_TYPE, SEG_TYPE_NAME,         TABLE_SPACE, ROW_ID,         USERNAME, OS_USERNAME, MACHINE_NAME, AUDIT_SESSIONID,         SESSION#, SERIAL#, SESSION_INFO,         THREAD#, SEQUENCE#, RBASQN, RBABLK, RBABYTE,         UBAFIL, UBABLK, UBAREC,  UBASQN,         ABS_FILE#,REL_FILE#, DATA_BLK#,         DATA_OBJ#, DATA_OBJV#, DATA_OBJD#,         SQL_REDO,  SQL_UNDO, RS_ID, SSN, CSF, INFO,         STATUS, REDO_VALUE, UNDO_VALUE,         SAFE_RESUME_SCN, CSCN, OBJECT_ID, EDITION_NAME, CLIENT_ID,         SRC_CON_NAME, SRC_CON_ID, SRC_CON_UID, SRC_CON_DBID, SRC_CON_GUID,         CON_ID      from GV$LOGMNR_CONTENTS where inst_id = userenv('instance')
+++V$LOGMNR_DBA_OBJECTS+++            select OWNER, OBJECT_NAME, SUBOBJECT_NAME, OBJECT_ID, DATA_OBJECT_ID,      OBJECT_TYPE, CREATED, LAST_DDL_TIME, TIMESTAMP, STATUS,      TEMPORARY, GENERATED, SECONDARY, CON_ID from gv$logmnr_dba_objects where inst_id = userenv('instance')
+++V$LOGMNR_DICTIONARY+++             select DB_NAME, DB_ID, DB_CREATED, TIMESTAMP, RESET_SCN,                 RESET_SCN_TIME, DB_VERSION_TIME, DB_CHARACTER_SET,                 DB_VERSION, DB_STATUS, DICTIONARY_SCN, ENABLED_THREAD_MAP,                 DB_TXN_SCN, FILENAME, INFO, STATUS, CON_ID       from GV$LOGMNR_DICTIONARY  where inst_id = userenv('instance')
+++V$LOGMNR_DICTIONARY_LOAD+++        select session_id, logmnr_uid,                                   action#, opcode, command, current_state,                  completed_actions, total_actions, loaded,                 percent_done, con_id          from gv$logmnr_dictionary_load where inst_id = userenv('instance')
+++V$LOGMNR_EXTENTS+++                select OWNER, SEGMENT_NAME, PARTITION_NAME, SEGMENT_TYPE, TABLESPACE_NAME,         EXTENT_ID, FILE_ID, BLOCK_ID, BYTES, BLOCKS, RELATIVE_FNO, CON_ID from GV$LOGMNR_EXTENTS where inst_id = userenv('instance')
+++V$LOGMNR_LATCH+++                  select session_id, name,                 child_addr, state, con_id          from gv$logmnr_latch where inst_id = userenv('instance')
+++V$LOGMNR_LOGFILE+++                select log_id, filename, low_time, next_time,                 db_id, db_name, reset_scnwrp, reset_scnbas, reset_scn_time,                thread_id, thread_sqn, low_scnwrp, low_scnbas,                 next_scnwrp, next_scnbas, file_state, con_id          from gv$logmnr_logfile where inst_id = userenv('instance')
+++V$LOGMNR_LOGS+++                   select LOG_ID, FILENAME, LOW_TIME, HIGH_TIME, DB_ID, DB_NAME,                   RESET_SCN, RESET_SCN_TIME, COMPATIBLE, THREAD_ID, THREAD_SQN,                 LOW_SCN,  NEXT_SCN, DICTIONARY_BEGIN,                                    DICTIONARY_END, TYPE, BLOCKSIZE, FILESIZE, INFO,                 STATUS, CON_ID       from GV$LOGMNR_LOGS where inst_id = userenv('instance')
+++V$LOGMNR_OBJECT_SEGMENTS+++        select OWNER, SEGMENT_NAME, PARTITION_NAME, SEGMENT_TYPE,         SEGMENT_TYPE_ID, TABLESPACE_ID, TABLESPACE_NAME, BLOCKSIZE,         HEADER_FILE, HEADER_BLOCK, BYTES, BLOCKS, EXTENTS, INITIAL_EXTENT,         NEXT_EXTENT, MIN_EXTENTS, MAX_EXTENTS, PCT_INCREASE, FREELISTS,         FREELIST_GROUPS, RELATIVE_FNO, BUFFER_POOL_ID, SEGMENT_FLAGS,         SEGMENT_OBJD, CON_ID from GV$LOGMNR_OBJECT_SEGMENTS where inst_id = userenv('instance')
+++V$LOGMNR_PARAMETERS+++             select START_DATE, REQUIRED_START_DATE,          END_DATE, START_SCN, REQUIRED_START_SCN, END_SCN,          OPTIONS, INFO, STATUS, CON_ID       from GV$LOGMNR_PARAMETERS  where inst_id = userenv('instance')
+++V$LOGMNR_PROCESS+++                select session_id, pid, spid, role, username, sid, serial#,                 latchwait, latchspin, work_microsec,                 overhead_microsec, con_id          from gv$logmnr_process          where inst_id = userenv('instance')
+++V$LOGMNR_SESSION+++                select session_id, session_name, session_state,         db_name, db_id, reset_scn, reset_timestamp, reset_time,                     num_process, chunk_size,                 start_scn, end_scn, spill_scn,                 processed_scn, processed_time, prepared_scn, read_scn,                     low_mark_scn, consumed_scn,                 max_memory_size, used_memory_size,                 builder_work_size, prepared_work_size, available_work_size,                 available_txn, available_committed_txn,                 delivered_txn, delivered_committed_txn,                 pinned_txn, pinned_committed_txn, checkpoint_interval, con_id          from GV$LOGMNR_SESSION where inst_id = userenv('instance')
+++V$LOGMNR_STATS+++                  select session_id, name,value, con_id from gv$logmnr_stats  where inst_id = USERENV('Instance')
+++V$LOGMNR_SYS_DBA_SEGS+++           select OWNER, SEGMENT_NAME, PARTITION_NAME, SEGMENT_TYPE,         SEGMENT_TYPE_ID, TABLESPACE_ID, TABLESPACE_NAME, BLOCKSIZE,         HEADER_FILE, HEADER_BLOCK, BYTES, BLOCKS, EXTENTS, INITIAL_EXTENT,         NEXT_EXTENT, MIN_EXTENTS, MAX_EXTENTS, PCT_INCREASE, FREELISTS,         FREELIST_GROUPS, RELATIVE_FNO, BUFFER_POOL_ID, SEGMENT_FLAGS,         SEGMENT_OBJD, CON_ID from gv$logmnr_sys_dba_segs where inst_id = userenv('instance')
+++V$LOGMNR_SYS_OBJECTS+++            select OBJECT_TYPE, OBJECT_TYPE_ID, SEGMENT_TYPE_ID, OBJECT_ID, HEADER_FILE,         HEADER_BLOCK, TS_NUMBER, CON_ID from gv$logmnr_sys_objects where inst_id = userenv('instance')
+++V$LOGMNR_TRANSACTION+++            select session_id, xid, xidusn, xidslt, xidsqn, parent_xid,                 parent_xidusn, parent_xidslt, parent_xidsqn, start_time,                 start_scn, chunk#, total_chunks, redo_thread, low_time,                 low_scn, high_time, high_scn, lcr_count,                 spilled_lcr_count, dflag, mflag, mflag2, state, type,                 mining_status, queue, src_con_id, con_id          from gv$logmnr_transaction          where inst_id = userenv('instance')
+++V$LOGSTDBY+++                      select serial#,logstdby_id,pid,type,status_code,status,high_scn, con_id from gv$logstdby where inst_id = USERENV('Instance')
+++V$LOGSTDBY_PROCESS+++              select sid, serial#,logstdby_id,spid,type,status_code,status,high_scn,con_id from gv$logstdby_process where inst_id = USERENV('Instance')
+++V$LOGSTDBY_PROGRESS+++             select applied_scn,applied_time,restart_scn,restart_time,latest_scn, latest_time,mining_scn, mining_time, resetlogs_id, con_id from gv$logstdby_progress where inst_id = USERENV('Instance')
+++V$LOGSTDBY_STATE+++                select primary_dbid,primary_con_dbid,session_id, realtime_apply,state, con_id from gv$logstdby_state where inst_id = USERENV('Instance')
+++V$LOGSTDBY_STATS+++                select name,value, con_id from gv$logstdby_stats where inst_id = USERENV('Instance')
+++V$LOGSTDBY_TRANSACTION+++          select primary_xidusn, primary_xidslt, primary_xidsqn, primary_xid,                 primary_start_scn, primary_start_time,                 primary_parent_xidusn, primary_parent_xidslt,                 primary_parent_xidsqn, primary_parent_xid, type,                 mining_status, src_con_id, apply_status, sid, serial#, con_id          from gv$logstdby_transaction          where inst_id = USERENV('Instance')
+++V$LOG_HISTORY+++                   select  RECID , STAMP , THREAD# , SEQUENCE# , FIRST_CHANGE# , FIRST_TIME , NEXT_CHANGE#, RESETLOGS_CHANGE#,  RESETLOGS_TIME, CON_ID from GV$LOG_HISTORY
+++V$MANAGED_STANDBY+++               select PROCESS, PID, STATUS, CLIENT_PROCESS, CLIENT_PID, CLIENT_DBID, GROUP#, RESETLOG_ID, THREAD#, SEQUENCE#, BLOCK#, BLOCKS, DELAY_MINS, KNOWN_AGENTS, ACTIVE_AGENTS, CON_ID from GV$MANAGED_STANDBY where inst_id = USERENV('Instance')
+++V$MAPPED_SQL+++                    select SQL_TEXT, SQL_FULLTEXT, SQL_ID, HASH_VALUE, MAPPED_SQL_TEXT, MAPPED_SQL_FULLTEXT, MAPPED_SQL_ID, MAPPED_HASH_VALUE, SQL_TRANSLATION_PROFILE_ID, CON_ID from GV$MAPPED_SQL where inst_id = USERENV('Instance')
+++V$MAP_COMP_LIST+++                 select ELEM_IDX,NUM_COMP,COMP1_NAME,COMP1_VAL, COMP2_NAME,COMP2_VAL,COMP3_NAME,COMP3_VAL, COMP4_NAME,COMP4_VAL,COMP5_NAME,COMP5_VAL,CON_ID from gv$map_comp_list where inst_id = USERENV('Instance')
+++V$MAP_ELEMENT+++                   select ELEM_NAME,ELEM_IDX,ELEM_CFGID,ELEM_TYPE, ELEM_SIZE,ELEM_NSUBELEM,ELEM_DESCR,STRIPE_SIZE,LIB_IDX,CON_ID from gv$map_element where inst_id = USERENV('Instance')
+++V$MAP_EXT_ELEMENT+++               select ELEM_IDX,NUM_ATTRB,ATTRB1_NAME,ATTRB1_VAL, ATTRB2_NAME,ATTRB2_VAL,ATTRB3_NAME,ATTRB3_VAL, ATTRB4_NAME,ATTRB4_VAL,ATTRB5_NAME,ATTRB5_VAL,CON_ID from gv$map_ext_element where inst_id = USERENV('Instance')
+++V$MAP_FILE+++                      select FILE_MAP_IDX,FILE_CFGID,FILE_STATUS,FILE_NAME, FILE_TYPE,FILE_STRUCTURE,FILE_SIZE,FILE_NEXTS,LIB_IDX, CON_ID  from gv$map_file where inst_id = USERENV('Instance')
+++V$MAP_FILE_EXTENT+++               select FILE_MAP_IDX,EXT_NUM,EXT_ELEM_OFF,EXT_SIZE, EXT_FILE_OFF,EXT_TYPE,ELEM_IDX,CON_ID from gv$map_file_extent where inst_id = USERENV('Instance')
+++V$MAP_FILE_IO_STACK+++             select FILE_MAP_IDX,DEPTH,ELEM_IDX,CU_SIZE, STRIDE,NUM_CU,ELEM_OFFSET,FILE_OFFSET,DATA_TYPE, PARITY_POS,PARITY_PERIOD,ID,PARENT_ID,CON_ID from gv$map_file_io_stack where inst_id = USERENV('Instance')
+++V$MAP_LIBRARY+++                   select LIB_IDX,LIB_NAME,VENDOR_NAME,PROTOCOL_NUM, VERSION_NUM,PATH_NAME,MAP_FILE,FILE_CFGID,MAP_ELEM, ELEM_CFGID,MAP_SYNC,CON_ID from gv$map_library where inst_id = USERENV('Instance')
+++V$MAP_SUBELEMENT+++                select CHILD_IDX,PARENT_IDX,SUB_NUM,SUB_SIZE, ELEM_OFFSET,SUB_FLAGS,CON_ID from gv$map_subelement where inst_id = USERENV('Instance')
+++V$MAX_ACTIVE_SESS_TARGET_MTH+++    select name, con_id from gv$max_active_sess_target_mth          where inst_id = userenv('instance')
+++V$MEMORY_CURRENT_RESIZE_OPS+++     select component, oper_type, oper_mode, parameter, initial_size,     target_size, current_size, start_time, last_update_time, con_id   from gv$memory_current_resize_ops   where inst_id = USERENV('Instance')
+++V$MEMORY_DYNAMIC_COMPONENTS+++     select component, current_size, min_size, max_size, user_specified_size,     oper_count, last_oper_type, last_oper_mode, last_oper_time, granule_size,   con_id from gv$memory_dynamic_components   where inst_id = USERENV('Instance')
+++V$MEMORY_RESIZE_OPS+++             select component, oper_type, oper_mode, parameter, initial_size,     target_size, final_size, status, start_time, end_time, con_id   from gv$memory_resize_ops   where inst_id = USERENV('Instance')
+++V$MEMORY_TARGET_ADVICE+++          select memory_size, memory_size_factor, estd_db_time,              estd_db_time_factor, version, con_id                               from gv$memory_target_advice where inst_id = userenv('instance')
+++V$METRIC+++                        SELECT begin_time, end_time, intsize_csec,            group_id, entity_id, entity_sequence, metric_id, metric_name,            value, metric_unit, con_id          FROM   gv$metric          WHERE  inst_id = USERENV('INSTANCE')
+++V$METRICGROUP+++                   SELECT group_id, name, interval_size, max_interval, con_id          FROM   gv$metricgroup          WHERE  inst_id = USERENV('INSTANCE')
+++V$METRICNAME+++                    SELECT group_id, group_name, metric_id,            metric_name, metric_unit, con_id          FROM   gv$metricname          WHERE  inst_id = USERENV('INSTANCE')
+++V$METRIC_HISTORY+++                SELECT begin_time, end_time, intsize_csec,            group_id, entity_id, entity_sequence, metric_id, metric_name,            value, metric_unit, con_id          FROM   gv$metric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$MTTR_TARGET_ADVICE+++            select mttr_target_for_estimate, advice_status, dirty_limit,            estd_cache_writes, estd_cache_write_factor, estd_total_writes,          estd_total_write_factor,                                                estd_total_ios, estd_total_io_factor, con_id from gv$mttr_target_advice  where inst_id = userenv('instance')
+++V$MUTEX_SLEEP+++                   select MUTEX_TYPE, LOCATION, SLEEPS, WAIT_TIME, CON_ID from GV$MUTEX_SLEEP where INST_ID = USERENV('INSTANCE')
+++V$MUTEX_SLEEP_HISTORY+++           select MUTEX_IDENTIFIER, SLEEP_TIMESTAMP, MUTEX_TYPE, GETS, SLEEPS, REQUESTING_SESSION, BLOCKING_SESSION, LOCATION, MUTEX_VALUE, P1, P1RAW, P2, P3, P4, P5, CON_ID from GV$MUTEX_SLEEP_HISTORY where INST_ID = USERENV('INSTANCE')
+++V$MVREFRESH+++                     SELECT SID, SERIAL#, CURRMVOWNER, CURRMVNAME, CON_ID         FROM GV$MVREFRESH
+++V$MYSTAT+++                        select  SID , STATISTIC# , VALUE, CON_ID from GV$MYSTAT where inst_id = USERENV('Instance')
+++V$NFS_CLIENTS+++                   SELECT NFSCLIENTID, NFSPRINCIPAL, NFSOPAQUECLIENT,            NFSVERIFIER, NFSLEASEEXPIRY, NFSCLIENTNETID || NFSCLIENTADDR,            decode(bitand(NFSFLAGS,1), 1, 'TRUE', 'FALSE'), CON_ID          FROM X$NFSCLIENTS
+++V$NFS_LOCKS+++                     SELECT NFSOPENSTATEID, NFSOPENSEQNO, NFSLOCKSTATEID,            NFSLOCKSEQNO, NFSLOCKOWNER,            NFSLOCKOFFSET, NFSLOCKLENGTH, NFSLOCKTYPE, CON_ID          FROM X$NFSLOCKS
+++V$NFS_OPEN_FILES+++                SELECT NFSCLIENTID, NFSOPENOWNER, NFSOPENSTATEID,            NFSOPENFILEHANDLE, NFSOPENSEQID,            decode(bitand(NFSOPENFLAGS,1), 0, 'FALSE', 'TRUE'),            decode(bitand(NFSOPENFLAGS,2), 0, 'FALSE', 'TRUE'),            decode(bitand(NFSOPENFLAGS,384), 384, 'SharedReadWrite', 128, 'SharedRead', 256, 'SharedWrite'),            decode(bitand(NFSOPENFLAGS,1536), 1536, 'DenyReadWrite', 512, 'DenyRead', 1024, 'DenyWrite'),            decode(bitand(NFSOPENFLAGS,64), 0, 'FALSE', 'TRUE'), CON_ID          FROM X$NFSOPENS
+++V$NLS_PARAMETERS+++                select  PARAMETER , VALUE, CON_ID from GV$NLS_PARAMETERS where inst_id = USERENV('Instance')
+++V$NLS_VALID_VALUES+++              select  PARAMETER , VALUE, ISDEPRECATED, CON_ID from GV$NLS_VALID_VALUES where inst_id = USERENV('Instance')
+++V$NONLOGGED_BLOCK+++               select FILE#, BLOCK#, BLOCKS, NONLOGGED_START_CHANGE#, NONLOGGED_START_TIME,  NONLOGGED_END_CHANGE#, NONLOGGED_END_TIME, RESETLOGS_CHANGE#,  RESETLOGS_TIME, OBJECT#, REASON, CON_ID  from GV$NONLOGGED_BLOCK   where inst_id = USERENV('Instance')
+++V$OBJECT_DEPENDENCY+++             select  FROM_ADDRESS , FROM_HASH , TO_OWNER , TO_NAME , TO_ADDRESS , TO_HASH , TO_TYPE, CON_ID from GV$OBJECT_DEPENDENCY where inst_id = USERENV('Instance')
+++V$OBJECT_DML_FREQUENCIES+++        SELECT OBJNAME, WORKING, SLOT0, SLOT1, SLOT2, SLOT3, SLOT4, SLOT5, SLOT6, SLOT7, SLOT8, SLOT9, SLOT10, SLOT11, SLOT12, SLOT13, SLOT14, SLOT15, SLOT16, SLOT17, SLOT18, SLOT19, SLOT20, SLOT21, SLOT22, SLOT23, SLOT24, CON_ID FROM X$KSXM_DFT
+++V$OBJECT_PRIVILEGE+++              SELECT OBJECT_TYPE_NAME, OBJECT_TYPE_ID, PRIVILEGE_ID, PRIVILEGE_NAME, CON_ID  FROM X$KZPOPR
+++V$OBSOLETE_PARAMETER+++            select  NAME , ISSPECIFIED, CON_ID from GV$OBSOLETE_PARAMETER where inst_id = USERENV('Instance')
+++V$OFFLINE_RANGE+++                 select  RECID , STAMP , FILE# , OFFLINE_CHANGE# , ONLINE_CHANGE# , ONLINE_TIME, RESETLOGS_CHANGE#, RESETLOGS_TIME, CON_ID from GV$OFFLINE_RANGE  where inst_id = USERENV('Instance')
+++V$OFSMOUNT+++                      select ofs_mntpath, ofs_fspath, ofs_mntopts,         ofs_mntflgs, con_id from GV$OFSMOUNT         where inst_id = USERENV('Instance')
+++V$OFS_STATS+++                     select ofs_mntpnt, ofs_lookup, ofs_forget, ofs_getattr, ofs_setattr,          ofs_readlink, ofs_symlink, ofs_mknod, ofs_mkdir, ofs_unlink,          ofs_rmdir, ofs_rename, ofs_link, ofs_open, ofs_read, ofs_write,          ofs_statfs, ofs_release, ofs_fsync, ofs_setxattr, ofs_getxattr,          ofs_listxattr, ofs_removexattr, ofs_flush, ofs_init, ofs_opendir,          ofs_readdir, ofs_releasedir, ofs_fsyncdir, ofs_getlk, ofs_setlk,          ofs_setlkw, ofs_access, ofs_create, ofs_interrupt, ofs_bmap,          ofs_destroy, ofs_bytes_read, ofs_bytes_written, con_id from          gv$ofs_stats where inst_id = USERENV('Instance')
+++V$OPEN_CURSOR+++                   select  SADDR , SID , USER_NAME , ADDRESS , HASH_VALUE, SQL_ID, SQL_TEXT,          LAST_SQL_ACTIVE_TIME, SQL_EXEC_ID, CURSOR_TYPE,                            CHILD_ADDRESS, CON_ID                                              from    GV$OPEN_CURSOR  where   inst_id = USERENV('Instance')
+++V$OPTIMIZER_PROCESSING_RATE+++     SELECT ADDR, OPERATION_NAME,          MANUAL_VALUE,          CALIBRATION_VALUE, DEFAULT_VALUE,          CON_ID FROM GV$OPTIMIZER_PROCESSING_RATE          where inst_id=USERENV('Instance')
+++V$OPTION+++                        select  PARAMETER , VALUE, CON_ID from GV$OPTION where inst_id = USERENV('Instance')
+++V$OSSTAT+++                        select STAT_NAME, VALUE, OSSTAT_ID, COMMENTS, CUMULATIVE, CON_ID from GV$OSSTAT where INST_ID = USERENV('Instance')
+++V$PARALLEL_DEGREE_LIMIT_MTH+++     select name, con_id from gv$parallel_degree_limit_mth          where inst_id = userenv('instance')
+++V$PARAMETER+++                     select  NUM , NAME , TYPE , VALUE , DISPLAY_VALUE, DEFAULT_VALUE, ISDEFAULT , ISSES_MODIFIABLE , ISSYS_MODIFIABLE , ISPDB_MODIFIABLE , ISINSTANCE_MODIFIABLE, ISMODIFIED , ISADJUSTED , ISDEPRECATED, ISBASIC, DESCRIPTION, UPDATE_COMMENT, HASH, CON_ID  from GV$PARAMETER where inst_id = USERENV('Instance')
+++V$PARAMETER2+++                    select  NUM , NAME , TYPE , VALUE , DISPLAY_VALUE,  ISDEFAULT , ISSES_MODIFIABLE ,  ISSYS_MODIFIABLE , ISPDB_MODIFIABLE , ISINSTANCE_MODIFIABLE, ISMODIFIED ,  ISADJUSTED , ISDEPRECATED, ISBASIC,  DESCRIPTION, ORDINAL,  UPDATE_COMMENT, CON_ID from GV$PARAMETER2 where inst_id = USERENV('Instance')
+++V$PARAMETER_VALID_VALUES+++        select num, name, ordinal, value, isdefault, con_id from GV$PARAMETER_VALID_VALUES where INST_ID = USERENV('Instance')
+++V$PATCHES+++                       select patch_id, con_id from GV$PATCHES where inst_id = USERENV('Instance')
+++V$PDBS+++                          select con_id, dbid, con_uid, guid, name,  open_mode, restricted, open_time, create_scn, total_size, block_size, recovery_status, snapshot_parent_con_id from GV$PDBS  WHERE  INST_ID = USERENV('Instance')
+++V$PDB_INCARNATION+++               select DB_INCARNATION#, PDB_INCARNATION#, STATUS, INCARNATION_SCN, INCARNATION_TIME, BEGIN_RESETLOGS_SCN, BEGIN_RESETLOGS_TIME, END_RESETLOGS_SCN, END_RESETLOGS_TIME, PRIOR_DB_INCARNATION#, PRIOR_PDB_INCARNATION#, FLASHBACK_DATABASE_ALLOWED, CON_ID from GV$PDB_INCARNATION where inst_id = USERENV('Instance')
+++V$PERSISTENT_PUBLISHERS+++         select queue_id, queue_schema, queue_name,  publisher_name, publisher_address, protocol,  enqueued_msgs, elapsed_enqueue_time, enqueue_cpu_time, last_enqueue_time,  enqueue_transactions, con_id  from gv$persistent_publishers where inst_id =  USERENV('Instance')
+++V$PERSISTENT_QMN_CACHE+++          select QUEUE_TABLE_ID, TYPE, STATUS, NEXT_SERVICE_TIME, WINDOW_END_TIME,         TOTAL_RUNS, TOTAL_LATENCY, TOTAL_ELAPSED_TIME, TOTAL_CPU_TIME,         TMGR_ROWS_PROCESSED, TMGR_ELAPSED_TIME, TMGR_CPU_TIME,         LAST_TMGR_PROCESSING_TIME, DEQLOG_ROWS_PROCESSED,         DEQLOG_PROCESSING_ELAPSED_TIME, DEQLOG_PROCESSING_CPU_TIME,         LAST_DEQLOG_PROCESSING_TIME, DEQUEUE_INDEX_BLOCKS_FREED,         HISTORY_INDEX_BLOCKS_FREED, TIME_INDEX_BLOCKS_FREED,         INDEX_CLEANUP_COUNT, INDEX_CLEANUP_ELAPSED_TIME,         INDEX_CLEANUP_CPU_TIME, LAST_INDEX_CLEANUP_TIME, CON_ID  from GV$PERSISTENT_QMN_CACHE where INST_ID = USERENV('Instance')
+++V$PERSISTENT_QUEUES+++             select queue_id, queue_table_id, queue_schema, queue_name,  first_activity_time, enqueued_msgs, dequeued_msgs, browsed_msgs,  elapsed_enqueue_time, elapsed_dequeue_time,  enqueue_cpu_time, dequeue_cpu_time,  avg_msg_age, dequeued_msg_latency,  elapsed_transformation_time,  elapsed_rule_evaluation_time, enqueued_expiry_msgs, enqueued_delay_msgs,  msgs_made_expired, msgs_made_ready,  last_enqueue_time, last_dequeue_time, last_tm_expiry_time,  last_tm_ready_time, enqueue_transactions, dequeue_transactions,  execution_count, oldest_msgid, oldest_msg_enqtm, con_id  from gv$persistent_queues where inst_id =  USERENV('Instance')
+++V$PERSISTENT_SUBSCRIBERS+++        select queue_id, queue_schema, queue_name,  subscriber_id, subscriber_name,  subscriber_address, protocol, subscriber_type,  first_activity_time, enqueued_msgs, dequeued_msgs,  avg_msg_age, browsed_msgs, expired_msgs,  dequeued_msg_latency, last_enqueue_time, last_dequeue_time,  elapsed_dequeue_time, dequeue_cpu_time,  dequeue_transactions, execution_count, dequeue_memory_locks,  dequeue_disk_locks, dequeue_disk_deletes,  oldest_msgid, oldest_msg_enqtm, con_id  from gv$persistent_subscribers where inst_id =  USERENV('Instance')
+++V$PGASTAT+++                       select   NAME,           VALUE,           UNIT,            CON_ID    from   GV$PGASTAT    where  INST_ID = USERENV('Instance')
+++V$PGA_TARGET_ADVICE+++             select   PGA_TARGET_FOR_ESTIMATE,           PGA_TARGET_FACTOR,           ADVICE_STATUS,           BYTES_PROCESSED,           ESTD_TIME,           ESTD_EXTRA_BYTES_RW,           ESTD_PGA_CACHE_HIT_PERCENTAGE,           ESTD_OVERALLOC_COUNT,           CON_ID    from   GV$PGA_TARGET_ADVICE    where  INST_ID = USERENV('Instance')
+++V$PGA_TARGET_ADVICE_HISTOGRAM+++   select   PGA_TARGET_FOR_ESTIMATE,           PGA_TARGET_FACTOR,           ADVICE_STATUS,           LOW_OPTIMAL_SIZE,           HIGH_OPTIMAL_SIZE,           ESTD_OPTIMAL_EXECUTIONS,           ESTD_ONEPASS_EXECUTIONS,           ESTD_MULTIPASSES_EXECUTIONS,           ESTD_TOTAL_EXECUTIONS,           IGNORED_WORKAREAS_COUNT,           CON_ID    from   GV$PGA_TARGET_ADVICE_HISTOGRAM    where  INST_ID = USERENV('Instance')
+++V$PING+++                          SELECT file#, block#, class#, status, xnc, forced_reads,         forced_writes, name, partition_name, kind, owner#,         lock_element_addr, lock_element_name, con_id  FROM   gv$ping  WHERE  INST_ID = USERENV('Instance')
+++V$POLICY_HISTORY+++                select inst_id, policy_event, database_id,          tablespace_id, data_object_id,          target_instance_number, event_date, con_id          from gv$policy_history where inst_id = USERENV('Instance')
+++V$PQ_SESSTAT+++                    select  STATISTIC , LAST_QUERY , SESSION_TOTAL, CON_ID from GV$PQ_SESSTAT where inst_id = USERENV('Instance')
+++V$PQ_SLAVE+++                      select  SLAVE_NAME , STATUS , SESSIONS , IDLE_TIME_CUR , BUSY_TIME_CUR , CPU_SECS_CUR , MSGS_SENT_CUR , MSGS_RCVD_CUR , IDLE_TIME_TOTAL , BUSY_TIME_TOTAL , CPU_SECS_TOTAL , MSGS_SENT_TOTAL , MSGS_RCVD_TOTAL, CON_ID from GV$PQ_SLAVE where inst_id = USERENV('Instance')
+++V$PQ_SYSSTAT+++                    select  STATISTIC , VALUE, CON_ID from GV$PQ_SYSSTAT where inst_id = USERENV('Instance')
+++V$PQ_TQSTAT+++                     select  DFO_NUMBER , TQ_ID , SERVER_TYPE , NUM_ROWS , BYTES , OPEN_TIME , AVG_LATENCY , WAITS , TIMEOUTS , PROCESS , INSTANCE, CON_ID from GV$PQ_TQSTAT where inst_id = USERENV('Instance')
+++V$PROCESS+++                       select addr, pid, sosid, spid, stid, execution_type, pname, username, serial#, terminal, program, traceid, tracefile, background, latchwait,latchspin,pga_used_mem,pga_alloc_mem,pga_freeable_mem,pga_max_mem, con_id from gv$process where inst_id = USERENV('Instance')
+++V$PROCESS_GROUP+++                 SELECT INDX, NAME, PID, CON_ID FROM gv$process_group    WHERE INST_ID = USERENV('INSTANCE')
+++V$PROCESS_MEMORY+++                select pid, serial#, category, allocated, used, max_allocated, con_id from gv$process_memory where inst_id = USERENV('Instance')
+++V$PROCESS_MEMORY_DETAIL+++         select pid, serial#, category, name, heap_name, bytes, allocation_count, heap_descriptor, parent_heap_descriptor, con_id from gv$process_memory_detail where inst_id = USERENV('Instance')
+++V$PROCESS_MEMORY_DETAIL_PROG+++    select pid, serial#, status, con_id from gv$process_memory_detail_prog where inst_id = USERENV('Instance')
+++V$PROPAGATION_RECEIVER+++          select src_queue_schema, src_queue_name, src_dbname,         dst_queue_schema, dst_queue_name, startup_time,                      high_water_mark, acknowledgement, last_received_msg, total_msgs,         elapsed_unpickle_time, elapsed_rule_time, elapsed_enqueue_time,         session_id, serial#, spid, propagation_name, state,         acknowledgement_position, last_received_msg_position, con_id  from gv$propagation_receiver  where inst_id = USERENV('Instance')
+++V$PROPAGATION_SENDER+++            select queue_id, queue_schema, queue_name, dst_queue_schema,         dst_queue_name, startup_time,         dblink, high_water_mark, acknowledgement, schedule_status,         total_msgs, total_bytes,         elapsed_dequeue_time, elapsed_pickle_time, elapsed_propagation_time,         elapsed_rule_time,         max_num_per_win, max_size, last_msg_latency, last_msg_enqueue_time,         last_msg_propagation_time, last_lcr_latency, last_lcr_creation_time,         last_lcr_propagation_time, dst_database_name, session_id, serial#,         spid, propagation_name, state, con_id  from gv$propagation_sender where inst_id = USERENV('Instance')
+++V$PROXY_ARCHIVEDLOG+++             select  RECID , STAMP , DEVICE_TYPE , HANDLE , COMMENTS , MEDIA , MEDIA_POOL , TAG, STATUS , DELETED, THREAD# , SEQUENCE# , RESETLOGS_CHANGE# , RESETLOGS_TIME , FIRST_CHANGE# , FIRST_TIME , NEXT_CHANGE# , NEXT_TIME , BLOCKS , BLOCK_SIZE , START_TIME , COMPLETION_TIME , ELAPSED_SECONDS, RMAN_STATUS_RECID, RMAN_STATUS_STAMP, TERMINAL, KEEP, KEEP_UNTIL, KEEP_OPTIONS, CON_ID from GV$PROXY_ARCHIVEDLOG where inst_id = USERENV('Instance')
+++V$PROXY_ARCHIVELOG_DETAILS+++      select a.*,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1 from (select b.session_recid session_key, b.session_recid, b.session_stamp,       a.recid copy_key, a.thread#, a.sequence#, a.resetlogs_change#,       a.resetlogs_time, a.handle, a.media, a.media_pool,       a.tag, a.first_change#, a.next_change#, a.first_time, a.next_time,       (a.blocks+1)*a.block_size output_bytes, a.completion_time,       a.keep, a.keep_until, a.keep_options  from v$proxy_archivedlog a, v$rman_status b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual) c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and            a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time))a
+++V$PROXY_ARCHIVELOG_SUMMARY+++      select nvl(num_files_backed, 0),       distinct_files_backed,       min_first_change#,       max_next_change#,       min_first_time,       max_next_time,       output_bytes,    sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1  from (select count(*) num_files_backed,       min(first_change#)min_first_change#,       max(next_change#) max_next_change#,       min(first_time)min_first_time,       max(next_time) max_next_time,       sum((blocks+1)*block_size) output_bytes    from v$proxy_archivedlog a, v$rman_status   b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)), (select count(*) distinct_files_backed     from (select unique thread#, sequence#, resetlogs_change#, resetlogs_time          from v$proxy_archivedlog a, v$rman_status   b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)))
+++V$PROXY_COPY_DETAILS+++            select a.*,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1 from (select b.session_recid session_key, b.session_recid, b.session_stamp,        a.recid copy_key, a.file#,  a.handle, a.media, a.media_pool,       a.tag, a.creation_change#,        a.creation_time, a.checkpoint_change#, a.checkpoint_time,        (a.blocks+1)*a.block_size output_bytes,        a.completion_time, a.controlfile_type, keep, keep_until,        keep_options  from v$proxy_datafile a, v$rman_status b ,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,    (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and            a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time))a
+++V$PROXY_COPY_SUMMARY+++            select a.*,   sys.dbms_rcvman.num2displaysize(output_bytes) output_bytes_display, 1  from (select nvl(sum(num_times_backed),0) num_copies,       sum(distinct_copies)  distinct_copies,       min(min_checkpoint_change#) min_checkpoint_change#,       max(max_checkpoint_change#) max_checkpoint_change#,       min(min_checkpoint_time) min_checkpoint_time,       max(max_checkpoint_time) max_checkpoint_time,       sum(output_bytes) output_bytes   from     (select unique file#, count(*) over (partition by file#,creation_change#)              num_times_backed,        count(distinct file#)                 over (partition by file#,creation_change#,checkpoint_change#)                distinct_copies,       min(checkpoint_change#) over (partition by file#, creation_change#)                  min_checkpoint_change#,       max(checkpoint_change#) over (partition by file#, creation_change#)                  max_checkpoint_change#,       min(checkpoint_time) over (partition by file#, creation_change#)                  min_checkpoint_time,       max(checkpoint_time) over (partition by file#, creation_change#)                  max_checkpoint_time,       sum((blocks+1)*block_size) over (partition by file#, creation_change#)                  output_bytes     from v$proxy_datafile a, v$rman_status   b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual)c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime         from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime         from dual) e     where  a.status = 'A' and            a.rman_status_recid = b.recid (+) and             a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and            (d.fTime is null or d.fTime <= b.start_time) and            (e.uTime is null or e.uTime >= b.end_time)))a
+++V$PROXY_DATAFILE+++                select  RECID , STAMP , DEVICE_TYPE , HANDLE , COMMENTS , MEDIA , MEDIA_POOL , TAG , STATUS , DELETED, FILE# , CREATION_CHANGE# , CREATION_TIME , RESETLOGS_CHANGE# , RESETLOGS_TIME , CHECKPOINT_CHANGE# , CHECKPOINT_TIME , ABSOLUTE_FUZZY_CHANGE# , RECOVERY_FUZZY_CHANGE# , RECOVERY_FUZZY_TIME , INCREMENTAL_LEVEL , ONLINE_FUZZY , BACKUP_FUZZY , BLOCKS , BLOCK_SIZE, OLDEST_OFFLINE_RANGE, START_TIME , COMPLETION_TIME , ELAPSED_SECONDS , CONTROLFILE_TYPE, KEEP, KEEP_UNTIL, KEEP_OPTIONS, RMAN_STATUS_RECID, RMAN_STATUS_STAMP, FOREIGN_DBID, PLUGGED_READONLY, PLUGIN_CHANGE#, PLUGIN_RESETLOGS_CHANGE#, PLUGIN_RESETLOGS_TIME, CON_ID, BACKED_BY_PDB from GV$PROXY_DATAFILE where inst_id = USERENV('Instance')
+++V$PWFILE_USERS+++                  select  USERNAME , SYSDBA , SYSOPER, SYSASM,          SYSBACKUP, SYSDG, SYSKM, CON_ID from GV$PWFILE_USERS where inst_id = USERENV('Instance')
+++V$PX_BUFFER_ADVICE+++              select  STATISTIC , VALUE, CON_ID from GV$PX_BUFFER_ADVICE where inst_id = USERENV('Instance')
+++V$PX_INSTANCE_GROUP+++             select  QC_INSTANCE_GROUP, WHY, INSTANCE_NUMBER, CON_ID from GV$PX_INSTANCE_GROUP  where inst_id = USERENV('Instance')
+++V$PX_PROCESS+++                    select  SERVER_NAME, STATUS, PID, SPID, SID, SERIAL#, IS_GV, CON_ID  from GV$PX_PROCESS where inst_id = USERENV('Instance')
+++V$PX_PROCESS_SYSSTAT+++            select  STATISTIC , VALUE, CON_ID from GV$PX_PROCESS_SYSSTAT where inst_id = USERENV('Instance')
+++V$PX_PROCESS_TRACE+++              select time_stamp, pid, spid, slvid,         pname, sid, qc_inst_id, qcsid, server_set, server#,        comp, filename, line, func, trace, con_id  from GV$PX_PROCESS_TRACE where inst_id = userenv('instance')
+++V$PX_SESSION+++                    select saddr, sid, serial#, qcsid, qcserial#, qcinst_id, server_group, server_set, server#,  degree, req_degree, con_id  from GV$PX_SESSION where inst_id = USERENV('Instance')
+++V$PX_SESSTAT+++                    select saddr, sid, serial#, qcsid, qcserial#, qcinst_id, server_group, server_set, server#,  degree, req_degree,  statistic#, value, con_id  from GV$PX_SESSTAT where inst_id = USERENV('Instance')
+++V$QMON_COORDINATOR_STATS+++        select QMNC_PID, STATUS, NUM_SERVERS, LAST_SERVER_START_TIME,         LAST_SERVER_PID, NEXT_WAKEUP_TIME, NEXT_READY_TIME,         NEXT_EXPIRY_TIME, LAST_WAIT_TIME, LAST_FAILURE,         LAST_FAILURE_TIME, MAX_TASK_LATENCY, MIN_TASK_LATENCY,         TOTAL_TASK_LATENCY, TOTAL_TASKS_EXECUTED, MAX_SERVERS, CON_ID  from GV$QMON_COORDINATOR_STATS where INST_ID = USERENV('Instance')
+++V$QMON_SERVER_STATS+++             select QMNC_PID, SERVER_PID, SERVER_NAME, STATUS, SERVER_START_TIME,         TASK_NAME, TASK_NUMBER, TASK_START_TIME, LAST_WAIT_TIME,         MAX_LATENCY, MIN_LATENCY, TOTAL_LATENCY,         NUM_TASKS, LAST_FAILURE, LAST_FAILURE_TIME, LAST_FAILURE_TASK,         LAST_FAILURE_TASKNUM, CON_ID  from GV$QMON_SERVER_STATS where INST_ID = USERENV('Instance')
+++V$QMON_TASKS+++                    select TASK_NAME, TASK_NUMBER, TASK_TYPE, TASK_SUBMIT_TIME,         TASK_READY_TIME, TASK_EXPIRY_TIME, TASK_START_TIME, TASK_STATUS,         SERVER_NAME, MAX_RETRIES, NUM_RUNS, NUM_FAILURES, CON_ID  from GV$QMON_TASKS where INST_ID = USERENV('Instance')
+++V$QMON_TASK_STATS+++               select TASK_NAME, TASK_TYPE, LAST_CREATED_TASKNUM, NUM_TASKS,         TOTAL_TASK_RUN_TIME, TOTAL_TASK_RUNS, TOTAL_TASK_FAILURES,         METRIC_TYPE, METRIC_VALUE, LAST_FAILURE, LAST_FAILURE_TIME,         LAST_FAILURE_TASKNUM, REMARK, CON_ID  from GV$QMON_TASK_STATS where INST_ID = USERENV('Instance')
+++V$QPX_INVENTORY+++                 select NODE_NAME,        CON_ID   from X$KQPXINV where INST_ID = USERENV('Instance')
+++V$QUEUE+++                         select  PADDR , TYPE , QUEUED , WAIT , TOTALQ, CON_ID from GV$QUEUE where inst_id = USERENV('Instance')
+++V$QUEUEING_MTH+++                  select name, con_id from gv$queueing_mth          where inst_id = userenv('instance')
+++V$RECOVERY_AREA_USAGE+++           select fusg.file_type,                                                           decode(nvl2(ra.name, ra.space_limit, 0), 0, 0,                                   round(nvl(fusg.space_used, 0)/ra.space_limit, 4)                          * 100),                                                            decode(nvl2(ra.name, ra.space_limit, 0), 0, 0,                                   round(nvl(fusg.space_reclaimable, 0)/ra.space_limit, 4)                   * 100),                                                            nvl2(ra.name, fusg.number_of_files, 0), ra.con_id                  from v$recovery_file_dest ra,                                                  (select 'CONTROL FILE'                 file_type,                                 sum(case when ceilasm = 1 and name like '+%'                                  then                                                                         ceil(((block_size*file_size_blks)+1)/1048576)*1048576                  else                                                                         block_size*file_size_blks                                              end)                       space_used,                                0                              space_reclaimable,                         count(*)                       number_of_files                       from v$controlfile,                                                            (select /*+ no_merge */ ceilasm from x$krasga)                      where is_recovery_dest_file = 'YES'                                      union all                                                                 select 'REDO LOG'                     file_type,                                 sum(case when ceilasm = 1 and member like '+%'                                then                                                                         ceil((l.bytes+1)/1048576)*1048576                                      else                                                                         l.bytes                                                                end)                       space_used,                                0                              space_reclaimable,                         count(*)                       number_of_files                       from (select group#, bytes from v$log                                           union                                                                     select group#, bytes from v$standby_log) l, v$logfile lf,                (select /*+ no_merge */ ceilasm from x$krasga)                      where l.group# = lf.group#                                                  and lf.is_recovery_dest_file = 'YES'                                   union all                                                                 select 'ARCHIVED LOG'                 file_type,                                 sum(al.file_size)              space_used,                                sum(case when dl.rectype = 11 then al.file_size                                    else 0 end)           space_reclaimable,                         count(*)                       number_of_files                       from (select recid,                                                                    case when ceilasm = 1 and name like '+%'                                  then                                                                         ceil(((blocks*block_size)+1)/1048576)*1048576                          else                                                                         blocks * block_size                                                    end file_size                                                        from v$archived_log,                                                           (select /*+ no_merge */ ceilasm from x$krasga)                      where is_recovery_dest_file = 'YES'                                         and name is not null) al,
+++V$RECOVERY_FILE_DEST+++            select rdi.location, rdi.slimit, (rdi.sused + rdi.scfile), rdi.srecl+client.srecl, rdi.fcnt, rdi.con_id from x$kccrdi rdi, (select sum(recl) srecl   from (select 0 recl from dual          union         select to_number(fblogreclsiz) recl          from x$krfblog         where rownum = 1         union        select sum(case when ceilasm = 1 and rlnam like '+%'                   then ceil(((rlbct*rlbsz)+1)/1048576)*1048576                    else rlbct*rlbsz                   end) recl          from x$kccrl, (select /*+ no_merge */ ceilasm from x$krasga)         where bitand(rlfl2, 64) = 64           and (bitand(rlfl2, 4096) = 4096 or bitand(rlfl2, 8192) = 8192)           and rlnam is not null)) client
+++V$RECOVERY_FILE_STATUS+++          select  FILENUM , FILENAME , STATUS, CON_ID from GV$RECOVERY_FILE_STATUS where inst_id = USERENV('Instance')
+++V$RECOVERY_LOG+++                  select  THREAD# , SEQUENCE# , TIME , ARCHIVE_NAME, CON_ID from GV$RECOVERY_LOG where inst_id = USERENV('Instance')
+++V$RECOVERY_PROGRESS+++             select START_TIME, TYPE, ITEM, UNITS, SOFAR, TOTAL, TIMESTAMP, COMMENTS, CON_ID from GV$RECOVERY_PROGRESS where inst_id = USERENV('Instance')
+++V$RECOVERY_STATUS+++               select  RECOVERY_CHECKPOINT , THREAD , SEQUENCE_NEEDED , SCN_NEEDED , TIME_NEEDED , PREVIOUS_LOG_NAME , PREVIOUS_LOG_STATUS , REASON, CON_ID from GV$RECOVERY_STATUS where inst_id = USERENV('Instance')
+++V$RECOVER_FILE+++                  select  FILE# , "ONLINE" , ONLINE_STATUS, ERROR , CHANGE# , TIME, CON_ID from GV$RECOVER_FILE where inst_id = USERENV('Instance')
+++V$REDO_DEST_RESP_HISTOGRAM+++      select DEST_ID,  TIME,  DURATION,  FREQUENCY,  CON_ID  from GV$REDO_DEST_RESP_HISTOGRAM  where inst_id = USERENV('Instance')
+++V$REPLAY_CONTEXT+++                select context_id,sid,endianness,protocol_version,context_size,        sql_hash,database_id,env_hash,timezone,checksum,        scn,reset_log_scn,reset_log_counter,unique_sequences_captured,        sequence_values_captured,sequence_values_replayed,        sysdate_values_captured,sysdate_values_replayed,        systimestamp_values_captured,systimestamp_values_replayed,        sysguid_values_captured,sysguid_values_replayed,        lobs_captured,lobs_replayed,con_id  from GV$REPLAY_CONTEXT where inst_id = USERENV('Instance')
+++V$REPLAY_CONTEXT_LOB+++            select context_id,lob_id,lob_version_base,lob_version_wrap,matched, con_id         from GV$REPLAY_CONTEXT_LOB where inst_id = USERENV('Instance')
+++V$REPLAY_CONTEXT_SEQUENCE+++       select context_id, sequence_hash, values_captured, values_replayed,        sequence_start_value, con_id from  GV$REPLAY_CONTEXT_SEQUENCE where inst_id = USERENV('Instance')
+++V$REPLAY_CONTEXT_SYSDATE+++        select context_id, sysdate_value, replayed, con_id from  GV$REPLAY_CONTEXT_SYSDATE where inst_id = USERENV('Instance')
+++V$REPLAY_CONTEXT_SYSGUID+++        select context_id, sysguid_value, replayed, con_id from  GV$REPLAY_CONTEXT_SYSGUID where inst_id = USERENV('Instance')
+++V$REPLAY_CONTEXT_SYSTIMESTAMP+++   select context_id, systimestamp_value, replayed, con_id from  GV$REPLAY_CONTEXT_SYSTIMESTAMP where inst_id = USERENV('Instance')
+++V$REPLPROP+++                      SELECT SID, SERIAL#, NAME, DBLINK, STATE, XID, SEQUENCE, CON_ID FROM GV$REPLPROP WHERE INST_ID = USERENV('Instance')
+++V$REPLQUEUE+++                     SELECT TXNS_ENQUEUED, CALLS_ENQUEUED, TXNS_PURGED, LAST_ENQUEUE_TIME, LAST_PURGE_TIME, CON_ID FROM GV$REPLQUEUE WHERE INST_ID = USERENV('Instance')
+++V$REQDIST+++                       select  BUCKET , COUNT, CON_ID from GV$REQDIST where inst_id = USERENV('Instance')
+++V$RESERVED_WORDS+++                select KEYWORD, LENGTH,          RESERVED, RES_TYPE, RES_ATTR, RES_SEMI, DUPLICATE, CON_ID          from GV$RESERVED_WORDS where inst_id = USERENV('Instance')
+++V$RESOURCE+++                      select  ADDR , TYPE , ID1 , ID2, CON_ID from GV$RESOURCE where inst_id = USERENV('Instance')
+++V$RESOURCE_LIMIT+++                select RESOURCE_NAME, CURRENT_UTILIZATION, MAX_UTILIZATION,  INITIAL_ALLOCATION, LIMIT_VALUE, CON_ID from GV$RESOURCE_LIMIT where inst_id = USERENV('Instance')
+++V$RESTORE_POINT+++                 select SCN, DATABASE_INCARNATION#, GUARANTEE_FLASHBACK_DATABASE,          STORAGE_SIZE, TIME, RESTORE_POINT_TIME, PRESERVED, NAME, CON_ID         from GV$RESTORE_POINT         where inst_id = USERENV('Instance')
+++V$RESULT_CACHE_DEPENDENCY+++       select  RESULT_ID,        DEPEND_ID,        OBJECT_NO,         CON_ID from GV$RESULT_CACHE_DEPENDENCY where inst_id=USERENV('Instance')
+++V$RESULT_CACHE_DR+++               select  OBJECT_NO,         CON_ID from GV$RESULT_CACHE_DR where inst_id=USERENV('Instance')
+++V$RESULT_CACHE_MEMORY+++           select  ID,        CHUNK,        OFFSET,        FREE,        OBJECT_ID,        POSITION,         CON_ID from GV$RESULT_CACHE_MEMORY where inst_id=USERENV('Instance')
+++V$RESULT_CACHE_OBJECTS+++          select  ID,        TYPE,        STATUS,        BUCKET_NO,        HASH,        NAME,        NAMESPACE,        CREATION_TIMESTAMP,        CREATOR_UID,        DEPEND_COUNT,        BLOCK_COUNT,        SCN,        COLUMN_COUNT,        PIN_COUNT,        SCAN_COUNT,        ROW_COUNT,        ROW_SIZE_MAX,        ROW_SIZE_MIN,        ROW_SIZE_AVG,        BUILD_TIME,        LRU_NUMBER,        OBJECT_NO,        INVALIDATIONS,        SPACE_OVERHEAD,        SPACE_UNUSED,        CACHE_ID,        CACHE_KEY,         CHECKSUM,        EDITION_ID,        DB_LINK,        CON_ID from GV$RESULT_CACHE_OBJECTS where inst_id=USERENV('Instance')
+++V$RESULT_CACHE_RD+++               select  KEY,             BLK_NUM,         BLK_SEQ,         BLK_DAT,         CON_ID from GV$RESULT_CACHE_RD where inst_id=USERENV('Instance')
+++V$RESULT_CACHE_RR+++               select  HSV1,         HSV2,         CON_ID from GV$RESULT_CACHE_RR where inst_id=USERENV('Instance')
+++V$RESULT_CACHE_STATISTICS+++       select  ID,        NAME,        VALUE,         CON_ID from GV$RESULT_CACHE_STATISTICS where inst_id=USERENV('Instance')
+++V$RESUMABLE+++                     select ADDR, SID, ENABLED, STATUS, TIMEOUT, SUSPEND_TIME, RESUME_TIME, NAME, ERROR_NUMBER, ERROR_PARAMETER1, ERROR_PARAMETER2, ERROR_PARAMETER3, ERROR_PARAMETER4, ERROR_PARAMETER5, ERROR_MSG, CON_ID from GV$RESUMABLE where inst_id = USERENV('Instance')
+++V$RFS_THREAD+++                    select THREAD#, RESETLOGS_CHANGE#, RESET_TIMESTAMP, LAST_REDO_SEQ#, LAST_REDO_BLK#, LAST_REDO_TIME, LOW_GAP_SCN, LOW_GAP_TIME, LAST_PING_TIME, CON_ID FROM gv$RFS_THREAD where INST_ID = USERENV('INSTANCE')
+++V$RMAN_BACKUP_JOB_DETAILS+++       select /*+ rule */ a.*,   sys.dbms_rcvman.num2displaysize(input_bytes)  input_bytes_display,   sys.dbms_rcvman.num2displaysize(output_bytes)  output_bytes_display,    sys.dbms_rcvman.num2displaysize(input_bytes_per_sec)          input_bytes_per_sec_display,   sys.dbms_rcvman.num2displaysize(output_bytes_per_sec)          output_bytes_per_sec_display,    sys.dbms_rcvman.sec2displaytime(elapsed_seconds) time_taken_display, 1 from (select unique a.session_recid session_key, a.*,    decode(autobackup_count, 0, 'NO', 'YES') autobackup_done,    decode(status_weight, 2000, 'FAILED',                          1900, 'RUNNING WITH ERRORS',                          1500, 'RUNNING WITH WARNINGS',                          1001, 'RUNNING',                           900, 'COMPLETED WITH ERRORS',                           500, 'COMPLETED WITH WARNINGS',                           001, 'COMPLETED',                           'FAILED') status,    decode(object_type_weight,9, 'DB FULL',                              8, 'RECVR AREA',                              7, 'DB INCR',                              6, 'DATAFILE FULL',                              5, 'DATAFILE INCR',                              4, 'ARCHIVELOG',                              3, 'CONTROLFILE',                              2, 'SPFILE',                              1, 'BACKUPSET', null) input_type,    decode(optimized_weight, 1, 'YES', 'NO') optimized,   abs(a.end_time-a.start_time)*86400 elapsed_seconds,   case when a.input_bytes/decode(a.output_bytes,0,null, a.output_bytes) > 1   then a.input_bytes/decode(a.output_bytes,0,null, a.output_bytes) else 1 end      compression_ratio,   a.input_bytes/(decode(a.end_time-a.start_time, 0, 1,      abs(a.end_time-a.start_time)*86400)) input_bytes_per_sec,   a.output_bytes/(decode(a.end_time-a.start_time, 0, 1,      abs(a.end_time-a.start_time)*86400)) output_bytes_per_sec        from  (select session_recid, session_stamp, command_id,        min(start_time) over           (partition by session_recid, session_stamp) start_time,        max(end_time) over            (partition by session_recid, session_stamp) end_time,        sum(input_bytes) over            (partition by session_recid, session_stamp) input_bytes,        sum(output_bytes) over            (partition by session_recid, session_stamp) output_bytes,        max(status_weight) over            (partition by session_recid, session_stamp)status_weight,        max(optimized_weight) over            (partition by session_recid, session_stamp)            optimized_weight,        max(object_type_weight) over            (partition by session_recid, session_stamp)            object_type_weight,        decode(count(distinct output_device_type) over                   (partition by session_recid, session_stamp),1,              first_value(output_device_type) over                   (partition by session_recid, session_stamp),0,              null, '*') output_device_type,        sum(autobackup_count) over            (partition by session_recid, session_stamp) autobackup_count,        backed_by_osb   from V$RMAN_BACKUP_SUBJOB_DETAILS) a)a
+++V$RMAN_BACKUP_SUBJOB_DETAILS+++    select a.session_recid session_key, a.*,    decode(nvl(b.autocnt,0), 0, 'NO', 'YES') autobackup_done,    decode(status_weight, 2000, 'FAILED',                          1900, 'RUNNING WITH ERRORS',                          1500, 'RUNNING WITH WARNINGS',                          1001, 'RUNNING',                           900, 'COMPLETED WITH ERRORS',                           500, 'COMPLETED WITH WARNINGS',                           001, 'COMPLETED',                           'FAILED') status,    decode(object_type_weight,9, 'DB FULL',                              8, 'RECVR AREA',                              7, 'DB INCR',                              6, 'DATAFILE FULL',                              5, 'DATAFILE INCR',                              4, 'ARCHIVELOG',                              3, 'CONTROLFILE',                              2, 'SPFILE',                              1, 'BACKUPSET', null) object_type,    decode(optimized_weight, 1, 'YES', 'NO') optimized,    nvl(b.autocnt,0) autobackup_count,    case when input_bytes/decode(output_bytes,0,null, output_bytes) > 1         then input_bytes/decode(output_bytes,0,null, output_bytes) else 1 end      compression_ratio,   sys.dbms_rcvman.num2displaysize(input_bytes)  input_bytes_display,   sys.dbms_rcvman.num2displaysize(output_bytes)  output_bytes_display,    b.con_id  from ( select unique session_recid, session_stamp, operation, command_id,        min(start_time) over           (partition by session_recid, session_stamp, operation) start_time,        max(end_time) over            (partition by session_recid, session_stamp, operation) end_time,        sum(input_bytes) over            (partition by session_recid, session_stamp, operation) input_bytes,        sum(output_bytes) over            (partition by session_recid, session_stamp, operation) output_bytes,        max(status_weight) over            (partition by session_recid, session_stamp, operation)status_weight,        max(object_type_weight) over            (partition by session_recid, session_stamp, operation)            object_type_weight,        max(optimized_weight) over            (partition by session_recid, session_stamp, operation)            optimized_weight,        decode(count(distinct output_device_type) over                   (partition by session_recid, session_stamp, operation),1,              first_value(output_device_type) over                   (partition by session_recid, session_stamp, operation),0,              null, '*') output_device_type,        decode(count(distinct osb_allocated) over                   (partition by session_recid, session_stamp, operation),1,              first_value(osb_allocated) over                   (partition by session_recid, session_stamp, operation),0,              'NO', '*') backed_by_osb        from (select d.*,                  decode(status, 'RUNNING', 1001,                   'RUNNING WITH WARNINGS', 1500,                     'RUNNING WITH ERRORS', 1900,                               'COMPLETED', 0001,                 'COMPLETED WITH WARNINGS', 500,                   'COMPLETED WITH ERRORS', 900,                                  'FAILED', 2000, 2000) status_weight,              decode(object_type, 'DB FULL', 9,                               'RECVR AREA', 8,                                  'DB INCR', 7,                            'DATAFILE FULL', 6,                            'DATAFILE INCR', 5,                               'ARCHIVELOG', 4,                              'CONTROLFILE', 3,                                   'SPFILE', 2,                                'BACKUPSET', 1, 0) object_type_weight,              decode(optimized,'YES', 1, 0) optimized_weight          from          v$rman_status d         where operation like 'BACKUP%' and row_level=1)) a,  ( select session_recid, session_stamp, count(*) autocnt, con_id from v$rman_status     where operation like '%AUTOBACKUP%' and row_level > 1     group by session_recid, session_stamp, con_id ) b  where a.se
+++V$RMAN_BACKUP_TYPE+++                 select 9, 'DB FULL', 0       from dual union    select 8, 'RECVR AREA', 0    from dual union    select 7, 'DB INCR', 0       from dual union   select 6, 'DATAFILE FULL', 0 from dual union    select 5, 'DATAFILE INCR', 0 from dual union    select 4, 'ARCHIVELOG', 0    from dual union    select 3, 'CONTROLFILE', 0   from dual union    select 2, 'SPFILE', 0        from dual union    select 1, 'BACKUPSET', 0     from dual
+++V$RMAN_COMPRESSION_ALGORITHM+++    SELECT algorithm_id, algorithm_name, initial_release, terminal_release, algorithm_description, algorithm_compatibility, is_valid, requires_aco, is_default, con_id FROM gv$rman_compression_algorithm WHERE inst_id = USERENV('Instance')
+++V$RMAN_CONFIGURATION+++            select CONF#, NAME, VALUE, CON_ID from GV$RMAN_CONFIGURATION where inst_id = USERENV('Instance')
+++V$RMAN_ENCRYPTION_ALGORITHMS+++    select algorithm_id, algorithm_name, algorithm_description, is_default, restore_only, con_id from gv$rman_encryption_algorithms where inst_id = USERENV('Instance')
+++V$RMAN_OUTPUT+++                   select SID,RECID,STAMP,SESSION_RECID,SESSION_STAMP,OUTPUT,RMAN_STATUS_RECID, RMAN_STATUS_STAMP, SESSION_RECID, CON_ID  from GV$RMAN_OUTPUT where inst_id = USERENV('Instance')
+++V$RMAN_STATUS+++                   SELECT /*+ LEADING(r2 r1) USE_HASH(r1) */        NVL(r1.sid, 0)      , NVL(r1.recid, r2.rsrrid)      , NVL(r1.stamp, r2.rsrtst)      , DECODE(          NVL(r1.row_level, r2.rsrlv)        , 0, TO_NUMBER(NULL)           , NVL(r1.parent_recid, r2.rsrpi)        )      , DECODE(          NVL(r1.row_level, r2.rsrlv)        , 0, TO_NUMBER(NULL)           , NVL(r1.parent_stamp, r2.rsrps)        )      , DECODE(          NVL(r1.row_level, r2.rsrlv)        , 0, NVL(r1.recid, r2.rsrrid)           , r2.rsr0i        )      , DECODE(          NVL(r1.row_level, r2.rsrlv)        , 0, NVL(r1.stamp, r2.rsrtst)           , r2.rsr0s        )      , NVL(r1.row_level, r2.rsrlv)      , NVL(r1.row_type, DECODE(                           r2.rsrlv                         , 0, 'SESSION'                         , 1, 'COMMAND'                            , 'RECURSIVE OPERATION'                         )        )      , NVL(r1.command_id, r2.rsrci)      , NVL(r1.operation, UPPER(r2.rsrop))      , NVL(r1.status, DECODE(                         BITAND(r2.rsris, 2 + 1)                       , 2, DECODE(r2.rsres                            ,            1, 'RUNNING'                            ,        1 + 8, 'RUNNING WITH WARNINGS'                            ,       1 + 16, 'RUNNING WITH ERRORS'                            ,   1 + 8 + 16, 'RUNNING WITH ERRORS'                            ,            2, 'COMPLETED'                            ,        2 + 8, 'COMPLETED WITH WARNINGS'                            ,       2 + 16, 'COMPLETED WITH ERRORS'                            ,   2 + 8 + 16, 'COMPLETED WITH ERRORS'                                          , 'FAILED'                            )                          , 'FAILED'                       )        )      , DECODE(r2.rsrmp, 0, NVL(r1.mbytes, 0), r2.rsrmp)      , NVL(          r1.start_time        , TO_DATE(r2.rsrst, 'MM/DD/RR HH24:MI:SS', 'NLS_CALENDAR=Gregorian')        )      , NVL(          r1.end_time        , TO_DATE(r2.rsret, 'MM/DD/RR HH24:MI:SS', 'NLS_CALENDAR=Gregorian')        )      , DECODE(          r2.rsrim        , 0, NVL(r1.inpbytes, 0)           , DECODE(               BITAND(r2.rsrim, 2147483648)             ,          0, r2.rsrim             , 2147483648, BITAND(r2.rsrim, 2147483647) * 1024 * 1024             )        )      , DECODE(          r2.rsrom        , 0, NVL(r1.outbytes, 0)           , DECODE(               BITAND(r2.rsrom, 2147483648)             ,          0, r2.rsrom             , 2147483648, BITAND(r2.rsrom, 2147483647) * 1024 * 1024             )        )      , DECODE(BITAND(r2.rsrfl, 32), 1, 'YES', 'NO')      , CASE          WHEN BITAND(r2.rsrfl, 1 + 128) =   1 THEN 'DB FULL'          WHEN BITAND(r2.rsrfl,      64) =  64 THEN 'RECVR AREA'          WHEN BITAND(r2.rsrfl, 1 + 128) = 129 THEN 'DB INCR'          WHEN BITAND(r2.rsrfl, 2 + 128) =   2 THEN 'DATAFILE FULL'          WHEN BITAND(r2.rsrfl, 2 + 128) = 130 THEN 'DATAFILE INCR'          WHEN BITAND(r2.rsrfl,       4) =   4 THEN 'ARCHIVELOG'          WHEN BITAND(r2.rsrfl,       8) =   8 THEN 'CONTROLFILE'          WHEN BITAND(r2.rsrfl,      16) =  16 THEN 'SPFILE'          WHEN BITAND(r2.rsrfl,     256) = 256 THEN 'BACKUPSET'        END      , DECODE(          BITAND(r2.rsris, 32 + 16 + 8 + 4)        ,  0, r1.device_type        ,  4, 'DISK'        ,  8, 'SBT_TAPE'        , 16, '*'        ) device_type      , DECODE(BITAND(r2.rsrfl, 512), 512, 'YES', 'NO') osb      , r2.con_id   FROM x$kccrsr r2      , (        SELECT r.sid, r.recid, r.stamp, r.row_level, r.parent_recid             , r.parent_stamp, r.row_type, r.command_id, r.operation             , r.status, r.start_time, r.end_time             , hh.device_type, hh.mbytes, hh.inpbytes, hh.outbytes          FROM gv$rman_status_current r             , (               SELECT rman_status_recid                    , rman_status_stamp                    , CASE                        WHEN MIN(CASE WHEN type = 2 THEN devtype END) IS NULL                        THEN NULL
+++V$ROLLSTAT+++                      select  USN , LATCH, EXTENTS , RSSIZE , WRITES , XACTS , GETS , WAITS , OPTSIZE , HWMSIZE , SHRINKS , WRAPS , EXTENDS , AVESHRINK , AVEACTIVE , STATUS , CUREXT , CURBLK, CON_ID from GV$ROLLSTAT where inst_id = USERENV('Instance')
+++V$ROWCACHE+++                      select cache#,type,subordinate#,parameter,count,usage,fixed, gets,fastgets,getmisses,scans,scanmisses,scancompletes,modifications,flushes,dlm_requests,dlm_conflicts,dlm_releases, con_id from gv$rowcache where inst_id = USERENV('Instance')
+++V$ROWCACHE_PARENT+++               select indx, hash, address, cache#, cache_name, existent, lock_mode, lock_request,  txn, saddr, inst_lock_request, inst_lock_release, inst_lock_type, inst_lock_id1,  inst_lock_id2, key, con_id from gv$rowcache_parent  where inst_id = USERENV('Instance')
+++V$ROWCACHE_SUBORDINATE+++          select indx, hash, address, cache#, subcache#, subcache_name,  existent, parent, key, con_id from gv$rowcache_subordinate  where inst_id = USERENV('Instance')
+++V$RO_USER_ACCOUNT+++               SELECT USERID, PASSW_EXPIRED, PASSW_IN_GRACE, PASSW_LOCKED, PASSW_LOCK_UNLIM, FAILED_LOGINS, EXPIRATION_AFTER_GRACE, PASSW_LOCK_TIME, CON_ID FROM GV$RO_USER_ACCOUNT where inst_id = USERENV('Instance')
+++V$RSRCMGRMETRIC+++                 SELECT begin_time, end_time, intsize_csec,                 sequence#, consumer_group_id, consumer_group_name,                 cpu_consumed_time, cpu_wait_time,                 num_cpus, running_sessions_limit, avg_running_sessions,                 avg_waiting_sessions,                 cpu_utilization_limit, avg_cpu_utilization,                 0, 0, 0,                 io_requests, io_megabytes,                 avg_active_parallel_stmts, avg_queued_parallel_stmts,                 avg_active_parallel_servers, avg_queued_parallel_servers,                 parallel_servers_limit, plan_name, con_id          FROM   gv$rsrcmgrmetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$RSRCMGRMETRIC_HISTORY+++         SELECT begin_time, end_time, intsize_csec,                 sequence#, consumer_group_id, consumer_group_name,                 cpu_consumed_time, cpu_wait_time,                 num_cpus, running_sessions_limit, avg_running_sessions,                 avg_waiting_sessions,                 cpu_utilization_limit, avg_cpu_utilization,                 0, 0, 0,                 io_requests, io_megabytes,                 avg_active_parallel_stmts, avg_queued_parallel_stmts,                 avg_active_parallel_servers, avg_queued_parallel_servers,                 parallel_servers_limit, plan_name, con_id          FROM   gv$rsrcmgrmetric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$RSRC_CONSUMER_GROUP+++           select id, name, active_sessions, execution_waiters, requests,          cpu_wait_time, cpu_waits, consumed_cpu_time, yields,          cpu_decisions, cpu_decisions_exclusive,          cpu_decisions_won,         queue_length, current_undo_consumption, active_session_limit_hit,          undo_limit_hit,          switches_in_cpu_time, switches_out_cpu_time,          switches_in_io_megabytes, switches_out_io_megabytes,          switches_in_io_requests, switches_out_io_requests,          switches_in_io_logical, switches_out_io_logical,          switches_in_elapsed_time, switches_out_elapsed_time,          sql_canceled, active_sessions_killed, idle_sessions_killed,          idle_blkr_sessions_killed, queued_time, queue_time_outs,          io_service_time, io_service_waits,          small_read_megabytes, small_write_megabytes,          large_read_megabytes, large_write_megabytes,          small_read_requests, small_write_requests,          large_read_requests, large_write_requests,          current_pqs_active, current_pq_servers_active,          pqs_queued, pqs_completed,          pq_servers_used, pq_active_time, current_pqs_queued,          pq_queued_time, pq_queue_time_outs, con_id          from gv$rsrc_consumer_group          where inst_id = userenv('instance')
+++V$RSRC_CONSUMER_GROUP_CPU_MTH+++   select name, con_id from gv$rsrc_consumer_group_cpu_mth          where inst_id = userenv('instance')
+++V$RSRC_CONS_GROUP_HISTORY+++       select sequence#, id, name, requests,          cpu_wait_time, cpu_waits, consumed_cpu_time, yields,          cpu_decisions, cpu_decisions_exclusive,          cpu_decisions_won,          active_sess_limit_hit, undo_limit_hit,          switches_in_cpu_time, switches_out_cpu_time,          switches_in_io_megabytes, switches_out_io_megabytes,          switches_in_io_requests, switches_out_io_requests,          switches_in_io_logical, switches_out_io_logical,          switches_in_elapsed_time, switches_out_elapsed_time,          sql_canceled,          active_sess_killed, idle_sess_killed, idle_blkr_sess_killed,          queued_time, queue_time_outs,          io_service_time, io_service_waits,          small_read_megabytes, small_write_megabytes,          large_read_megabytes, large_write_megabytes,          small_read_requests, small_write_requests,          large_read_requests, large_write_requests,          pqs_completed, pq_servers_used, pqs_queued,          pq_active_time, pq_queued_time, pq_queue_time_outs, con_id          from gv$rsrc_cons_group_history          where inst_id = userenv('instance')
+++V$RSRC_PLAN+++                     select id, name, is_top_plan, cpu_managed, instance_caging,          parallel_servers_active,          parallel_servers_total, parallel_execution_managed, con_id,          directive_type, shares, utilization_limit, parallel_server_limit,          memory_min, memory_limit, profile          from gv$rsrc_plan          where inst_id = userenv('instance')
+++V$RSRC_PLAN_CPU_MTH+++             select name, con_id from gv$rsrc_plan_cpu_mth          where inst_id = userenv('instance')
+++V$RSRC_PLAN_HISTORY+++             select sequence#, id, name,          start_time, end_time,          enabled_by_scheduler, window_name, allowed_automated_switches,          cpu_managed, instance_caging, parallel_execution_managed, con_id          from gv$rsrc_plan_history          where inst_id = userenv('instance')
+++V$RSRC_SESSION_INFO+++             select  sid, current_consumer_group_id, current_consumer_group,          orig_consumer_group_id,          mapping_attribute, mapped_consumer_group,          state, active, current_idle_time,          current_cpu_wait_time, cpu_wait_time, current_cpu_waits, cpu_waits,          current_consumed_cpu_time, consumed_cpu_time,          current_active_time,          active_time, current_queued_time, queued_time, current_yields,          yields, current_undo_consumption, max_undo_consumption,          sql_canceled, queue_time_outs, estimated_execution_limit_hit,          current_io_service_time, io_service_time,          current_io_service_waits, io_service_waits,          current_small_read_megabytes, small_read_megabytes,          current_large_read_megabytes, large_read_megabytes,          current_small_write_megabytes, small_write_megabytes,          current_large_write_megabytes, large_write_megabytes,          current_small_read_requests, small_read_requests,          current_small_write_requests, small_write_requests,          current_large_read_requests, large_read_requests,          current_large_write_requests, large_write_requests,          current_pq_active_time, pq_active_time,          dop, pq_servers, estimated_execution_time,          current_pq_queued_time, pq_queued_time, pq_queued,          pq_queue_time_outs, pq_active, pq_status,          current_logical_ios, logical_ios,          current_elapsed_time, elapsed_time,          last_action, last_action_reason, last_action_time, con_id          from gv$rsrc_session_info          where inst_id = userenv('instance')
+++V$RT_ADDM_CONTROL+++               SELECT ID, IMPACT, CANDIDATE, LASTTIME,          CON_ID FROM GV$RT_ADDM_CONTROL          WHERE INST_ID = USERENV('Instance')
+++V$RULE+++                          select RULE_SET_OBJECT_ID, EVALUATION_CONTEXT_OBJECT_ID, RULE_OWNER,  RULE_NAME, RULE_CONDITION, TRUE_HITS, MAYBE_HITS, SQL_EVALUATIONS, CON_ID  from GV$RULE  where inst_id = USERENV('Instance')
+++V$RULE_SET+++                      select OWNER, NAME, CPU_TIME, ELAPSED_TIME, FIRST_LOAD_TIME, LAST_LOAD_TIME,  LAST_LOADING_TIME, SHARABLE_MEM, RELOADS, INVALIDATIONS,  EVALUATIONS, FIRST_HIT_EVALUATIONS, SIMPLE_RULES_ONLY_EVALUATIONS,  SQL_FREE_EVALUATIONS, SQL_EXECUTIONS, CONDITIONS_PROCESSED,  TRUE_RULES, MAYBE_RULES, VARIABLE_VALUE_FUNCTION_CALLS,  VARIABLE_METHOD_FUNCTION_CALLS, EVALUATION_FUNCTION_CALLS,  RESULT_CACHE_HITS, IS_RESULT_CACHE, RESULT_CACHE_ELEMENTS, CON_ID  from GV$RULE_SET  where inst_id = USERENV('Instance')
+++V$RULE_SET_AGGREGATE_STATS+++      select NAME, VALUE, CON_ID from GV$RULE_SET_AGGREGATE_STATS  where inst_id = USERENV('Instance')
+++V$SCHEDULER_INMEM_MDINFO+++        SELECT OBJID, PRGOID, LAST_ENABLED_TIME, CLSOID, INSTANCE_ID,         FLAGS, CREATOR, CLIENT_ID, GUID, CON_ID FROM GV$SCHEDULER_INMEM_MDINFO          WHERE INST_ID = USERENV('Instance')
+++V$SCHEDULER_INMEM_RTINFO+++        SELECT USERID, OBJID, ID_TYPE, NAME, NEXT_RUN_DATE, LAST_START_DATE,         LAST_END_DATE,         RUN_COUNT, FAILURE_COUNT, RUNNING_INSTANCE, RUNNING_SLAVE,         JOB_STATUS, CON_ID FROM GV$SCHEDULER_INMEM_RTINFO          WHERE INST_ID = USERENV('Instance')
+++V$SCHEDULER_RUNNING_JOBS+++        select session_id,  session_serial_num, job_id, paddr,  os_process_id, session_stat_cpu, con_id   from gv$scheduler_running_jobs where   inst_id = USERENV('Instance')
+++V$SECUREFILE_TIMER+++              SELECT NAME, LAYER_ID, OWNTIME, MAXTIME, MINTIME, INVOCATIONS, LAYER_NAME, CON_ID FROM GV$SECUREFILE_TIMER
+++V$SEGMENT_STATISTICS+++            select owner,                                                 object_name,                                           subobject_name,                                        tablespace_name,                                       ts#,                                                   obj#,                                                  dataobj#,                                              object_type,                                           statistic_name,                                        statistic#,                                            value,                                                 con_id                                          from  gv$segment_statistics                            where inst_id = userenv('instance')
+++V$SEGSPACE_USAGE+++                SELECT TBS_ID, RFNO, bno, objd, USED_SPACE,          uspscnbase, uspscnwrap, usptime,          ctime, total_alloc, total_dealloc,          delta_alloc, delta_dealloc, deltascn_base, deltascn_wrap,          deltaupd_time, delta_count, df_count, flag, con_id          FROM GV$SEGSPACE_USAGE WHERE INST_ID = USERENV('INSTANCE')
+++V$SEGSTAT+++                       select ts#,                                                    obj#,                                                   dataobj#,                                               statistic_name,                                         statistic#,                                             value,                                                  con_id                                           from  gv$segstat where inst_id = userenv('instance')
+++V$SEGSTAT_NAME+++                  select statistic#,                                           name,                                                 sampled,                                              con_id                                         from gv$segstat_name                                  where inst_id = userenv('instance')
+++V$SERVICEMETRIC+++                 SELECT begin_time, end_time, intsize_csec,            group_id, service_name_hash, service_name,            ctmhash, elapsedpercall, cpupercall, dbtimepercall,            callspersec, dbtimepersec, goodness, delta, flags, con_id          FROM   gv$servicemetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$SERVICEMETRIC_HISTORY+++         SELECT begin_time, end_time, intsize_csec,            group_id, service_name_hash, service_name,            ctmhash, elapsedpercall, cpupercall, dbtimepercall,            callspersec, dbtimepersec, con_id          FROM   gv$servicemetric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$SERVICES+++                      select SERVICE_ID, NAME, NAME_HASH, NETWORK_NAME, CREATION_DATE, CREATION_DATE_HASH, GOAL, DTP,  AQ_HA_NOTIFICATION, CLB_GOAL,  COMMIT_OUTCOME, RETENTION_TIME, REPLAY_INITIATION_TIMEOUT,  SESSION_STATE_CONSISTENCY,  GLOBAL, PDB, SQL_TRANSLATION_PROFILE, MAX_LAG_TIME,  CON_ID  from GV$SERVICES where inst_id = USERENV('Instance')
+++V$SERVICE_EVENT+++                 select service_name, service_name_hash,event,event_id, total_waits, total_timeouts, time_waited,average_wait, max_wait,time_waited_micro, con_id  from gv$service_event where inst_id = USERENV('Instance')
+++V$SERVICE_STATS+++                 select SERVICE_NAME_HASH , SERVICE_NAME , STAT_ID ,  STAT_NAME , VALUE, CON_ID from GV$SERVICE_STATS  where inst_id = USERENV('Instance')
+++V$SERVICE_WAIT_CLASS+++            select service_name, service_name_hash,wait_class_id, wait_class#,  wait_class,total_waits, time_waited, con_id  from gv$service_wait_class where inst_id = USERENV('Instance')
+++V$SERV_MOD_ACT_STATS+++            select AGGREGATION_TYPE, SERVICE_NAME, MODULE, ACTION, STAT_ID,    STAT_NAME, VALUE, CON_ID from GV$SERV_MOD_ACT_STATS  where inst_id = USERENV('Instance')
+++V$SESSION+++                       select  SADDR , SID , SERIAL# , AUDSID , PADDR , USER# , USERNAME , COMMAND , OWNERID, TADDR , LOCKWAIT , STATUS , SERVER , SCHEMA# , SCHEMANAME ,OSUSER , PROCESS , MACHINE , PORT ,  TERMINAL , PROGRAM , TYPE , SQL_ADDRESS , SQL_HASH_VALUE, SQL_ID, SQL_CHILD_NUMBER , SQL_EXEC_START, SQL_EXEC_ID, PREV_SQL_ADDR , PREV_HASH_VALUE , PREV_SQL_ID, PREV_CHILD_NUMBER , PREV_EXEC_START , PREV_EXEC_ID , PLSQL_ENTRY_OBJECT_ID, PLSQL_ENTRY_SUBPROGRAM_ID, PLSQL_OBJECT_ID, PLSQL_SUBPROGRAM_ID, MODULE , MODULE_HASH , ACTION , ACTION_HASH , CLIENT_INFO , FIXED_TABLE_SEQUENCE , ROW_WAIT_OBJ# , ROW_WAIT_FILE# , ROW_WAIT_BLOCK# , ROW_WAIT_ROW# , TOP_LEVEL_CALL#,  LOGON_TIME ,  LAST_CALL_ET , PDML_ENABLED , FAILOVER_TYPE , FAILOVER_METHOD , FAILED_OVER, RESOURCE_CONSUMER_GROUP, PDML_STATUS, PDDL_STATUS, PQ_STATUS, CURRENT_QUEUE_DURATION, CLIENT_IDENTIFIER, BLOCKING_SESSION_STATUS, BLOCKING_INSTANCE, BLOCKING_SESSION, FINAL_BLOCKING_SESSION_STATUS, FINAL_BLOCKING_INSTANCE, FINAL_BLOCKING_SESSION, SEQ#, EVENT#,EVENT,P1TEXT,P1,P1RAW,P2TEXT,P2,P2RAW, P3TEXT,P3,P3RAW,WAIT_CLASS_ID, WAIT_CLASS#,WAIT_CLASS,WAIT_TIME, SECONDS_IN_WAIT,STATE,WAIT_TIME_MICRO,TIME_REMAINING_MICRO, TIME_SINCE_LAST_WAIT_MICRO,SERVICE_NAME, SQL_TRACE, SQL_TRACE_WAITS, SQL_TRACE_BINDS, SQL_TRACE_PLAN_STATS, SESSION_EDITION_ID, CREATOR_ADDR, CREATOR_SERIAL#, ECID, SQL_TRANSLATION_PROFILE_ID, PGA_TUNABLE_MEM, CON_ID, EXTERNAL_NAME  from GV$SESSION where inst_id = USERENV('Instance')
+++V$SESSIONS_COUNT+++                select            CON_ID, CURRENT_COUNT          from GV$SESSIONS_COUNT where INST_ID = USERENV('Instance')
+++V$SESSION_BLOCKERS+++              select  sid,  sess_serial#,  wait_id,  wait_event,  wait_event_text,  blocker_instance_id,  blocker_sid,  blocker_sess_serial#,  con_id  from gv$session_blockers  where inst_id = USERENV('Instance')
+++V$SESSION_CLIENT_RESULT_CACHE+++    select SID, SERIAL#, CSOADDR, CACHE_ID, CON_ID    from GV$SESSION_CLIENT_RESULT_CACHE       where inst_id=USERENV('Instance')
+++V$SESSION_CONNECT_INFO+++          select sid,serial#,authentication_type,osuser,network_service_banner,   client_charset,client_connection,client_oci_library,client_version,  client_driver, client_lobattr, client_regid, con_id   from gv$session_connect_info where inst_id = USERENV('Instance')
+++V$SESSION_CURSOR_CACHE+++          select  MAXIMUM , COUNT , OPENS , HITS , HIT_RATIO, CON_ID from GV$SESSION_CURSOR_CACHE where inst_id = USERENV('Instance')
+++V$SESSION_EVENT+++                 select sid,event,total_waits,total_timeouts,time_waited,average_wait, max_wait,time_waited_micro, event_id, wait_class_id,wait_class#,  wait_class, con_id  from gv$session_event where inst_id = USERENV('Instance')
+++V$SESSION_FIX_CONTROL+++           select  SESSION_ID,        BUGNO,        VALUE,        SQL_FEATURE,        DESCRIPTION,        OPTIMIZER_FEATURE_ENABLE,        EVENT,        IS_DEFAULT,         CON_ID from GV$SESSION_FIX_CONTROL where inst_id=USERENV('Instance')
+++V$SESSION_LONGOPS+++               select SID, SERIAL#, OPNAME, TARGET, TARGET_DESC,                                    SOFAR, TOTALWORK, UNITS, START_TIME, LAST_UPDATE_TIME,                        TIMESTAMP, TIME_REMAINING, ELAPSED_SECONDS, CONTEXT, MESSAGE,                 USERNAME, SQL_ADDRESS, SQL_HASH_VALUE, SQL_ID,                                SQL_PLAN_HASH_VALUE, SQL_EXEC_START, SQL_EXEC_ID,                             SQL_PLAN_LINE_ID, SQL_PLAN_OPERATION, SQL_PLAN_OPTIONS, QCSID,                CON_ID                                                                    from GV$SESSION_LONGOPS                                                       where inst_id = USERENV('Instance')
+++V$SESSION_OBJECT_CACHE+++          select pins,hits,true_hits,hit_ratio,true_hit_ratio,object_refreshes,cache_refreshes,object_flushes,cache_flushes,cache_shrinks,cached_objects,pinned_objects,cache_size,optimal_size,maximum_size, con_id from gv$session_object_cache where inst_id=userenv('Instance')
+++V$SESSION_WAIT+++                  select sid,seq#,event,p1text,p1,p1raw,p2text,p2,p2raw,p3text, p3,p3raw,wait_class_id, wait_class#,wait_class,wait_time,seconds_in_wait, state,wait_time_micro,time_remaining_micro,  time_since_last_wait_micro, con_id from gv$session_wait where inst_id = USERENV('Instance')
+++V$SESSION_WAIT_CLASS+++            select sid,serial#,wait_class_id, wait_class#,wait_class,total_waits, time_waited, con_id from gv$session_wait_class where inst_id = USERENV('Instance')
+++V$SESSION_WAIT_HISTORY+++          select sid,seq#,event#,event,p1text,p1,p2text,p2,p3text,p3,wait_time, wait_time_micro,time_since_last_wait_micro, con_id from gv$session_wait_history  where inst_id = USERENV('Instance')
+++V$SESSMETRIC+++                    SELECT begin_time, end_time, intsize_csec,            session_id, serial_num, cpu, physical_reads,            logical_reads, pga_memory, hard_parses, soft_parses,            physical_read_pct, logical_read_pct, con_id          FROM gv$sessmetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$SESSTAT+++                       select  SID , STATISTIC# , VALUE, CON_ID from GV$SESSTAT where inst_id = USERENV('Instance')
+++V$SESS_IO+++                       select  SID , BLOCK_GETS , CONSISTENT_GETS , PHYSICAL_READS , BLOCK_CHANGES , CONSISTENT_CHANGES, OPTIMIZED_PHYSICAL_READS, CON_ID  from GV$SESS_IO where inst_id = USERENV('Instance')
+++V$SESS_TIME_MODEL+++               select SID, STAT_ID, STAT_NAME, VALUE, CON_ID from GV$SESS_TIME_MODEL  where inst_id = USERENV('Instance')
+++V$SES_OPTIMIZER_ENV+++             select SID,                          ID,                           NAME,                         SQL_FEATURE,                  ISDEFAULT,                    VALUE,                        CON_ID                 from   GV$SES_OPTIMIZER_ENV     where  INST_ID = USERENV('Instance')
+++V$SGA+++                           select  NAME , VALUE, CON_ID from GV$SGA where inst_id = USERENV('Instance')
+++V$SGAINFO+++                       select name, bytes, resizeable, con_id from gv$sgainfo  where inst_id = USERENV('Instance')
+++V$SGASTAT+++                       select  POOL, NAME , BYTES, CON_ID from GV$SGASTAT where inst_id = USERENV('Instance')
+++V$SGA_CURRENT_RESIZE_OPS+++        select component, oper_type, oper_mode, parameter, initial_size,     target_size, current_size, start_time, last_update_time, con_id   from gv$sga_current_resize_ops   where inst_id = USERENV('Instance')
+++V$SGA_DYNAMIC_COMPONENTS+++        select component, current_size, min_size, max_size, user_specified_size,     oper_count, last_oper_type, last_oper_mode, last_oper_time, granule_size,   con_id from gv$sga_dynamic_components   where inst_id = USERENV('Instance')
+++V$SGA_DYNAMIC_FREE_MEMORY+++       select current_size, con_id from gv$sga_dynamic_free_memory   where inst_id = USERENV('Instance')
+++V$SGA_RESIZE_OPS+++                select component, oper_type, oper_mode, parameter, initial_size,     target_size, final_size, status, start_time, end_time, con_id   from gv$sga_resize_ops   where inst_id = USERENV('Instance')
+++V$SGA_TARGET_ADVICE+++             select sga_size, sga_size_factor, estd_db_time,                   estd_db_time_factor, estd_physical_reads, estd_buffer_cache_size, estd_shared_pool_size, con_id                                     from gv$sga_target_advice where inst_id = userenv('instance')
+++V$SHARED_POOL_ADVICE+++            select shared_pool_size_for_estimate, shared_pool_size_factor,  estd_lc_size, estd_lc_memory_objects, estd_lc_time_saved,  estd_lc_time_saved_factor, estd_lc_load_time,  estd_lc_load_time_factor, estd_lc_memory_object_hits, con_id  from gv$shared_pool_advice where inst_id = USERENV('Instance')
+++V$SHARED_POOL_RESERVED+++          select  FREE_SPACE , AVG_FREE_SIZE , FREE_COUNT , MAX_FREE_SIZE , USED_SPACE , AVG_USED_SIZE , USED_COUNT , MAX_USED_SIZE , REQUESTS , REQUEST_MISSES , LAST_MISS_SIZE , MAX_MISS_SIZE , REQUEST_FAILURES , LAST_FAILURE_SIZE , ABORTED_REQUEST_THRESHOLD , ABORTED_REQUESTS , LAST_ABORTED_SIZE, CON_ID from GV$SHARED_POOL_RESERVED where inst_id = USERENV('Instance')
+++V$SHARED_SERVER+++                 select  NAME , PADDR , STATUS , MESSAGES , BYTES , BREAKS , CIRCUIT , IDLE , BUSY , IN_NET , OUT_NET , REQUESTS, CON_ID from GV$SHARED_SERVER where inst_id = USERENV('Instance')
+++V$SHARED_SERVER_MONITOR+++         select  MAXIMUM_CONNECTIONS , MAXIMUM_SESSIONS , SERVERS_STARTED , SERVERS_TERMINATED , SERVERS_HIGHWATER, CON_ID from GV$SHARED_SERVER_MONITOR where inst_id = USERENV('Instance')
+++V$SORT_SEGMENT+++                  select  TABLESPACE_NAME , SEGMENT_FILE , SEGMENT_BLOCK , EXTENT_SIZE , CURRENT_USERS , TOTAL_EXTENTS , TOTAL_BLOCKS , USED_EXTENTS , USED_BLOCKS , FREE_EXTENTS , FREE_BLOCKS , ADDED_EXTENTS , EXTENT_HITS , FREED_EXTENTS , FREE_REQUESTS , MAX_SIZE , MAX_BLOCKS , MAX_USED_SIZE , MAX_USED_BLOCKS , MAX_SORT_SIZE, MAX_SORT_BLOCKS, RELATIVE_FNO, TS#, CON_ID from GV$SORT_SEGMENT where inst_id = USERENV('Instance')
+++V$SORT_USAGE+++                    select  USERNAME , "USER" , SESSION_ADDR , SESSION_NUM , SQLADDR , SQLHASH, SQL_ID, TABLESPACE , CONTENTS , SEGTYPE , SEGFILE# , SEGBLK# ,EXTENTS , BLOCKS , SEGRFNO#, TS#, CON_ID , SQL_ID_TEMPSEG from GV$SORT_USAGE where inst_id = USERENV('Instance')
+++V$SPPARAMETER+++                   select FAMILY, SID, NAME, TYPE, VALUE, DISPLAY_VALUE, ISSPECIFIED, ORDINAL,  UPDATE_COMMENT, CON_ID  from GV$SPPARAMETER where INST_id = USERENV('Instance')
+++V$SQL+++                           select  SQL_TEXT , SQL_FULLTEXT , SQL_ID,  SHARABLE_MEM , PERSISTENT_MEM , RUNTIME_MEM , SORTS , LOADED_VERSIONS , OPEN_VERSIONS , USERS_OPENING , FETCHES , EXECUTIONS , PX_SERVERS_EXECUTIONS , END_OF_FETCH_COUNT, USERS_EXECUTING , LOADS , FIRST_LOAD_TIME, INVALIDATIONS, PARSE_CALLS , DISK_READS , DIRECT_WRITES , BUFFER_GETS , APPLICATION_WAIT_TIME, CONCURRENCY_WAIT_TIME, CLUSTER_WAIT_TIME, USER_IO_WAIT_TIME, PLSQL_EXEC_TIME, JAVA_EXEC_TIME, ROWS_PROCESSED , COMMAND_TYPE , OPTIMIZER_MODE , OPTIMIZER_COST, OPTIMIZER_ENV, OPTIMIZER_ENV_HASH_VALUE, PARSING_USER_ID , PARSING_SCHEMA_ID , PARSING_SCHEMA_NAME, KEPT_VERSIONS , ADDRESS , TYPE_CHK_HEAP , HASH_VALUE, OLD_HASH_VALUE, PLAN_HASH_VALUE, FULL_PLAN_HASH_VALUE, CHILD_NUMBER, SERVICE, SERVICE_HASH, MODULE, MODULE_HASH , ACTION , ACTION_HASH ,  SERIALIZABLE_ABORTS , OUTLINE_CATEGORY, CPU_TIME, ELAPSED_TIME, OUTLINE_SID, CHILD_ADDRESS, SQLTYPE, REMOTE, OBJECT_STATUS, LITERAL_HASH_VALUE, LAST_LOAD_TIME, IS_OBSOLETE, IS_BIND_SENSITIVE, IS_BIND_AWARE, IS_SHAREABLE,CHILD_LATCH, SQL_PROFILE, SQL_PATCH, SQL_PLAN_BASELINE, PROGRAM_ID, PROGRAM_LINE#, EXACT_MATCHING_SIGNATURE, FORCE_MATCHING_SIGNATURE, LAST_ACTIVE_TIME, BIND_DATA, TYPECHECK_MEM, IO_CELL_OFFLOAD_ELIGIBLE_BYTES, IO_INTERCONNECT_BYTES,  PHYSICAL_READ_REQUESTS, PHYSICAL_READ_BYTES, PHYSICAL_WRITE_REQUESTS, PHYSICAL_WRITE_BYTES, OPTIMIZED_PHY_READ_REQUESTS, LOCKED_TOTAL, PINNED_TOTAL, IO_CELL_UNCOMPRESSED_BYTES, IO_CELL_OFFLOAD_RETURNED_BYTES, CON_ID, IS_REOPTIMIZABLE, IS_RESOLVED_ADAPTIVE_PLAN, IM_SCANS, IM_SCAN_BYTES_UNCOMPRESSED, IM_SCAN_BYTES_INMEMORY from GV$SQL where inst_id = USERENV('Instance')
+++V$SQLAREA+++                       select    SQL_TEXT,           SQL_FULLTEXT,           SQL_ID,           SHARABLE_MEM,           PERSISTENT_MEM,           RUNTIME_MEM,           SORTS,           VERSION_COUNT,           LOADED_VERSIONS,           OPEN_VERSIONS,           USERS_OPENING,           FETCHES,           EXECUTIONS,           PX_SERVERS_EXECUTIONS,           END_OF_FETCH_COUNT,           USERS_EXECUTING,           LOADS,           FIRST_LOAD_TIME,           INVALIDATIONS,           PARSE_CALLS,           DISK_READS,           DIRECT_WRITES,           BUFFER_GETS,           APPLICATION_WAIT_TIME,           CONCURRENCY_WAIT_TIME,           CLUSTER_WAIT_TIME,           USER_IO_WAIT_TIME,           PLSQL_EXEC_TIME,           JAVA_EXEC_TIME,           ROWS_PROCESSED,           COMMAND_TYPE,           OPTIMIZER_MODE,           OPTIMIZER_COST,           OPTIMIZER_ENV,           OPTIMIZER_ENV_HASH_VALUE,           PARSING_USER_ID,           PARSING_SCHEMA_ID,           PARSING_SCHEMA_NAME,           KEPT_VERSIONS,           ADDRESS,           HASH_VALUE,           OLD_HASH_VALUE,           PLAN_HASH_VALUE,           FULL_PLAN_HASH_VALUE,           MODULE,           MODULE_HASH,           ACTION,           ACTION_HASH,           SERIALIZABLE_ABORTS,           OUTLINE_CATEGORY,           CPU_TIME,           ELAPSED_TIME,           OUTLINE_SID,           LAST_ACTIVE_CHILD_ADDRESS,           REMOTE,           OBJECT_STATUS,           LITERAL_HASH_VALUE,           LAST_LOAD_TIME,           IS_OBSOLETE,           IS_BIND_SENSITIVE,           IS_BIND_AWARE,           CHILD_LATCH,           SQL_PROFILE,           SQL_PATCH,           SQL_PLAN_BASELINE,           PROGRAM_ID,           PROGRAM_LINE#,           EXACT_MATCHING_SIGNATURE,           FORCE_MATCHING_SIGNATURE,           LAST_ACTIVE_TIME,            BIND_DATA,            TYPECHECK_MEM,            IO_CELL_OFFLOAD_ELIGIBLE_BYTES,            IO_INTERCONNECT_BYTES,             PHYSICAL_READ_REQUESTS,            PHYSICAL_READ_BYTES,            PHYSICAL_WRITE_REQUESTS,            PHYSICAL_WRITE_BYTES,            OPTIMIZED_PHY_READ_REQUESTS,            LOCKED_TOTAL,             PINNED_TOTAL,            IO_CELL_UNCOMPRESSED_BYTES,            IO_CELL_OFFLOAD_RETURNED_BYTES,            CON_ID,            IS_REOPTIMIZABLE,            IS_RESOLVED_ADAPTIVE_PLAN from GV$SQLAREA where inst_id = USERENV('Instance')
+++V$SQLAREA_PLAN_HASH+++             select  SQL_TEXT,          SQL_FULLTEXT,          ADDRESS,          HASH_VALUE,          SQL_ID,          PLAN_HASH_VALUE,          VERSION_COUNT,          LAST_ACTIVE_CHILD_ADDRESS,          SHARABLE_MEM,          PERSISTENT_MEM,          RUNTIME_MEM,          SORTS,          LOADED_VERSIONS,          OPEN_VERSIONS,          USERS_OPENING,          USERS_EXECUTING,          FETCHES,          EXECUTIONS,          PX_SERVERS_EXECUTIONS,          END_OF_FETCH_COUNT,          LOADS,          FIRST_LOAD_TIME,          LAST_LOAD_TIME,          LAST_ACTIVE_TIME,          INVALIDATIONS,          PARSE_CALLS,          DISK_READS,          DIRECT_WRITES,          BUFFER_GETS,          CPU_TIME,          ELAPSED_TIME,          APPLICATION_WAIT_TIME,          CONCURRENCY_WAIT_TIME,          CLUSTER_WAIT_TIME,          USER_IO_WAIT_TIME,          PLSQL_EXEC_TIME,          JAVA_EXEC_TIME,          ROWS_PROCESSED,          COMMAND_TYPE,          OPTIMIZER_MODE,          OPTIMIZER_COST,          OPTIMIZER_ENV,          OPTIMIZER_ENV_HASH_VALUE,          PARSING_USER_ID,          PARSING_SCHEMA_ID,          PARSING_SCHEMA_NAME,          KEPT_VERSIONS,          MODULE,          MODULE_HASH,          ACTION,          ACTION_HASH,          SERIALIZABLE_ABORTS,          OUTLINE_CATEGORY,          OUTLINE_SID,          REMOTE,          OBJECT_STATUS,          LITERAL_HASH_VALUE,          SQL_PROFILE,          PROGRAM_ID,          PROGRAM_LINE#,          EXACT_MATCHING_SIGNATURE,          FORCE_MATCHING_SIGNATURE,          BIND_DATA,          TYPECHECK_MEM,          IO_CELL_OFFLOAD_ELIGIBLE_BYTES,          IO_INTERCONNECT_BYTES,           PHYSICAL_READ_REQUESTS,          PHYSICAL_READ_BYTES,          PHYSICAL_WRITE_REQUESTS,          PHYSICAL_WRITE_BYTES,          OPTIMIZED_PHY_READ_REQUESTS,          IO_CELL_UNCOMPRESSED_BYTES,          IO_CELL_OFFLOAD_RETURNED_BYTES,          CON_ID,          CON_DBID from GV$SQLAREA_PLAN_HASH where inst_id = USERENV('Instance')
+++V$SQLCOMMAND+++                    select COMMAND_TYPE, COMMAND_NAME, CON_ID  from GV$SQLCOMMAND where inst_id = USERENV('Instance')
+++V$SQLFN_ARG_METADATA+++            select FUNC_ID,               ARGNUM,               DATATYPE,               DESCR,               CON_ID        from GV$SQLFN_ARG_METADATA where inst_id=USERENV('Instance')
+++V$SQLFN_METADATA+++                select FUNC_ID,               NAME,               MINARGS,               MAXARGS,               DATATYPE,               VERSION,               ANALYTIC,               AGGREGATE,               OFFLOADABLE,               DISP_TYPE,               USAGE,               DESCR,               CON_ID        from GV$SQLFN_METADATA where inst_id=USERENV('Instance')
+++V$SQLPA_METRIC+++                  select METRIC_NAME, CON_ID          from GV$SQLPA_METRIC          where INST_ID = USERENV('Instance')
+++V$SQLSTATS+++                      select SQL_TEXT, SQL_FULLTEXT, SQL_ID, LAST_ACTIVE_TIME,         LAST_ACTIVE_CHILD_ADDRESS, PLAN_HASH_VALUE,         PARSE_CALLS, DISK_READS, DIRECT_WRITES, BUFFER_GETS, ROWS_PROCESSED, SERIALIZABLE_ABORTS, FETCHES, EXECUTIONS, END_OF_FETCH_COUNT, LOADS, VERSION_COUNT, INVALIDATIONS, PX_SERVERS_EXECUTIONS, CPU_TIME, ELAPSED_TIME, AVG_HARD_PARSE_TIME, APPLICATION_WAIT_TIME, CONCURRENCY_WAIT_TIME, CLUSTER_WAIT_TIME, USER_IO_WAIT_TIME, PLSQL_EXEC_TIME, JAVA_EXEC_TIME, SORTS, SHARABLE_MEM, TOTAL_SHARABLE_MEM, TYPECHECK_MEM, IO_CELL_OFFLOAD_ELIGIBLE_BYTES, IO_INTERCONNECT_BYTES, PHYSICAL_READ_REQUESTS, PHYSICAL_READ_BYTES, PHYSICAL_WRITE_REQUESTS, PHYSICAL_WRITE_BYTES, EXACT_MATCHING_SIGNATURE, FORCE_MATCHING_SIGNATURE, IO_CELL_UNCOMPRESSED_BYTES, IO_CELL_OFFLOAD_RETURNED_BYTES, DELTA_PARSE_CALLS,  DELTA_DISK_READS, DELTA_DIRECT_WRITES, DELTA_BUFFER_GETS, DELTA_ROWS_PROCESSED, DELTA_FETCH_COUNT, DELTA_EXECUTION_COUNT,  DELTA_PX_SERVERS_EXECUTIONS, DELTA_END_OF_FETCH_COUNT, DELTA_CPU_TIME, DELTA_ELAPSED_TIME, DELTA_APPLICATION_WAIT_TIME, DELTA_CONCURRENCY_TIME, DELTA_CLUSTER_WAIT_TIME,  DELTA_USER_IO_WAIT_TIME, DELTA_PLSQL_EXEC_TIME, DELTA_JAVA_EXEC_TIME, DELTA_SORTS, DELTA_LOADS, DELTA_INVALIDATIONS, DELTA_PHYSICAL_READ_REQUESTS, DELTA_PHYSICAL_READ_BYTES, DELTA_PHYSICAL_WRITE_REQUESTS, DELTA_PHYSICAL_WRITE_BYTES, DELTA_IO_INTERCONNECT_BYTES, DELTA_CELL_OFFLOAD_ELIG_BYTES, DELTA_CELL_UNCOMPRESSED_BYTES, CON_ID, CON_DBID, OBSOLETE_COUNT FROM gv$sqlstats where inst_id=USERENV('Instance')
+++V$SQLSTATS_PLAN_HASH+++            select SQL_TEXT, SQL_FULLTEXT, SQL_ID, LAST_ACTIVE_TIME,         LAST_ACTIVE_CHILD_ADDRESS, PLAN_HASH_VALUE,         PARSE_CALLS, DISK_READS, DIRECT_WRITES, BUFFER_GETS, ROWS_PROCESSED, SERIALIZABLE_ABORTS, FETCHES, EXECUTIONS, END_OF_FETCH_COUNT, LOADS, VERSION_COUNT, INVALIDATIONS, PX_SERVERS_EXECUTIONS, CPU_TIME, ELAPSED_TIME, AVG_HARD_PARSE_TIME, APPLICATION_WAIT_TIME, CONCURRENCY_WAIT_TIME, CLUSTER_WAIT_TIME, USER_IO_WAIT_TIME, PLSQL_EXEC_TIME, JAVA_EXEC_TIME, SORTS, SHARABLE_MEM, TOTAL_SHARABLE_MEM, TYPECHECK_MEM, IO_CELL_OFFLOAD_ELIGIBLE_BYTES, IO_INTERCONNECT_BYTES, PHYSICAL_READ_REQUESTS, PHYSICAL_READ_BYTES, PHYSICAL_WRITE_REQUESTS, PHYSICAL_WRITE_BYTES, EXACT_MATCHING_SIGNATURE, FORCE_MATCHING_SIGNATURE, IO_CELL_UNCOMPRESSED_BYTES, IO_CELL_OFFLOAD_RETURNED_BYTES, DELTA_PARSE_CALLS,  DELTA_DISK_READS, DELTA_DIRECT_WRITES, DELTA_BUFFER_GETS, DELTA_ROWS_PROCESSED, DELTA_FETCH_COUNT, DELTA_EXECUTION_COUNT,  DELTA_PX_SERVERS_EXECUTIONS, DELTA_END_OF_FETCH_COUNT, DELTA_CPU_TIME, DELTA_ELAPSED_TIME, DELTA_APPLICATION_WAIT_TIME, DELTA_CONCURRENCY_TIME, DELTA_CLUSTER_WAIT_TIME,  DELTA_USER_IO_WAIT_TIME, DELTA_PLSQL_EXEC_TIME, DELTA_JAVA_EXEC_TIME, DELTA_SORTS, DELTA_LOADS, DELTA_INVALIDATIONS, DELTA_PHYSICAL_READ_REQUESTS, DELTA_PHYSICAL_READ_BYTES, DELTA_PHYSICAL_WRITE_REQUESTS, DELTA_PHYSICAL_WRITE_BYTES, DELTA_IO_INTERCONNECT_BYTES, DELTA_CELL_OFFLOAD_ELIG_BYTES, DELTA_CELL_UNCOMPRESSED_BYTES, CON_ID FROM gv$sqlstats_plan_hash where inst_id=USERENV('Instance')
+++V$SQLTEXT+++                       select  ADDRESS, HASH_VALUE, SQL_ID, COMMAND_TYPE , PIECE,  SQL_TEXT, CON_ID from GV$SQLTEXT where inst_id = USERENV('Instance')
+++V$SQLTEXT_WITH_NEWLINES+++         select  ADDRESS, HASH_VALUE, SQL_ID, COMMAND_TYPE, PIECE,          SQL_TEXT, CON_ID  from GV$SQLTEXT_WITH_NEWLINES where inst_id = USERENV('Instance')
+++V$SQL_BIND_DATA+++                 select  CURSOR_NUM , POSITION , DATATYPE , SHARED_MAX_LEN , PRIVATE_MAX_LEN , ARRAY_SIZE , PRECISION , SCALE , SHARED_FLAG , SHARED_FLAG2 , BUF_ADDRESS , BUF_LENGTH , VAL_LENGTH , BUF_FLAG , INDICATOR , VALUE, CON_ID from GV$SQL_BIND_DATA where inst_id = USERENV('Instance')
+++V$SQL_BIND_METADATA+++             select  ADDRESS , POSITION , DATATYPE , MAX_LENGTH , ARRAY_LEN , BIND_NAME, CON_ID from GV$SQL_BIND_METADATA where inst_id = USERENV('Instance')
+++V$SQL_CS_HISTOGRAM+++              select  address, hash_value, sql_id,         child_number, bucket_id, count, con_id from GV$SQL_CS_HISTOGRAM where inst_id=USERENV('Instance')
+++V$SQL_CS_SELECTIVITY+++            select  address, hash_value, sql_id,         child_number, predicate, range_id, low, high, con_id from GV$SQL_CS_SELECTIVITY where inst_id=USERENV('Instance')
+++V$SQL_CS_STATISTICS+++             select  address, hash_value,         sql_id, child_number,         bind_set_hash_value, peeked,         executions, rows_processed,         buffer_gets, cpu_time, con_id from GV$SQL_CS_STATISTICS where inst_id=USERENV('Instance')
+++V$SQL_CURSOR+++                    select  CURNO , FLAG , STATUS , PARENT_HANDLE , PARENT_LOCK , CHILD_LOCK , CHILD_PIN , PERS_HEAP_MEM , WORK_HEAP_MEM , BIND_VARS , DEFINE_VARS , BIND_MEM_LOC , INST_FLAG , INST_FLAG2, CHILD_HANDLE, CON_ID from GV$SQL_CURSOR where inst_id = USERENV('Instance')
+++V$SQL_DIAG_REPOSITORY+++           select  address, con_id, hash_value, sql_id,         child_number, SQL_DIAG_REPO_ID, type,         plan_id, feature, state from GV$SQL_DIAG_REPOSITORY where inst_id=USERENV('Instance')
+++V$SQL_DIAG_REPOSITORY_REASON+++    select  address, con_id, hash_value, sql_id,         child_number, SQL_DIAG_REPO_ID, feature, reason,         COMPILATION_ORIGIN, EXECUTION_ORIGIN, SLAVE_ORIGIN from GV$SQL_DIAG_REPOSITORY_REASON where inst_id=USERENV('Instance')
+++V$SQL_FEATURE+++                   select  SQL_FEATURE,        DESCRIPTION,        PROPERTY,         CON_ID from GV$SQL_FEATURE where inst_id=USERENV('Instance')
+++V$SQL_FEATURE_DEPENDENCY+++        select  SQL_FEATURE,        DEPEND_ON,         CON_ID  from GV$SQL_FEATURE_DEPENDENCY where inst_id=USERENV('Instance')
+++V$SQL_FEATURE_HIERARCHY+++         select  SQL_FEATURE,        PARENT_ID,         CON_ID  from GV$SQL_FEATURE_HIERARCHY where inst_id=USERENV('Instance')
+++V$SQL_HINT+++                      select  NAME,        SQL_FEATURE,        CLASS,        INVERSE,        TARGET_LEVEL,        PROPERTY,        VERSION,        VERSION_OUTLINE,         CON_ID from gv$sql_hint where inst_id=USERENV('Instance')
+++V$SQL_JOIN_FILTER+++               SELECT qc_session_id, qc_instance_id, sql_plan_hash_value,                 filter_id, length, bits_set, filtered, probed, active, con_id          FROM GV$SQL_JOIN_FILTER          WHERE inst_id = USERENV('INSTANCE')
+++V$SQL_MONITOR+++                   select  KEY,         REPORT_ID,         STATUS,         USER#,         USERNAME,         MODULE,         ACTION,         SERVICE_NAME,         CLIENT_IDENTIFIER,         CLIENT_INFO,         PROGRAM,         PLSQL_ENTRY_OBJECT_ID,         PLSQL_ENTRY_SUBPROGRAM_ID,         PLSQL_OBJECT_ID,         PLSQL_SUBPROGRAM_ID,         FIRST_REFRESH_TIME,         LAST_REFRESH_TIME,         REFRESH_COUNT,         DBOP_EXEC_ID,         DBOP_NAME,         SID,         PROCESS_NAME,         SQL_ID,         SQL_TEXT,         IS_FULL_SQLTEXT,         SQL_EXEC_START,         SQL_EXEC_ID,         SQL_PLAN_HASH_VALUE,         SQL_FULL_PLAN_HASH_VALUE,         EXACT_MATCHING_SIGNATURE,         FORCE_MATCHING_SIGNATURE,         SQL_CHILD_ADDRESS,         SESSION_SERIAL#,         PX_IS_CROSS_INSTANCE,        PX_MAXDOP,        PX_MAXDOP_INSTANCES,        PX_SERVERS_REQUESTED,        PX_SERVERS_ALLOCATED,        PX_SERVER#,         PX_SERVER_GROUP,         PX_SERVER_SET,         PX_QCINST_ID,         PX_QCSID,         ERROR_NUMBER,         ERROR_FACILITY,         ERROR_MESSAGE,         BINDS_XML,         OTHER_XML,         ELAPSED_TIME,         QUEUING_TIME,         CPU_TIME,         FETCHES,         BUFFER_GETS,         PHYSICAL_READ_REQUESTS,         PHYSICAL_WRITE_REQUESTS,         IO_INTERCONNECT_BYTES,         PHYSICAL_READ_REQUESTS,         PHYSICAL_READ_BYTES,         PHYSICAL_WRITE_REQUESTS,         PHYSICAL_WRITE_BYTES,         APPLICATION_WAIT_TIME,         CONCURRENCY_WAIT_TIME,         CLUSTER_WAIT_TIME,         USER_IO_WAIT_TIME,         PLSQL_EXEC_TIME,         JAVA_EXEC_TIME,         RM_LAST_ACTION,         RM_LAST_ACTION_REASON,         RM_LAST_ACTION_TIME,         RM_CONSUMER_GROUP,         CON_ID,         CON_NAME,         ECID,         IS_ADAPTIVE_PLAN,         IS_FINAL_PLAN from GV$SQL_MONITOR where inst_id=USERENV('Instance')
+++V$SQL_MONITOR_SESSTAT+++           select con_id, key, statistic#, value from GV$SQL_MONITOR_SESSTAT where inst_id = USERENV('Instance')
+++V$SQL_MONITOR_STATNAME+++          select con_id, id, group_id, name, description, type, flags from GV$SQL_MONITOR_STATNAME where inst_id = USERENV('Instance')
+++V$SQL_OPTIMIZER_ENV+++             select ADDRESS,                      HASH_VALUE,                   SQL_ID,                       CHILD_ADDRESS,                CHILD_NUMBER,                 ID,                           NAME,                         ISDEFAULT,                    VALUE,                        CON_ID                 from   GV$SQL_OPTIMIZER_ENV     where  INST_ID = USERENV('Instance')
+++V$SQL_PLAN+++                      select ADDRESS, HASH_VALUE, SQL_ID, PLAN_HASH_VALUE,                         FULL_PLAN_HASH_VALUE, CHILD_ADDRESS,                                         CHILD_NUMBER,  TIMESTAMP, OPERATION,                                         OPTIONS, OBJECT_NODE, OBJECT#, OBJECT_OWNER, OBJECT_NAME,                    OBJECT_ALIAS, OBJECT_TYPE, OPTIMIZER,                                        ID, PARENT_ID, DEPTH, POSITION, SEARCH_COLUMNS, COST, CARDINALITY,           BYTES, OTHER_TAG, PARTITION_START, PARTITION_STOP, PARTITION_ID,             OTHER, DISTRIBUTION, CPU_COST, IO_COST, TEMP_SPACE,                          ACCESS_PREDICATES, FILTER_PREDICATES, PROJECTION, TIME, QBLOCK_NAME,         REMARKS, OTHER_XML, CON_ID                                                   from GV$SQL_PLAN                                                             where inst_id = USERENV('Instance')
+++V$SQL_PLAN_MONITOR+++              select  CON_ID,         KEY,         STATUS,         FIRST_REFRESH_TIME,         LAST_REFRESH_TIME,         FIRST_CHANGE_TIME,         LAST_CHANGE_TIME,         REFRESH_COUNT,         SID,         PROCESS_NAME,         SQL_ID,         SQL_EXEC_START,         SQL_EXEC_ID,         SQL_PLAN_HASH_VALUE,         SQL_CHILD_ADDRESS,         PLAN_PARENT_ID,         PLAN_LINE_ID,         PLAN_OPERATION,         PLAN_OPTIONS,         PLAN_OBJECT_OWNER,         PLAN_OBJECT_NAME,         PLAN_OBJECT_TYPE,         PLAN_DEPTH,         PLAN_POSITION,         PLAN_COST,         PLAN_CARDINALITY,         PLAN_BYTES,         PLAN_TIME,         PLAN_PARTITION_START,         PLAN_PARTITION_STOP,         PLAN_CPU_COST,         PLAN_IO_COST,         PLAN_TEMP_SPACE,         STARTS,         OUTPUT_ROWS,         IO_INTERCONNECT_BYTES,         PHYSICAL_READ_REQUESTS,         PHYSICAL_READ_BYTES,         PHYSICAL_WRITE_REQUESTS,         PHYSICAL_WRITE_BYTES,         WORKAREA_MEM,         WORKAREA_MAX_MEM,         WORKAREA_TEMPSEG,         WORKAREA_MAX_TEMPSEG,         OTHERSTAT_GROUP_ID,         OTHERSTAT_1_ID,         OTHERSTAT_1_TYPE,         OTHERSTAT_1_VALUE,         OTHERSTAT_2_ID,         OTHERSTAT_2_TYPE,         OTHERSTAT_2_VALUE,         OTHERSTAT_3_ID,         OTHERSTAT_3_TYPE,         OTHERSTAT_3_VALUE,         OTHERSTAT_4_ID,         OTHERSTAT_4_TYPE,         OTHERSTAT_4_VALUE,         OTHERSTAT_5_ID,         OTHERSTAT_5_TYPE,         OTHERSTAT_5_VALUE,         OTHERSTAT_6_ID,         OTHERSTAT_6_TYPE,         OTHERSTAT_6_VALUE,         OTHERSTAT_7_ID,         OTHERSTAT_7_TYPE,         OTHERSTAT_7_VALUE,         OTHERSTAT_8_ID,         OTHERSTAT_8_TYPE,         OTHERSTAT_8_VALUE,         OTHERSTAT_9_ID,         OTHERSTAT_9_TYPE,         OTHERSTAT_9_VALUE,         OTHERSTAT_10_ID,         OTHERSTAT_10_TYPE,         OTHERSTAT_10_VALUE,         OTHER_XML,         PLAN_OPERATION_INACTIVE from GV$SQL_PLAN_MONITOR where inst_id=USERENV('Instance')
+++V$SQL_PLAN_STATISTICS+++           select ADDRESS, HASH_VALUE, SQL_ID, PLAN_HASH_VALUE,                                FULL_PLAN_HASH_VALUE, CHILD_ADDRESS,                                         CHILD_NUMBER, OPERATION_ID, EXECUTIONS,                                      LAST_STARTS, STARTS, LAST_OUTPUT_ROWS, OUTPUT_ROWS,                          LAST_CR_BUFFER_GETS, CR_BUFFER_GETS, LAST_CU_BUFFER_GETS,                    CU_BUFFER_GETS, LAST_DISK_READS, DISK_READS,                                 LAST_DISK_WRITES, DISK_WRITES,                                               LAST_ELAPSED_TIME, ELAPSED_TIME, CON_ID                               from GV$SQL_PLAN_STATISTICS                                                  where inst_id = USERENV('Instance')
+++V$SQL_PLAN_STATISTICS_ALL+++       select ADDRESS, HASH_VALUE, SQL_ID, PLAN_HASH_VALUE,                                 FULL_PLAN_HASH_VALUE, CHILD_ADDRESS,                                          CHILD_NUMBER, TIMESTAMP, OPERATION, OPTIONS, OBJECT_NODE,                     OBJECT#, OBJECT_OWNER, OBJECT_NAME, OBJECT_ALIAS,                             OBJECT_TYPE, OPTIMIZER,                                                       ID, PARENT_ID, DEPTH, POSITION, SEARCH_COLUMNS, COST,                         CARDINALITY, BYTES, OTHER_TAG, PARTITION_START, PARTITION_STOP,               PARTITION_ID, OTHER, DISTRIBUTION, CPU_COST, IO_COST,                         TEMP_SPACE, ACCESS_PREDICATES, FILTER_PREDICATES, PROJECTION,                 TIME, QBLOCK_NAME, REMARKS, OTHER_XML, EXECUTIONS,                            LAST_STARTS,                                                                  STARTS, LAST_OUTPUT_ROWS, OUTPUT_ROWS, LAST_CR_BUFFER_GETS,                   CR_BUFFER_GETS, LAST_CU_BUFFER_GETS, CU_BUFFER_GETS,                          LAST_DISK_READS, DISK_READS, LAST_DISK_WRITES, DISK_WRITES,                   LAST_ELAPSED_TIME, ELAPSED_TIME, POLICY,                                      ESTIMATED_OPTIMAL_SIZE, ESTIMATED_ONEPASS_SIZE,                               LAST_MEMORY_USED, LAST_EXECUTION, LAST_DEGREE,                                TOTAL_EXECUTIONS, OPTIMAL_EXECUTIONS, ONEPASS_EXECUTIONS,                     MULTIPASSES_EXECUTIONS, ACTIVE_TIME, MAX_TEMPSEG_SIZE,                        LAST_TEMPSEG_SIZE, CON_ID, CON_DBID                                    from GV$SQL_PLAN_STATISTICS_ALL                                               where inst_id = USERENV('Instance')
+++V$SQL_REDIRECTION+++               select ADDRESS,PARENT_HANDLE,HASH_VALUE,SQL_ID,CHILD_NUMBER, PARSING_USER_ID, PARSING_SCHEMA_ID,COMMAND_TYPE, REASON, ERROR_CODE, POSITION, SQL_TEXT_PIECE, ERROR_MESSAGE, CON_ID  from GV$SQL_REDIRECTION  where inst_id = USERENV('Instance')
+++V$SQL_REOPTIMIZATION_HINTS+++      select  address, hash_value, sql_id,         child_number, hint_id, hint_text,         client_id, reparse, con_id from GV$SQL_REOPTIMIZATION_HINTS where inst_id=USERENV('Instance')
+++V$SQL_SHARED_CURSOR+++             select  SQL_ID, ADDRESS, CHILD_ADDRESS, CHILD_NUMBER, UNBOUND_CURSOR,                SQL_TYPE_MISMATCH, OPTIMIZER_MISMATCH,                               OUTLINE_MISMATCH, STATS_ROW_MISMATCH, LITERAL_MISMATCH, FORCE_HARD_PARSE,    EXPLAIN_PLAN_CURSOR, BUFFERED_DML_MISMATCH, PDML_ENV_MISMATCH,               INST_DRTLD_MISMATCH, SLAVE_QC_MISMATCH, TYPECHECK_MISMATCH,                  AUTH_CHECK_MISMATCH, BIND_MISMATCH, DESCRIBE_MISMATCH, LANGUAGE_MISMATCH,    TRANSLATION_MISMATCH, BIND_EQUIV_FAILURE, INSUFF_PRIVS,                      INSUFF_PRIVS_REM, REMOTE_TRANS_MISMATCH, LOGMINER_SESSION_MISMATCH,          INCOMP_LTRL_MISMATCH, OVERLAP_TIME_MISMATCH, EDITION_MISMATCH,               MV_QUERY_GEN_MISMATCH, USER_BIND_PEEK_MISMATCH, TYPCHK_DEP_MISMATCH,         NO_TRIGGER_MISMATCH, FLASHBACK_CURSOR, ANYDATA_TRANSFORMATION,               PDDL_ENV_MISMATCH, TOP_LEVEL_RPI_CURSOR, DIFFERENT_LONG_LENGTH,              LOGICAL_STANDBY_APPLY, DIFF_CALL_DURN, BIND_UACS_DIFF,                       PLSQL_CMP_SWITCHS_DIFF, CURSOR_PARTS_MISMATCH, STB_OBJECT_MISMATCH,          CROSSEDITION_TRIGGER_MISMATCH, PQ_SLAVE_MISMATCH, TOP_LEVEL_DDL_MISMATCH,    MULTI_PX_MISMATCH, BIND_PEEKED_PQ_MISMATCH, MV_REWRITE_MISMATCH,             ROLL_INVALID_MISMATCH, OPTIMIZER_MODE_MISMATCH,                              PX_MISMATCH, MV_STALEOBJ_MISMATCH, FLASHBACK_TABLE_MISMATCH,                 LITREP_COMP_MISMATCH, PLSQL_DEBUG, LOAD_OPTIMIZER_STATS, ACL_MISMATCH,       FLASHBACK_ARCHIVE_MISMATCH, LOCK_USER_SCHEMA_FAILED,                         REMOTE_MAPPING_MISMATCH, LOAD_RUNTIME_HEAP_FAILED, HASH_MATCH_FAILED,        PURGED_CURSOR, BIND_LENGTH_UPGRADEABLE, USE_FEEDBACK_STATS, REASON, CON_ID   from GV$SQL_SHARED_CURSOR                                                       where inst_id = USERENV('Instance')
+++V$SQL_SHARED_MEMORY+++             select  SQL_TEXT, SQL_FULLTEXT, HASH_VALUE, SQL_ID, HEAP_DESC,  STRUCTURE, FUNCTION, CHUNK_COM , CHUNK_PTR , CHUNK_SIZE , ALLOC_CLASS , CHUNK_TYPE , SUBHEAP_DESC, CON_ID from GV$SQL_SHARED_MEMORY where inst_id = USERENV('Instance')
+++V$SQL_WORKAREA+++                  select ADDRESS, HASH_VALUE, SQL_ID, CHILD_NUMBER,                   WORKAREA_ADDRESS,                                                            OPERATION_TYPE, OPERATION_ID, POLICY, ESTIMATED_OPTIMAL_SIZE,                ESTIMATED_ONEPASS_SIZE, LAST_MEMORY_USED, LAST_EXECUTION,                    LAST_DEGREE, TOTAL_EXECUTIONS, OPTIMAL_EXECUTIONS,                           ONEPASS_EXECUTIONS, MULTIPASSES_EXECUTIONS, ACTIVE_TIME,                     MAX_TEMPSEG_SIZE, LAST_TEMPSEG_SIZE, CON_ID                           from  GV$SQL_WORKAREA                                                        where inst_id = USERENV('Instance')
+++V$SQL_WORKAREA_ACTIVE+++           select   SQL_HASH_VALUE,           SQL_ID,            SQL_EXEC_START,            SQL_EXEC_ID,            WORKAREA_ADDRESS,           OPERATION_TYPE,             OPERATION_ID,           POLICY,              SID,                 QCINST_ID,           QCSID,               ACTIVE_TIME,           WORK_AREA_SIZE,           EXPECTED_SIZE,           ACTUAL_MEM_USED,            MAX_MEM_USED,            NUMBER_PASSES,            TEMPSEG_SIZE,           TABLESPACE,           SEGRFNO#,           SEGBLK#,           CON_ID    from   GV$SQL_WORKAREA_ACTIVE    where  INST_ID = USERENV('Instance')
+++V$SQL_WORKAREA_HISTOGRAM+++        select   LOW_OPTIMAL_SIZE,           HIGH_OPTIMAL_SIZE,           OPTIMAL_EXECUTIONS,           ONEPASS_EXECUTIONS,           MULTIPASSES_EXECUTIONS,           TOTAL_EXECUTIONS,           CON_ID    from   GV$SQL_WORKAREA_HISTOGRAM    where  INST_ID = USERENV('Instance')
+++V$SSCR_SESSIONS+++                 SELECT sid, serial#, state, crmode, scope, nc_component,  nc_reason, options, timeout, con_id FROM gv$sscr_sessions WHERE inst_id = USERENV('Instance')
+++V$STANDBY_EVENT_HISTOGRAM+++       select NAME, TIME, UNIT, COUNT, LAST_TIME_UPDATED, CON_ID         FROM x$krdevthist
+++V$STANDBY_LOG+++                   select GROUP# , DBID , THREAD# , SEQUENCE# , BYTES , BLOCKSIZE, USED , ARCHIVED , STATUS , FIRST_CHANGE# , FIRST_TIME , NEXT_CHANGE#, NEXT_TIME, LAST_CHANGE# , LAST_TIME, CON_ID  from GV$STANDBY_LOG  where inst_id = USERENV('Instance')
+++V$STATISTICS_LEVEL+++              select statistics_name, description, session_status, system_status,          activation_level, statistics_view_name, session_settable, con_id          from gv$statistics_level where inst_id = USERENV('Instance')
+++V$STATNAME+++                      select  STATISTIC#, NAME, CLASS, STAT_ID, DISPLAY_NAME, CON_ID from GV$STATNAME where inst_id = USERENV('Instance')
+++V$STREAMS_APPLY_COORDINATOR+++     SELECT SID, SERIAL#, STATE, APPLY#, APPLY_NAME, TOTAL_APPLIED,TOTAL_WAIT_DEPS,TOTAL_WAIT_COMMITS, TOTAL_ADMIN, TOTAL_ASSIGNED, TOTAL_RECEIVED,TOTAL_IGNORED, TOTAL_ROLLBACKS, TOTAL_ERRORS, UNASSIGNED_COMPLETE_TXNS,AUTO_TXN_BUFFER_SIZE, LWM_TIME, LWM_MESSAGE_NUMBER, LWM_MESSAGE_CREATE_TIME,HWM_TIME, HWM_MESSAGE_NUMBER, HWM_MESSAGE_CREATE_TIME,STARTUP_TIME, ELAPSED_SCHEDULE_TIME, ELAPSED_IDLE_TIME,LWM_POSITION, HWM_POSITION, PROCESSED_MESSAGE_NUMBER, CON_ID, ACTIVE_SERVER_COUNT from GV$STREAMS_APPLY_COORDINATOR WHERE INST_ID = USERENV('Instance')
+++V$STREAMS_APPLY_READER+++          select SID, SERIAL#, APPLY#, APPLY_NAME, STATE, TOTAL_MESSAGES_DEQUEUED, TOTAL_MESSAGES_SPILLED, DEQUEUE_TIME, DEQUEUED_MESSAGE_NUMBER, DEQUEUED_MESSAGE_CREATE_TIME, SGA_USED, ELAPSED_DEQUEUE_TIME,  ELAPSED_SCHEDULE_TIME, ELAPSED_SPILL_TIME, LAST_BROWSE_NUM, OLDEST_SCN_NUM,  LAST_BROWSE_SEQ, LAST_DEQ_SEQ, OLDEST_XIDUSN, OLDEST_XIDSLT, OLDEST_XIDSQN,  SPILL_LWM_SCN, PROXY_SID, PROXY_SERIAL, PROXY_SPID, CAPTURE_BYTES_RECEIVED,  DEQUEUED_POSITION, LAST_BROWSE_POSITION, OLDEST_POSITION,  SPILL_LWM_POSITION, OLDEST_TRANSACTION_ID,  TOTAL_LCRS_WITH_DEP, TOTAL_LCRS_WITH_WMDEP, TOTAL_IN_MEMORY_LCRS,  SGA_ALLOCATED, CON_ID from GV$STREAMS_APPLY_READER where INST_ID = USERENV('Instance')
+++V$STREAMS_APPLY_SERVER+++          select SID, SERIAL#, APPLY#, APPLY_NAME,SERVER_ID, STATE, XIDUSN, XIDSLT, XIDSQN, COMMITSCN,DEP_XIDUSN, DEP_XIDSLT, DEP_XIDSQN, DEP_COMMITSCN, MESSAGE_SEQUENCE,TOTAL_ASSIGNED, TOTAL_ADMIN, TOTAL_ROLLBACKS,TOTAL_MESSAGES_APPLIED, APPLY_TIME, APPLIED_MESSAGE_NUMBER, APPLIED_MESSAGE_CREATE_TIME,ELAPSED_DEQUEUE_TIME, ELAPSED_APPLY_TIME, COMMIT_POSITION, DEP_COMMIT_POSITION, LAST_APPLY_POSITION, TRANSACTION_ID, DEP_TRANSACTION_ID, CON_ID, TOTAL_LCRS_RETRIED, LCR_RETRY_ITERATION, TOTAL_TXNS_RETRIED, TXN_RETRY_ITERATION, TOTAL_TXNS_RECORDED  from GV$STREAMS_APPLY_SERVER where INST_ID = USERENV('Instance')
+++V$STREAMS_CAPTURE+++               select SID, SERIAL#, CAPTURE#, CAPTURE_NAME, LOGMINER_ID,        STARTUP_TIME, STATE, TOTAL_PREFILTER_DISCARDED, TOTAL_PREFILTER_KEPT,        TOTAL_PREFILTER_EVALUATIONS,TOTAL_MESSAGES_CAPTURED, CAPTURE_TIME,        CAPTURE_MESSAGE_NUMBER, CAPTURE_MESSAGE_CREATE_TIME,        TOTAL_MESSAGES_CREATED, TOTAL_FULL_EVALUATIONS,        TOTAL_MESSAGES_ENQUEUED, ENQUEUE_TIME, ENQUEUE_MESSAGE_NUMBER,        ENQUEUE_MESSAGE_CREATE_TIME, AVAILABLE_MESSAGE_NUMBER,        AVAILABLE_MESSAGE_CREATE_TIME, ELAPSED_CAPTURE_TIME,        ELAPSED_RULE_TIME,ELAPSED_ENQUEUE_TIME,        ELAPSED_LCR_TIME, ELAPSED_REDO_WAIT_TIME, ELAPSED_PAUSE_TIME,         STATE_CHANGED_TIME, APPLY_NAME, APPLY_DBLINK, APPLY_MESSAGES_SENT,         APPLY_BYTES_SENT, OPTIMIZATION, PURPOSE,         SGA_USED, SGA_ALLOCATED, BYTES_OF_REDO_MINED,         SESSION_RESTART_SCN, CON_ID  from   GV$STREAMS_CAPTURE  where  INST_ID = USERENV('Instance')
+++V$STREAMS_MESSAGE_TRACKING+++      select TRACKING_LABEL, TAG, COMPONENT_NAME, COMPONENT_TYPE,         ACTION, ACTION_DETAILS, TIMESTAMP, MESSAGE_CREATION_TIME,                     MESSAGE_NUMBER, TRACKING_ID,                SOURCE_DATABASE_NAME, OBJECT_OWNER, OBJECT_NAME,         XID, COMMAND_TYPE, MESSAGE_POSITION, PURPOSE, CON_ID                    from   GV$STREAMS_MESSAGE_TRACKING          where  INST_ID = USERENV('Instance')
+++V$STREAMS_POOL_ADVICE+++           select streams_pool_size_for_estimate, streams_pool_size_factor, estd_spill_count, estd_spill_time, estd_unspill_count, estd_unspill_time, con_id from gv$streams_pool_advice where inst_id = USERENV('Instance')
+++V$STREAMS_POOL_STATISTICS+++       SELECT TOTAL_MEMORY_ALLOCATED, CURRENT_SIZE, SGA_TARGET_VALUE,         SHRINK_PHASE, ADVICE_DISABLED, CON_ID  FROM   GV$STREAMS_POOL_STATISTICS WHERE  INST_ID = USERENV('Instance')
+++V$STREAMS_TRANSACTION+++           select STREAMS_NAME, STREAMS_TYPE, XIDUSN, XIDSLT, XIDSQN,                 CUMULATIVE_MESSAGE_COUNT, TOTAL_MESSAGE_COUNT,                 FIRST_MESSAGE_TIME, FIRST_MESSAGE_NUMBER,                LAST_MESSAGE_TIME, LAST_MESSAGE_NUMBER,                 FIRST_MESSAGE_POSITION, LAST_MESSAGE_POSITION,                 TRANSACTION_ID, PURPOSE, CON_ID                               from   GV$STREAMS_TRANSACTION          where  INST_ID = USERENV('Instance')
+++V$SUBCACHE+++                      select  OWNER_NAME , NAME , TYPE , HEAP_NUM , CACHE_ID , CACHE_CNT , HEAP_SZ , HEAP_ALOC , HEAP_USED, CON_ID from GV$SUBCACHE where inst_id = USERENV('Instance')
+++V$SUBSCR_REGISTRATION_STATS+++     select reg_id, num_ntfns, num_grouping_ntfns,         num_ntfns_current_group, last_ntfn_start_time,         last_ntfn_sent_time, total_emon_latency, emon#, all_emon_servers,         total_payload_bytes_sent, num_retries, total_plsql_exec_time,         last_err, last_err_time, last_update_time, num_pending_ntfns,         total_pending_ntfn_bytes, con_id  from gv$subscr_registration_stats where inst_id = USERENV('Instance')
+++V$SYSAUX_OCCUPANTS+++              SELECT occupant_name, occupant_desc, schema_name,                 move_procedure, move_procedure_desc,                 space_usage_kbytes, con_id          FROM   gv$sysaux_occupants          WHERE  inst_id = USERENV('INSTANCE')
+++V$SYSMETRIC+++                     SELECT begin_time, end_time, intsize_csec,            group_id, metric_id, metric_name,            value, metric_unit, con_id          FROM   gv$sysmetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$SYSMETRIC_HISTORY+++             SELECT begin_time, end_time, intsize_csec,            group_id, metric_id, metric_name,            value, metric_unit, con_id          FROM   gv$sysmetric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$SYSMETRIC_SUMMARY+++             SELECT begin_time, end_time, intsize_csec,            group_id, metric_id, metric_name, num_interval, maxval, minval,            average, standard_deviation, metric_unit, con_id          FROM   gv$sysmetric_summary          WHERE  inst_id = USERENV('INSTANCE')
+++V$SYSSTAT+++                       select  STATISTIC# , NAME , CLASS , VALUE, STAT_ID, CON_ID from GV$SYSSTAT where inst_id = USERENV('Instance')
+++V$SYSTEM_CURSOR_CACHE+++           select  OPENS , HITS , HIT_RATIO, CON_ID from GV$SYSTEM_CURSOR_CACHE where inst_id = USERENV('Instance')
+++V$SYSTEM_EVENT+++                   select event,total_waits,total_timeouts,time_waited,average_wait,  time_waited_micro, total_waits_fg, total_timeouts_fg, time_waited_fg,  average_wait_fg, time_waited_micro_fg,  event_id, wait_class_id, wait_class#, wait_class, con_id   from gv$system_event where inst_id = USERENV('Instance')
+++V$SYSTEM_FIX_CONTROL+++            select  BUGNO,        VALUE,        SQL_FEATURE,        DESCRIPTION,        OPTIMIZER_FEATURE_ENABLE,        EVENT,        IS_DEFAULT,         CON_ID from GV$SYSTEM_FIX_CONTROL where inst_id=USERENV('Instance')
+++V$SYSTEM_PARAMETER+++              select  NUM , NAME , TYPE , VALUE , DISPLAY_VALUE, DEFAULT_VALUE,  ISDEFAULT , ISSES_MODIFIABLE , ISSYS_MODIFIABLE , ISPDB_MODIFIABLE , ISINSTANCE_MODIFIABLE, ISMODIFIED , ISADJUSTED , ISDEPRECATED, ISBASIC, DESCRIPTION, UPDATE_COMMENT, HASH, CON_ID from GV$SYSTEM_PARAMETER where inst_id = USERENV('Instance')
+++V$SYSTEM_PARAMETER2+++             select  NUM, NAME, TYPE, VALUE, DISPLAY_VALUE, ISDEFAULT, ISSES_MODIFIABLE, ISSYS_MODIFIABLE , ISPDB_MODIFIABLE , ISINSTANCE_MODIFIABLE, ISMODIFIED , ISADJUSTED , ISDEPRECATED, ISBASIC, DESCRIPTION, ORDINAL, UPDATE_COMMENT, CON_ID from GV$SYSTEM_PARAMETER2 where inst_id = USERENV('Instance')
+++V$SYSTEM_PARAMETER4+++             select SID, NUM, NAME, TYPE, DISPLAY_VALUE, ORDINAL, UPDATE_COMMENT,  PARAM_FLAG, CON_ID from GV$SYSTEM_PARAMETER4  where INST_id = USERENV('Instance')
+++V$SYSTEM_WAIT_CLASS+++             select wait_class_id, wait_class#,wait_class,total_waits,time_waited, total_waits_fg, time_waited_fg, con_id from gv$system_wait_class where inst_id = USERENV('Instance')
+++V$SYS_OPTIMIZER_ENV+++             select ID,                 NAME,               SQL_FEATURE,                  ISDEFAULT,                    VALUE,                        DEFAULT_VALUE,                CON_ID       from   GV$SYS_OPTIMIZER_ENV     where  INST_ID = USERENV('Instance')
+++V$SYS_REPORT_REQUESTS+++           select con_id, report_class, report_ref, ref_len, priority,   generation_time   from GV$SYS_REPORT_REQUESTS   where inst_id = USERENV('Instance')
+++V$SYS_REPORT_STATS+++              select con_id, execution_mode, num_queued_requests, num_failed_requests,         num_failed_cycles, last_failed_cycle_time, cycles_since_stats_reset,         last_cycle_time, last_stats_reset_time,         last_purge_time, available_dbtime,         avg_db_time, avg_cpu_time, avg_userio_time, db_time,         cpu_time, userio_time  from gv$sys_report_stats  where inst_id = USERENV('Instance')
+++V$SYS_TIME_MODEL+++                select STAT_ID, STAT_NAME, VALUE, CON_ID from GV$SYS_TIME_MODEL  where inst_id = USERENV('Instance')
+++V$TABLESPACE+++                    select  TS# , NAME, INCLUDED_IN_DATABASE_BACKUP, BIGFILE, FLASHBACK_ON, ENCRYPT_IN_BACKUP, CON_ID from GV$TABLESPACE where inst_id = USERENV('Instance')
+++V$TEMPFILE+++                      select  FILE# , CREATION_CHANGE# , CREATION_TIME , TS# , RFILE# , STATUS , ENABLED , BYTES, BLOCKS, CREATE_BYTES , BLOCK_SIZE , NAME, CON_ID from GV$TEMPFILE where inst_id = USERENV('Instance')
+++V$TEMPORARY_LOBS+++                select SID, CACHE_LOBS, NOCACHE_LOBS, ABSTRACT_LOBS, CON_ID             from GV$TEMPORARY_LOBS             where inst_id = USERENV('Instance')
+++V$TEMPSTAT+++                      select  FILE# , PHYRDS , PHYWRTS , PHYBLKRD , PHYBLKWRT , SINGLEBLKRDS,  READTIM , WRITETIM, SINGLEBLKRDTIM, AVGIOTIM, LSTIOTIM, MINIOTIM, MAXIORTM,  MAXIOWTM, CON_ID  from GV$TEMPSTAT where inst_id = USERENV('Instance')
+++V$TEMPUNDOSTAT+++                  select      begin_time, end_time, undotsn, txncount, maxconcurrency, maxquerylen,      maxqueryid, undoblkcnt, extcnt, uscount, ssolderrcnt, nospaceerrcnt,       con_id    from GV$TEMPUNDOSTAT where inst_id = USERENV('Instance')
+++V$TEMP_CACHE_TRANSFER+++           select  file_number,                                               x_2_null, x_2_null_forced_write, x_2_null_forced_stale,            x_2_s, x_2_s_forced_write,                                         s_2_null, s_2_null_forced_stale,                                   rbr, rbr_forced_write,                                             null_2_x, s_2_x, null_2_s, con_id                                  from gv$temp_cache_transfer                                        where inst_id = USERENV('Instance')
+++V$TEMP_EXTENT_MAP+++               select  TABLESPACE_NAME , FILE_ID , BLOCK_ID , BYTES , BLOCKS , OWNER , RELATIVE_FNO, CON_ID from GV$TEMP_EXTENT_MAP where inst_id = USERENV('Instance')
+++V$TEMP_EXTENT_POOL+++              select  TABLESPACE_NAME , FILE_ID , EXTENTS_CACHED , EXTENTS_USED , BLOCKS_CACHED , BLOCKS_USED , BYTES_CACHED , BYTES_USED , RELATIVE_FNO, CON_ID from GV$TEMP_EXTENT_POOL where inst_id = USERENV('Instance')
+++V$TEMP_PING+++                     select  file_number, frequency,                                    x_2_null, x_2_null_forced_write, x_2_null_forced_stale,            x_2_s, x_2_s_forced_write, x_2_ssx, x_2_ssx_forced_write,          s_2_null, s_2_null_forced_stale, ss_2_null, ss_2_rls, wrb, wrb_forced_write, rbr, rbr_forced_write, rbr_forced_stale, cbr, cbr_forced_write,    null_2_x, s_2_x, ssx_2_x, null_2_s, null_2_ss, op_2_ss, con_id             from gv$temp_ping                                                  where inst_id = USERENV('Instance')
+++V$TEMP_SPACE_HEADER+++             select  TABLESPACE_NAME , FILE_ID , BYTES_USED , BLOCKS_USED , BYTES_FREE , BLOCKS_FREE , RELATIVE_FNO, CON_ID from GV$TEMP_SPACE_HEADER where inst_id = USERENV('Instance')
+++V$THREAD+++                        select  THREAD# , STATUS , ENABLED , GROUPS , INSTANCE , OPEN_TIME , CURRENT_GROUP# , SEQUENCE# , CHECKPOINT_CHANGE# , CHECKPOINT_TIME , ENABLE_CHANGE# , ENABLE_TIME , DISABLE_CHANGE# , DISABLE_TIME, LAST_REDO_SEQUENCE#, LAST_REDO_BLOCK, LAST_REDO_CHANGE#, LAST_REDO_TIME, CON_ID from GV$THREAD where inst_id = USERENV('Instance')
+++V$THRESHOLD_TYPES+++               SELECT metrics_id, metrics_group_id, operator_mask, object_type,            alert_reason_id, metric_value_type, con_id          FROM gv$threshold_types          WHERE inst_id = USERENV('INSTANCE')
+++V$TIMER+++                         select  HSECS, CON_ID from GV$TIMER where inst_id = USERENV('Instance')
+++V$TIMEZONE_FILE+++                 select FILENAME, VERSION, CON_ID          from GV$TIMEZONE_FILE
+++V$TIMEZONE_NAMES+++                select TZNAME, TZABBREV, CON_ID          from GV$TIMEZONE_NAMES
+++V$TOPLEVELCALL+++                  select top_level_call#, top_level_call_name, con_id  from gv$toplevelcall where inst_id = USERENV('Instance')
+++V$TRANSACTION+++                   select  ADDR , XIDUSN , XIDSLOT , XIDSQN , UBAFIL , UBABLK , UBASQN , UBAREC , STATUS , START_TIME , START_SCNB , START_SCNW , START_UEXT , START_UBAFIL , START_UBABLK , START_UBASQN , START_UBAREC , SES_ADDR , FLAG , SPACE , RECURSIVE , NOUNDO , PTX , NAME,PRV_XIDUSN , PRV_XIDSLT , PRV_XIDSQN , PTX_XIDUSN , PTX_XIDSLT , PTX_XIDSQN , "DSCN-B" , "DSCN-W" , USED_UBLK , USED_UREC , LOG_IO , PHY_IO , CR_GET , CR_CHANGE, START_DATE, DSCN_BASE, DSCN_WRAP, START_SCN, DEPENDENT_SCN, XID, PRV_XID, PTX_XID, CON_ID from gv$transaction where inst_id = USERENV('Instance')
+++V$TRANSACTION_ENQUEUE+++           select  ADDR , KADDR , SID , TYPE , ID1 , ID2 , LMODE , REQUEST , CTIME , BLOCK, CON_ID from GV$TRANSACTION_ENQUEUE where inst_id = USERENV('Instance')
+++V$TRANSPORTABLE_PLATFORM+++        SELECT PLATFORM_ID, PLATFORM_NAME,          decode(endian_format, 1,'Big' ,0,'Little','UNKNOWN FORMAT'), CON_ID          FROM  x$kcpxpl
+++V$TSDP_SUPPORTED_FEATURE+++        select            FEATURE_NAME, FUNCTIONALITY, COMMENTS$, CON_ID          from GV$TSDP_SUPPORTED_FEATURE where INST_ID = USERENV('Instance')
+++V$TSM_SESSIONS+++                  select sid, serial#, state, migratable, migration_allowed, transferable,  migration_boundary, nonmigratability_reason, nonmigratability_info,  nontransferability_reason, nontransferability_info,  stateless, preserve_state, cost, destination, roundtrips,  blocking_component, start_time, sequence_number, con_id  from gv$tsm_sessions where inst_id = USERENV('Instance')
+++V$TYPE_SIZE+++                     select  COMPONENT , TYPE , DESCRIPTION , TYPE_SIZE, CON_ID  from GV$TYPE_SIZE where inst_id = USERENV('Instance')
+++V$UNDOSTAT+++                      select      to_date(KTUSMSTRBEGTIME,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),      to_date(KTUSMSTRENDTIME,'MM/DD/RR HH24:MI:SS','NLS_CALENDAR=Gregorian'),      KTUSMSTTSN, KTUSMSTUSU, KTUSMSTTCT, KTUSMSTMQL, KTUSMSTRMQI, KTUSMSTMTC,      KTUSMSTUAC, KTUSMSTUBS, KTUSMSTUBR, KTUSMSTXAC, KTUSMSTXBS,  KTUSMSTXBR,      KTUSMSTSOC, KTUSMSTOOS, KTUSMSTABK, KTUSMSTUBK, KTUSMSTEBK,  KTUSMSTTUR,      CON_ID    from X$KTUSMST where INST_ID = userenv('instance')
+++V$UNIFIED_AUDIT_RECORD_FORMAT+++   SELECT COMPONENT, AUDIT_TYPE, FIELD_SEQ#, FIELD_TYPE, FIELD_LENGTH, VERSION_ADDED, VERSION_REMOVED, CON_ID FROM X$UNIFIED_AUDIT_RECORD_FORMAT
+++V$UNIFIED_AUDIT_TRAIL+++           select audit_type, sessionid, proxy_sessionid,         os_user, host_name, terminal, instance_id, dbid,         authentication_type, userid, proxy_userid, external_userid,         global_userid, client_program_name, dblink_info,         xs_user_name, xs_sessionid,         entry_id, statement_id, event_timestamp, action, return_code,         os_process, transaction_id, scn, execution_id, obj_owner, obj_name,           sql_text, sql_binds, application_contexts,         client_identifier, new_owner, new_name, object_edition,           system_privilege_used, system_privilege, audit_option,           object_privileges, role, target_user,           excluded_user, excluded_schema, excluded_object, additional_info,           unified_audit_policies, fga_policy_name, xs_inactivity_timeout,           xs_entity_type, xs_target_principal_name, xs_proxy_user_name,           xs_datasec_policy_name, xs_schema_name,           xs_callback_event_type, xs_package_name,           xs_procedure_name, xs_enabled_role, xs_cookie,           xs_ns_name, xs_ns_attribute, xs_ns_attribute_old_val,           xs_ns_attribute_new_val,           dv_action_code, dv_action_name, dv_extended_action_code, dv_grantee,           dv_return_code, dv_action_object_name,           dv_rule_set_name, dv_comment, dv_factor_context,           dv_object_status, ols_policy_name, ols_grantee, ols_max_read_label,           ols_max_write_label, ols_min_write_label, ols_privileges_granted,           ols_program_unit_name, ols_privileges_used, ols_string_label,           ols_label_component_type, ols_label_component_name,           ols_parent_group_name, ols_old_value, ols_new_value,           rman_session_recid, rman_session_stamp, rman_operation,           rman_object_type, rman_device_type,          dp_text_parameters1, dp_boolean_parameters1,           direct_path_num_columns_loaded,           con_id from gv$unified_audit_trail where inst_id = USERENV('Instance')
+++V$UNUSABLE_BACKUPFILE_DETAILS+++   select b.session_recid session_key, b.session_recid, b.session_stamp,   a.*, 1  from   (select a.rman_status_recid, a.rman_status_stamp,        'BACKUPSET' btype, b.recid btype_key, a.set_stamp id1, a.set_count id2,       'BACKUPPIECE' filetype,b.recid filetype_key,a.status,a.bytes filesize,         a.device_type, a.handle filename, a.media, a.media_pool      from v$backup_piece a, v$backup_set b  where         a.set_stamp = b.set_stamp and a.set_count = b.set_count and         status <> 'A'   union   select rman_status_recid, rman_status_stamp,         'IMAGECOPY', recid, recid, stamp, 'DATAFILECOPY', recid, status,         (blocks+1)*block_size, 'DISK', name, null, null       from v$datafile_copy where status <> 'A' and file#<>0   union   select rman_status_recid, rman_status_stamp,         'IMAGECOPY', recid, recid, stamp, 'CONTROLFILECOPY', recid, status,         (blocks+1)*block_size, 'DISK', name, null, null       from v$datafile_copy where status <> 'A' and file#=0   union   select rman_status_recid, rman_status_stamp,         'PROXYCOPY', recid, recid, stamp, 'DATAFILECOPY', recid, status,         (blocks+1)*block_size, device_type, handle, media, media_pool      from v$proxy_datafile where status <> 'A' and file#<>0   union   select rman_status_recid, rman_status_stamp,         'PROXYCOPY', recid, recid, stamp, 'CONTROLFILECOPY', recid, status,         (blocks+1)*block_size, device_type, handle, media, media_pool      from v$proxy_datafile where status <> 'A' and file#=0   union   select rman_status_recid, rman_status_stamp,         'PROXYCOPY', recid, recid, stamp, 'ARCHIVELOGCOPY', recid, status,         (blocks+1)*block_size, device_type, handle, media, media_pool      from v$proxy_archivedlog where status <> 'A') a, v$rman_status b,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionkey skey from dual) c,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionfromTimeRange fTime        from dual) d,   (select /*+ no_merge */ sys.dbms_rcvman.sv_getsessionuntilTimeRange uTime        from dual) e    where  a.rman_status_recid = b.recid (+) and            a.rman_status_stamp = b.stamp (+) and            (c.skey is null or c.skey = b.session_recid) and           (d.fTime is null or d.fTime <= b.start_time) and           (e.uTime is null or e.uTime >= b.end_time)
+++V$VERSION+++                       select  BANNER, CON_ID from GV$VERSION where inst_id = USERENV('Instance')
+++V$VPD_POLICY+++                    select ADDRESS,PARADDR,SQL_HASH,SQL_ID,CHILD_NUMBER,        OBJECT_OWNER,        OBJECT_NAME,POLICY_GROUP,POLICY,POLICY_FUNCTION_OWNER,PREDICATE,CON_ID         from GV$VPD_POLICY  where inst_id = USERENV('Instance')
+++V$WAITCLASSMETRIC+++               SELECT begin_time, end_time, intsize_csec,            wait_class#, wait_class_id, average_waiter_count,            dbtime_in_wait, time_waited, wait_count,            time_waited_fg, wait_count_fg, con_id          FROM gv$waitclassmetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$WAITCLASSMETRIC_HISTORY+++       SELECT begin_time, end_time, intsize_csec,            wait_class#, wait_class_id, average_waiter_count,            dbtime_in_wait, time_waited, wait_count,            time_waited_fg, wait_count_fg, con_id          FROM gv$waitclassmetric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$WAITSTAT+++                      select class,count,time, con_id from gv$waitstat where inst_id = USERENV('Instance')
+++V$WAIT_CHAINS+++                   select  s.chain_id,  decode(s.chain_is_cycle, 0,'FALSE','TRUE'),  s.chain_signature, s.chain_signature_hash,   s.instance, s.osid, s.pid, s.sid,  s.sess_serial#,  s.pdb_id, s.pdb_name,   decode(s.blocker_is_valid, 0,'FALSE','TRUE'),  decode(s.blocker_is_valid, 0, to_number(null), s.blocker_instance),  s.blocker_osid,  decode(s.blocker_is_valid, 0, to_number(null), s.blocker_pid),  decode(s.blocker_is_valid, 0, to_number(null), s.blocker_sid),  decode(s.blocker_is_valid, 0, to_number(null), s.blocker_sess_serial#),  decode(s.blocker_is_valid, 0, to_number(null), s.blocker_pdb_id),  s.blocker_pdb_name,  decode(s.blocker_chain_id, 0, to_number(null), s.blocker_chain_id),   decode(s.in_wait, 0,'FALSE','TRUE'),   decode(s.in_wait, 0, s.time_since_last_wait_secs, to_number(null)),   decode(s.in_wait, 0, to_number(null), s.wait_id),  decode(s.in_wait, 0, to_number(null), s.wait_event),  s.wait_event_text,  decode(s.in_wait, 0, to_number(null), s.p1),  s.p1_text,  decode(s.in_wait, 0, to_number(null), s.p2),  s.p2_text,  decode(s.in_wait, 0, to_number(null), s.p3),  s.p3_text,   decode(s.in_wait, 0, to_number(null), s.in_wait_secs),  decode(s.in_wait, 0, to_number(null), s.time_remaining_secs),  s.num_waiters,   decode(s.in_wait, 0, to_number(null), s.row_wait_obj#),  decode(s.in_wait, 0, to_number(null), s.row_wait_file#),  decode(s.in_wait, 0, to_number(null), s.row_wait_block#),  decode(s.in_wait, 0, to_number(null), s.row_wait_row#), s.con_id  from X$KSDHNG_CHAINS s
+++V$WALLET+++                        SELECT          CERT_ID, DN, SERIAL_NUM, ISSUER, KEYSIZE, STATUS, CON_ID          FROM GV$WALLET          WHERE inst_id = USERENV('INSTANCE')
+++V$WLM_PCMETRIC+++                  SELECT begin_time,                 end_time,                 intsize_csec,                 pc_name_hash,                 pc_name,                 requestspersec,                 errrequestspersec,                 responsetimeperrequest,                 cpuperrequest,                 cpuwaitperrequest,                 ioperrequest,                 iowaitperrequest,                 gcperrequest,                 gcwaitperrequest,                 niwaitperrequest,                 schwaitperrequest,                 con_id          FROM   gv$wlm_pcmetric          WHERE  inst_id = USERENV('INSTANCE')
+++V$WLM_PCMETRIC_HISTORY+++          SELECT begin_time,                 end_time,                 intsize_csec,                 pc_name_hash,                 pc_name,                 requestspersec,                 errrequestspersec,                 responsetimeperrequest,                 cpuperrequest,                 cpuwaitperrequest,                 ioperrequest,                 iowaitperrequest,                 gcperrequest,                 gcwaitperrequest,                 niwaitperrequest,                 schwaitperrequest,                 con_id          FROM   gv$wlm_pcmetric_history          WHERE  inst_id = USERENV('INSTANCE')
+++V$WLM_PC_STATS+++                  SELECT pc_name_hash,                 pc_name,                 stat_id ,                 stat_name ,                 value,                 con_id          FROM gv$wlm_pc_stats          WHERE inst_id = USERENV('Instance')
+++V$WORKLOAD_REPLAY_THREAD+++        SELECT clock, next_ticker,        sid, serial#, spid, logon_user, logon_time,        event, event_id, event#,        p1text, p1, p2text, p2, p3text, p3, wait_for_scn,        file_id, call_counter,        dependent_scn, statement_scn,        commit_wait_scn, post_commit_scn,        action_type, session_type, wrc_id, file_name,        skip_it, dirty_buffers,        dbtime, network_time, think_time,        time_gain, time_loss, user_calls,        client_os_user, client_host, client_pid, program, con_id FROM   GV$WORKLOAD_REPLAY_THREAD WHERE  inst_id = USERENV('INSTANCE')
+++V$XML_AUDIT_TRAIL+++               select AUDIT_TYPE, SESSION_ID, PROXY_SESSIONID, STATEMENTID, ENTRYID,        EXTENDED_TIMESTAMP, GLOBAL_UID, DB_USER, CLIENTIDENTIFIER, EXT_NAME,        OS_USER, OS_HOST, OS_PROCESS, TERMINAL, INSTANCE_NUMBER,        OBJECT_SCHEMA, OBJECT_NAME, POLICY_NAME, NEW_OWNER, NEW_NAME, ACTION,        STATEMENT_TYPE, TRANSACTIONID, RETURNCODE, SCN, COMMENT_TEXT,        AUTH_PRIVILEGES, GRANTEE, PRIV_USED, SES_ACTIONS, OS_PRIVILEGE,        ECONTEXT_ID, SQL_BIND, SQL_TEXT, OBJ_EDITION_NAME, DBID, CON_ID from GV$XML_AUDIT_TRAIL where inst_id=USERENV('Instance')
+++V$XSTREAM_APPLY_COORDINATOR+++     SELECT SID, SERIAL#, STATE, APPLY#, APPLY_NAME, TOTAL_APPLIED,TOTAL_WAIT_DEPS,TOTAL_WAIT_COMMITS, TOTAL_ADMIN, TOTAL_ASSIGNED, TOTAL_RECEIVED,TOTAL_IGNORED, TOTAL_ROLLBACKS, TOTAL_ERRORS, UNASSIGNED_COMPLETE_TXNS,LWM_TIME, LWM_MESSAGE_NUMBER, LWM_MESSAGE_CREATE_TIME,HWM_TIME, HWM_MESSAGE_NUMBER, HWM_MESSAGE_CREATE_TIME,STARTUP_TIME, ELAPSED_SCHEDULE_TIME, ELAPSED_IDLE_TIME,LWM_POSITION, HWM_POSITION, PROCESSED_MESSAGE_NUMBER, CON_ID,ACTIVE_SERVER_COUNT from GV$XSTREAM_APPLY_COORDINATOR WHERE INST_ID = USERENV('Instance')
+++V$XSTREAM_APPLY_READER+++          select SID, SERIAL#, APPLY#, APPLY_NAME, STATE, TOTAL_MESSAGES_DEQUEUED, TOTAL_MESSAGES_SPILLED, DEQUEUE_TIME, DEQUEUED_MESSAGE_NUMBER, DEQUEUED_MESSAGE_CREATE_TIME, SGA_USED, ELAPSED_DEQUEUE_TIME,  ELAPSED_SCHEDULE_TIME, ELAPSED_SPILL_TIME, OLDEST_SCN_NUM,  OLDEST_XIDUSN, OLDEST_XIDSLT, OLDEST_XIDSQN,  SPILL_LWM_SCN, PROXY_SID, PROXY_SERIAL, PROXY_SPID, BYTES_RECEIVED,  DEQUEUED_POSITION, SPILL_LWM_POSITION, OLDEST_TRANSACTION_ID,  TOTAL_LCRS_WITH_DEP, TOTAL_LCRS_WITH_WMDEP, TOTAL_IN_MEMORY_LCRS,  SGA_ALLOCATED, CON_ID from GV$XSTREAM_APPLY_READER where INST_ID = USERENV('Instance')
+++V$XSTREAM_APPLY_RECEIVER+++        select SID, SERIAL#, APPLY_NAME, STARTUP_TIME,                SOURCE_DATABASE_NAME, ACKNOWLEDGEMENT,LAST_RECEIVED_MSG,                TOTAL_MESSAGES_RECEIVED, TOTAL_AVAILABLE_MESSAGES,                STATE, LAST_RECEIVED_MSG_POSITION, ACKNOWLEDGEMENT_POSITION,                CON_ID          from   GV$XSTREAM_APPLY_RECEIVER          where  INST_ID = USERENV('Instance')
+++V$XSTREAM_APPLY_SERVER+++          select SID, SERIAL#, APPLY#, APPLY_NAME,SERVER_ID, STATE, XIDUSN, XIDSLT, XIDSQN, COMMITSCN,DEP_XIDUSN, DEP_XIDSLT, DEP_XIDSQN, DEP_COMMITSCN, MESSAGE_SEQUENCE,TOTAL_ASSIGNED, TOTAL_ADMIN, TOTAL_ROLLBACKS,TOTAL_MESSAGES_APPLIED, APPLY_TIME, APPLIED_MESSAGE_NUMBER, APPLIED_MESSAGE_CREATE_TIME,ELAPSED_DEQUEUE_TIME, ELAPSED_APPLY_TIME, COMMIT_POSITION, DEP_COMMIT_POSITION, LAST_APPLY_POSITION, TRANSACTION_ID, DEP_TRANSACTION_ID, CON_ID, TOTAL_LCRS_RETRIED, LCR_RETRY_ITERATION, TOTAL_TXNS_RETRIED, TXN_RETRY_ITERATION, TOTAL_TXNS_RECORDED  from GV$XSTREAM_APPLY_SERVER where INST_ID = USERENV('Instance')
+++V$XSTREAM_CAPTURE+++               select SID, SERIAL#, CAPTURE#, CAPTURE_NAME, LOGMINER_ID,        STARTUP_TIME, STATE, TOTAL_PREFILTER_DISCARDED, TOTAL_PREFILTER_KEPT,        TOTAL_PREFILTER_EVALUATIONS,TOTAL_MESSAGES_CAPTURED, CAPTURE_TIME,        CAPTURE_MESSAGE_NUMBER, CAPTURE_MESSAGE_CREATE_TIME,        TOTAL_MESSAGES_CREATED, TOTAL_FULL_EVALUATIONS,        TOTAL_MESSAGES_ENQUEUED, ENQUEUE_TIME, ENQUEUE_MESSAGE_NUMBER,        ENQUEUE_MESSAGE_CREATE_TIME, AVAILABLE_MESSAGE_NUMBER,        AVAILABLE_MESSAGE_CREATE_TIME, ELAPSED_CAPTURE_TIME,        ELAPSED_RULE_TIME,ELAPSED_ENQUEUE_TIME,        ELAPSED_LCR_TIME, ELAPSED_REDO_WAIT_TIME, ELAPSED_PAUSE_TIME,         STATE_CHANGED_TIME,         SGA_USED, SGA_ALLOCATED, BYTES_OF_REDO_MINED,         SESSION_RESTART_SCN, CON_ID  from   GV$XSTREAM_CAPTURE  where  INST_ID = USERENV('Instance')
+++V$XSTREAM_MESSAGE_TRACKING+++      select TRACKING_LABEL, TAG, COMPONENT_NAME, COMPONENT_TYPE,         ACTION, ACTION_DETAILS, TIMESTAMP, MESSAGE_CREATION_TIME,                     MESSAGE_NUMBER, TRACKING_ID,                SOURCE_DATABASE_NAME, OBJECT_OWNER, OBJECT_NAME,         XID, COMMAND_TYPE, MESSAGE_POSITION, CON_ID                    from   GV$XSTREAM_MESSAGE_TRACKING          where  INST_ID = USERENV('Instance')
+++V$XSTREAM_OUTBOUND_SERVER+++       SELECT SID, SERIAL#, SPID, SERVER_NAME, STARTUP_TIME, STATE, XIDUSN, XIDSLT, XIDSQN, COMMITSCN, TOTAL_TRANSACTIONS_SENT, MESSAGE_SEQUENCE, TOTAL_MESSAGES_SENT, SEND_TIME, LAST_SENT_MESSAGE_NUMBER, LAST_SENT_MESSAGE_CREATE_TIME, ELAPSED_SEND_TIME, COMMIT_POSITION, LAST_SENT_POSITION, BYTES_SENT, COMMITTED_DATA_ONLY, CON_ID  from GV$XSTREAM_OUTBOUND_SERVER where INST_ID = USERENV('Instance')
+++V$XSTREAM_TABLE_STATS+++           select APPLY_NAME, SERVER_ID, SOURCE_TABLE_OWNER, SOURCE_TABLE_NAME,                DESTINATION_TABLE_OWNER, DESTINATION_TABLE_NAME,                 LAST_UPDATE, TOTAL_INSERTS, TOTAL_UPDATES, TOTAL_DELETES,                INSERT_COLLISIONS, UPDATE_COLLISIONS, DELETE_COLLISIONS,                REPERROR_RECORDS, REPERROR_IGNORES, WAIT_DEPENDENCIES, CON_ID,                CDR_INSERT_ROW_EXISTS, CDR_UPDATE_ROW_EXISTS,                 CDR_UPDATE_ROW_MISSING, CDR_DELETE_ROW_EXISTS,                 CDR_DELETE_ROW_MISSING,                 CDR_SUCCESSFUL_RESOLUTIONS, CDR_FAILED_RESOLUTIONS,                 LOB_OPERATIONS          from   GV$XSTREAM_TABLE_STATS          where  INST_ID = USERENV('Instance')
+++V$XSTREAM_TRANSACTION+++           select COMPONENT_NAME, COMPONENT_TYPE, XIDUSN, XIDSLT, XIDSQN,                 CUMULATIVE_MESSAGE_COUNT, TOTAL_MESSAGE_COUNT,                 FIRST_MESSAGE_TIME, FIRST_MESSAGE_NUMBER,                LAST_MESSAGE_TIME, LAST_MESSAGE_NUMBER,                 FIRST_MESSAGE_POSITION, LAST_MESSAGE_POSITION,                 TRANSACTION_ID, CON_ID                               from   GV$XSTREAM_TRANSACTION          where  INST_ID = USERENV('Instance')
+++V$XS_SESSIONS+++                   select sid, db_sid, serial#, con_id from gv$xs_sessions  where inst_id = userenv('Instance')
+++V$XS_SESSION_NS_ATTRIBUTE+++       SELECT namespace_name, workspace_name, attribute_name,         attribute_value, attribute_events, attribute_default_value,         attribute_type, con_id  FROM GV$XS_SESSION_NS_ATTRIBUTE  WHERE  INST_ID = USERENV('Instance')
+++V$XS_SESSION_ROLE+++               SELECT role_wspace, role_name, flags, con_id  FROM   GV$XS_SESSION_ROLE  WHERE  INST_ID = USERENV('Instance')
+++V$_LOCK+++                         select  LADDR , KADDR , SADDR , RADDR , LMODE , REQUEST , CTIME , BLOCK, CON_ID from GV$_LOCK where inst_id = USERENV('Instance')
+++V$_LOCK1+++                        select  LADDR , KADDR , SADDR , RADDR , LMODE , REQUEST , CTIME , BLOCK, CON_ID from GV$_LOCK1 where inst_id = USERENV('Instance')
+++V$_SEQUENCES+++                    select  SEQUENCE_OWNER , SEQUENCE_NAME , OBJECT# , ACTIVE_FLAG , REPLENISH_FLAG , WRAP_FLAG , NEXTVALUE , MIN_VALUE , MAX_VALUE , INCREMENT_BY , CYCLE_FLAG , ORDER_FLAG , CACHE_SIZE , HIGHWATER , BACKGROUND_INSTANCE_LOCK , INSTANCE_LOCK_FLAGS, CON_ID, SESSION_PRIVATE_ON_STANDBY from GV$_SEQUENCES where inst_id = USERENV('Instance')

